<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[八、Spring Boot错误处理详解]]></title>
    <url>%2F2019%2F08%2F25%2FSpring-Boot%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[九、Spring Boot错误处理详解]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Sprng Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六、Spring Boot整合FreeMarker]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%B8%83%E3%80%81Spring-Boot%E6%95%B4%E5%90%88FreeMarker%2F</url>
    <content type="text"><![CDATA[七、Spring Boot整合FreeMarker]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis[从入门到基本精通]]]></title>
    <url>%2F2019%2F08%2F25%2FMyBatis-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%9F%BA%E6%9C%AC%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[MyBatis【从入门到基本精通】 一、MyBatis的基本使用1、MyBatis作用 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML用于配置和原始映射，将接口和Java的POJO类映射成数据库中的记录 使开发者只需要关注 SQL本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 2.MyBatis的历史 原是apache的一个开源项目iBatis，2010年6月这个项目由apache software foundation迁移到了google code，并且改名为MyBatis 。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 3.为什么要使用MyBatis？JDBC的缺点 SQL夹在Java代码块里，耦合度高导致硬编码内伤 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 要自已创建connection、创建statement、手动设置参数、结果集检索等 Hibernate的缺点 长难复杂SQL，对于Hibernate而言处理也不容易 内部自动生产的SQL，不容易做特殊优化。 MyBatis的好处： 对开发人员而言，核心sql还是需要自己优化 MyBatis是一个半自动化的持久化层框架。 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 二、MyBatis的开发步骤1、下载Mybatis核心包http://www.mybatis.org/mybatis-3/getting-started.html https://github.com/mybatis/mybatis-3/releases 2、创建工程,引入MyBatis核心包及依赖包 3、创建customer表123456781 CREATE TABLE customer(2 cust_id int PRIMARY KEY,3 cust_name varchar(50),4 cust_profession VARCHAR(50),5 cust_phone VARCHAR(50),6 cust_email VARCHAR(50)7 )1234567 4、建立与表对象的domain，创建Customer实体类我在IDEA中用了lombok jar包1234567891011121314151617181920212223242526 package com.lqg.domain; 2 3 import lombok.Getter; 4 import lombok.Setter; 5 6 @Setter@Getter 7 public class Customer &#123; 8 9 private Integer cust_id;10 private String cust_name;11 private String cust_profession;12 private String cust_phone;13 private String cust_email;14 15 @Override16 public String toString() &#123;17 return "Customer&#123;" +18 "cust_id=" + cust_id +19 ", cust_name='" + cust_name + '\'' +20 ", cust_profession='" + cust_profession + '\'' +21 ", cust_phone='" + cust_phone + '\'' +22 ", cust_email='" + cust_email + '\'' +23 '&#125;';24 &#125;25 &#125;12345678910111213141516171819202122232425 5、创建与表对象的关系映射Mapping文件编写sql语句12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt; 2 &lt;!DOCTYPE mapper 3 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 4 "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; 5 &lt;mapper namespace="Mytest"&gt; 6 &lt;!--根据id查询用户--&gt; 7 &lt;select id="queryCustomerById" parameterType="Int" resultType="com.lqg.domain.Customer"&gt; 8 select * from `customer` where cust_id = #&#123;cust_id&#125; 9 &lt;/select&gt;10 11 &lt;/mapper&gt;123456789101112 6、在核心配置文件当中引入Mapping12345&lt;!--加载映射文件--&gt;&lt;mappers&gt;&lt;mapper resource="com/lqg/domain/Customer.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt;1234 7、创建工厂,执行sql语句1234567891011121314151617181920212223242526272829303132package com.lqg.test;import com.lqg.domain.Customer;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MyBatisTest &#123; @Test public void test() throws IOException &#123; //1.创建一个SqlSessionFactoryBulider的类 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //2.加载SqlMapConfig.xml的配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); //3.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); //4.创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //5.用sqlSession对象执行查询 Customer customer = sqlSession.selectOne("queryCustomerById",1); System.out.println(customer); &#125;&#125;12345678910111213141516171819202122232425262728293031 8通过用户id查询结果如下： 三. MyBatis的入门程序：4.1、MyBatis的CRUD操作MyBatis查询一个，多个以及增删改 4.4.1通过用户id进行查询对应映射配置 1234&lt;select id="queryCustomerById" parameterType="Int" resultType="com.domain.Customer"&gt; SELECT * FROM `customer` WHERE cust_id = #&#123;cust_id&#125;&lt;/select&gt;123 在测试类里面查询 12Customer c = session.selectOne("queryCustomerById", 1);1 查询所有用户在对应的映射文件里面配置 1234&lt;select id="queryAllCustomer" resultType="com.domain.Customer"&gt; select * from customer &lt;/select&gt;123 模糊查询（同查询所有差不多） 1234&lt;select id="queryAllByName" parameterType="String" resultType="com.lqg.domain.Customer"&gt; select * from customer where cust_name like '%$&#123;value&#125;%'&lt;/select&gt;123 4.4.2、总结 parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中 selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常 selectList可以查询一条或多条记录 #{}表示一个？占位符号，通过#{}可以实现preparedStatement向占位符中设置值自动进行java类型和jdbc类型转换，可以有效防止sql注入#{}可以接收简单类型值或pojo属性值如果parameterType传输单个简单类型值,#{}括号中可以是value或其它名称里面的参数传递过来都是加上’’引号的， 表示拼接sql串，可以接收简单类型值或pojo属性值通过{} 表示拼接sql串，可以接收简单类型值或pojo属性值 通过表示拼接s*ql串，可以接收简单类型值或pojo*属性值通过{}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换如果parameterType传输单个简单类型值，${}括号中只能是value 5、保存更新删除5.1添加用户对应关系映射配置 12345&lt;insert id="insertCustomer" parameterType="com.domain.Customer"&gt; insert into `customer` values(#&#123;cust_id&#125;,#&#123;cust_name&#125;,#&#123;cust_profession&#125;, #&#123;cust_phone&#125;,#&#123;cust_email&#125;)&lt;/insert&gt;1234 注意：如果添加操作后面直接跟的表名，赋值里面的所有字段都要写上包括自动增长的id，如果是跟字段那值就跟上自己写的字段一一对应 5.5.1、添加用户的方法测试代码 12345SqlSession session = MyBatisUtils.openSession(); Customer customer = new Customer("老王","服务员","17364343463","748639224@qq.com"); session.insert("insertCustomer",customer); session.commit();1234 注意：当要修改数据库中的记录的时候，执行sql时候需要自己提交事务 5.5.2、返回添加过后自增的主键两种方式方式一：获取插入最后一个id（写在insert标签里面） 1234&lt;selectKey keyColumn="cust_id" keyProperty="cust_id" resultType="Integer" order="AFTER"&gt; select last_insert_id()&lt;/selectKey&gt;123 方式二：获取插入的最后一个id(这种方式比第一种简单)* 1234567&lt;insert id="insertCustomer" parameterType="Customer" useGeneratedKeys="true" keyProperty="cust_id" keyColumn="cust_id"&gt; //keyColumn可以不写 insert into customer(cust_name,cust_profession,cust_phone) values(#&#123;cust_name&#125;,#&#123;cust_profession&#125;,#&#123;cust_phone&#125;);&lt;/insert&gt; 123456 5.2更新用户对应关系映射配置 1234&lt;update id="updateCustomerById" parameterType="com.lqg.domain.Customer"&gt; update customer set cust_name =#&#123;cust_name&#125; where cust_id = #&#123;cust_id&#125;&lt;/update&gt;123 5.2.1、修改用户的方法测试代码 123456789Customer customer1 = new Customer(); customer1.setCust_id(7); customer1.setCust_name("王麻子"); customer1.setCust_profession("清洁工"); customer1.setCust_email("78754579846"); int row= sqlSession.insert("saveCustomer",customer1); int row2 = sqlSession.update("updateCustomerById",customer1); session.commit();12345678 5.3删除用户对应关系映射配置 1234&lt;delete id="deleteCustomerById" parameterType="com.lqg.domain.Customer"&gt; delete from customer where cust_id=#&#123;cust_id&#125;&lt;/delete&gt;123 5.3.1、修改用户的方法测试代码 12345678910 Customer customer1 = new Customer(); customer1.setCust_id(7); customer1.setCust_name("王麻子"); customer1.setCust_profession("清洁工"); customer1.setCust_email("78754579846"); int row= sqlSession.insert("saveCustomer",customer1); int row2 = sqlSession.update("updateCustomerById",customer1); sqlSession.delete("deleteCustomerById",7) session.commit();123456789 四、MyBatis开发Dao1、原始的Dao开发方法1.1、创建CustomerDao接口类 123456789101112package com.lqg.dao;import com.lqg.domain.Customer;import java.util.List;public interface CustomerDao &#123; public Customer findCustomerById(Long cust_id); public List&lt;Customer&gt; findAllCustomer(); public int saveCustomer(Customer customer);&#125;1234567891011 1.2、创建CustomerDao接口类的实现类CustomerDaoImpl 123456789101112131415161718192021222324252627282930313233343536package com.lqg.daoImpl;import com.lqg.dao.CustomerDao;import com.lqg.domain.Customer;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class CustomerDaoImpl implements CustomerDao &#123; private SqlSessionFactory sqlSessionFactory; public CustomerDaoImpl(SqlSessionFactory sqlSessionFactory)&#123; this.sqlSessionFactory=sqlSessionFactory; &#125; @Override public Customer findCustomerById(Long cust_id) &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); Customer customer = sqlSession.selectOne("queryCustomerById", 2); return customer; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;Customer&gt; allCustomer = sqlSession.selectList("queryAllCustomer"); return allCustomer; &#125; @Override public int saveCustomer(Customer customer) &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); int customer1=sqlSession.insert("saveCustomer",customer); return customer1; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435 1.3、创建CustomerDao的测试类TestCustomerDao的测试类 123456789101112131415161718192021222324252627282930313233343536373839package com.lqg.test;import com.lqg.dao.CustomerDao;import com.lqg.daoImpl.CustomerDaoImpl;import com.lqg.domain.Customer;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestCustomerDao &#123; private SqlSessionFactory sqlSessionFactory; public void init() throws IOException &#123; System.out.println("init"); //1.创建一个SqlSessionFactoryBulider的类 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //2.加载SqlMapConfig.xml的配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); //3.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125;@Testpublic void test()&#123; //创建CustomerDao的接口编程 CustomerDao customerDao = new CustomerDaoImpl(this.sqlSessionFactory); //通过id查询用户，然后保存到customer中 Customer customer = customerDao.findCustomerById(2L); System.out.println(customer); List&lt;Customer&gt; allCustomer = customerDao.findAllCustomer(); System.out.println(allCustomer); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738 2.Mapper动态代理2.1、Mapper动态代理开发的要求 namespace必须和Mapper接口类路径一致 id必须和Mapper接口方法名一致 parameterType必须和接口方法参数类型一致 resultType必须和接口方法返回值类型一致 2.2、先重新创建一张表 1234567CREATE TABLE tbl_employee&#123; id INT PRIMARY KEY auto_increment, last_name VARCHAR(255), gender CHAR(1), email VARCHAR(255)&#125;123456 2.3、这是演示的结构图2.4、创建一个Employee的pojo类 123456789101112131415package com.lqg.mybatis.domain;import lombok.Getter;import lombok.Setter;import lombok.ToString;@Setter@Getter@ToStringpublic class Employee &#123; private Integer id; private String lastName; private String gender; private String email;&#125;1234567891011121314 2.5、创建MyBatis的核心配置文件 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/lqg/mybatis/domain/EmployeeMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;123456789101112131415161718192021222324 2.6、创建pojo的接口类 12345678package com.lqg.mybatis.dao;import com.lqg.mybatis.domain.Employee;public interface EmployeeMapper &#123; public Employee getEmployeeById(Integer id);//方法名称为xml配置文件里面的对应操作语句的id名称&#125;1234567 2.7、创建pojo的映射EmployeeMapper.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql语句，后续有重要内容 --&gt; &lt;!-- 1. namespace必须和Mapper接口类路径一致 2. id必须和Mapper接口方法名一致 3. parameterType必须和接口方法参数类型一致 4. resultType必须和接口方法返回值类型一致--&gt;&lt;!--public Employee getEmployeeById(Integer id);--&gt;&lt;mapper namespace="com.lqg.mybatis.dao.EmployeeMapper"&gt; &lt;select id="getEmployeeById" resultType="com.lqg.mybatis.domain.Employee"&gt; select id,last_name lastName,gender,email from tbl_employee where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;12345678910111213141516 2.8、最后编写MyBatisTest的测试类 12345678910111213141516171819202122232425262728293031323334package com.lqg.mybatis.test;import com.lqg.mybatis.dao.EmployeeMapper;import com.lqg.mybatis.domain.Employee;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;public class MyBatisTest &#123; @Test public void test() throws IOException &#123; //1.创建一个SqlSessionFactoryBulider的类 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //2.加载mybatis-config.xml的配置文件 InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); //3.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); //4.创建SqlSession对象 SqlSession openSession = sqlSessionFactory.openSession(); //获取接口的实现类对象 EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);//接口的字节码 Employee employee=mapper.getEmployeeById(1);//方法为接口当中的方法 System.out.println(employee); openSession.close(); &#125;&#125;123456789101112131415161718192021222324252627282930313233 2.9、查询效果如下 五、MyBatis的参数传递1.单个参数 可以接受基本类型，对象类型，集合类型的值。 MyBatis可直接使用这个参数，不需要经过任何处理。 2.多个参数 任意多个参数，都会被MyBatis重新包装成一个Map传入。 Map的key是param1，param2…，值就是参数的值示例3.@param命名参数 为参数使用@Param起一个名字 MyBatis就会将这些参数封装进map中，key就是我们自己指定的名字示例4.pojo 当这些参数属于我们业务POJO时，我们直接传递POJO示例5.Map我们也可以封装多个参数为map，直接传递示例6.参数传递源码分析 会把参数给放到一个数组当中 如果一个参数, 内部处理时,会自动把该参数范围 如果是多个参数,内部会做判断 判断是否有@param注解 如果没有： 没有注解的话, 就直接使用arg0 arg1…为key 放到map中并且还会以param1和param2…为key放一份到map中 如果有 如果有注解的话, 会使用注解当中的值,替换掉默认的arg0和arg1 使用@param中的值,做为key 放到一个map当中并且还会以param1和param2…为key放一份到map中 六、MyBatis的核心配置文件1、 properties：定义属性及读取属性文件 示例 1234 &lt;properties resource="jdbc.properties"&gt; &lt;property name="jdbc.driver" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;&lt;/properties&gt;123 resource为资源文件，配置文件访问方法”${key名称}”,如访问数据库连接，如果配置了相同的property会先加载，resource里面的会把其覆盖掉 2、settings——这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为示例 123456 &lt;!--全局信息配置，--&gt; &lt;settings&gt; //配置打印sql信息 &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt; &lt;/settings&gt;12345 3、typeAliases——（定义别名，可以在使用时候省略掉前面一串路径） 1234567&lt;typeAliases&gt; &lt;!--单个别名--&gt; &lt;!--&lt;typeAlias type="domain.Customer" alias="Customer"&gt;&lt;/typeAlias&gt;--&gt; &lt;!--批量定义别名，别名为类名--&gt; &lt;package name="domain"&gt;&lt;/package&gt;&lt;/typeAliases&gt;123456 如果当前包类与子包类重名,会有异常，可以在类上使用注解@Alias(“别名”) 4、typeHandlers——（类型处理器）无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。JDK1.8之后实现全部的JSR310规范日期时间处理上，我们可以使用MyBatis基于JSR310（Date and Time API）编写的各种日期时间类型处理器。MyBatis3.4以前的版本需要我们手动注册这些处理器，以后的版本都是自动注册的 5、Plugins ——（插件）插件是MyBatis提供的一个非常强大的机制，MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。通过插件来修改MyBatis的一些核心行为。 6、Environments ——（数据库运行的环境）MyBatis可以配置多种环境，比如开发、测试和生产环境需要有不同的配置。每种环境使用一个environment标签进行配置并指定唯一标识符可以通过environments标签中的default属性指定一个环境的标识符来快速的切换环境Environment子标签transactionManager事务管理Type有以下取值JDBC使用JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务范围MANAGED不提交或回滚一个连接、让容器来管理事务的整个生命周期ManagedTransactionFactory自定义实现TransactionFactory接口type=全类名/别名dataSource数据源type有以下取值UNPOOLED不使用连接池UnpooledDataSourceFactoryPOOLED使用连接池PooledDataSourceFactoryJNDI在EJB 或应用服务器这类容器中查找指定的数据源自定义实现DataSourceFactory接口，定义数据源的获取方式实际开发实际开发中我们使用Spring管理数据源并进行事务控制的配置来覆盖上述配置 7、databaseIDProvider——（定义数据的厂商）MyBatis 可以根据不同的数据库厂商执行不同的语句。可以能过databaseIDProvider标签来进行设置 12345678910111213141516&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MYSQL" value="mysql"/&gt; &lt;property name="DB2" value="db2"/&gt; &lt;property name="Oracle" value="oracle" /&gt; &lt;property name="SQL Server" value="sqlserver"/&gt;&lt;/databaseIdProvider&gt;123456 示例1&lt;mapper namespace="mapper.CustomerDao"&gt; &lt;select id="getCustomerWithID" resultType="Customer" databaseId="mysql"&gt; //只有Mysql的数据库才能执行该语句 select * from customer where cust_id = #&#123;id名称&#125; and cust_name=#&#123;值&#125; &lt;/select&gt;&lt;/mapper&gt; 123456 8、mappers——（加载映射文件）8.1、使用文件路径引入映射器 12 &lt;mapper resource="domain/Customer.xml"&gt;&lt;/mapper&gt; 1 8.2、使用mapper接口类路径，此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中 1234&lt;mapper class=" " /&gt; 如&lt;mapper class="mapper.CustomerDao"&gt;&lt;/mapper&gt;123 8.3、使用包名引入映射器指定包下的所有mapper接口、批量加载、此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中 12&lt;package name=""/1 //加载对应包下面所有的文件 七、MyBatis的输出类型八、MyBatis【关联映射】1、MyBatis的多表连接1.1一对一 1.1.1设计表格：1234567891011121314151617181920--mysqlcreate table cards( cid int(5) primary key, cnum varchar(10));create table students( sid int(5) primary key, sname varchar(10), scid int(5), constraint scid_fk foreign key(scid) references cards(cid));insert into cards(cid,cnum) values(1,&apos;111&apos;);insert into students(sid,sname,scid) values(1,&apos;哈哈&apos;,1);select * from cards;select * from students;12345678910111213141516171819 1.1.2、实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 身份证(单方) * @author AdminTC */public class Card &#123; private Integer id; private String num; public Card()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNum() &#123; return num; &#125; public void setNum(String num) &#123; this.num = num; &#125;&#125;/** * 学生(单方) * @author AdminTC */public class Student &#123; private Integer id; private String name; private Card card;//关联属性 public Student()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Card getCard() &#123; return card; &#125; public void setCard(Card card) &#123; this.card = card; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 1.1.3、映射文件由于我们有两个实体，因此我们会有两个映射文件Student映射文件 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="studentNamespace"&gt; &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt;1234567891011 Card映射文件 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cardNamespace"&gt; &lt;resultMap type="zhongfucheng2.Card" id="cardMap"&gt; &lt;id property="id" column="cid"/&gt; &lt;result property="num" column="cnum"/&gt; &lt;/resultMap&gt; &lt;/mapper&gt;1234567891011select * from zhongfucheng.students s,zhongfucheng.cards c where c.cid = s.scid and sid=1;1 我来看一下查询结果：我们的实体与映射表中，Student实体是没有关联其他的字段的，仅仅是写出了该实体的自带的属性。 12345 &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;/resultMap&gt;1234 明显地，我们Student是不能封装返回的结果，因此我们需要将关联属性进行关联起来！ 1234567891011 &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;!-- property写的是在Student实体中写关联字段的属性变量名称 resultMap写的是映射文件中的命名空间.id --&gt; &lt;association property="card" resultMap="cardNamespace.cardMap"/&gt; &lt;/resultMap&gt;12345678910 我们关联了以后，Student实体就能够封装返回的结果了 12345678910111213141516171819202122232425&lt;!-- 因为使用多表联合查询， 那么查询结果中的列在对象中就没有对应的属性 所以需要我们自己去配置这些列与对象中的属性的映射关系 注意：并且需要给所有属性配置映射关系 --&gt; &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;!-- id子标签：用于配置主键的映射关系 ,这个id是下面的id column:查询结果中的列的列名 property:结果对象中的属性名 把列与属性之间关联起来：会把查询到的该列的值赋值给这个属性 &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;!-- property写的是在Student实体中写关联字段的属性变量名称 resultMap写的是映射文件中的命名空间.id --&gt; &lt;!-- 封装该对象的属性 与 查询语句结果的列的映射 关系 --&gt; &lt;association property="card" resultMap="cardNamespace.cardMap"/&gt; &lt;/resultMap&gt; &lt;select id="findById" parameterType="int" resultMap="studentMap"&gt; select * from zhongfucheng.students s,zhongfucheng.cards c where c.cid = s.scid and sid=#&#123;id&#125;; &lt;/select&gt;123456789101112131415161718192021222324 1.1.4查询编号为1的学生信息【包括身份证编号】12345678910111213141516171819202122232425 public Student findById(int id) throws Exception &#123; //得到连接对象 SqlSession sqlSession = MybatisUtil.getSqlSession(); try&#123; return sqlSession.selectOne("studentNamespace.findById", id); /* sqlSession.commit();*/ &#125;catch(Exception e)&#123; e.printStackTrace(); sqlSession.rollback(); throw e; &#125;finally&#123; MybatisUtil.closeSqlSession(); &#125; &#125; public static void main(String[] args) throws Exception &#123; StudentDao studentDao = new StudentDao(); Student student = studentDao.findById(1); System.out.println(student.getId() + "----" + student.getName() + "----" + student.getCard().getNum()); &#125;12345678910111213141516171819202122232425 这里写图片描述 2.1一对多 2.1.1设计数据库表123456789101112131415161718192021create table grades( gid int(5) primary key, gname varchar(10));create table students( sid int(5) primary key, sname varchar(10), sgid int(5), constraint sgid_fk foreign key(sgid) references grades(gid));insert into grades(gid,gname) values(1,'java');insert into students(sid,sname,sgid) values(1,'哈哈',1);insert into students(sid,sname,sgid) values(2,'呵呵',1);select * from grades;select * from students;1234567891011121314151617181920 2.1.2创建实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package zhongfucheng2;import java.util.ArrayList;import java.util.List;/** * 学科(单方) * @author AdminTC */public class Grade &#123; private Integer id; private String name; private List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();//关联属性 public Grade()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Student&gt; getStudentList() &#123; return studentList; &#125; public void setStudentList(List&lt;Student&gt; studentList) &#123; this.studentList = studentList; &#125;&#125;package zhongfucheng2;/** * 学生(多方) * @author AdminTC */public class Student &#123; private Integer id; private String name; private Grade grade;//关联属性 public Student()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Grade getGrade() &#123; return grade; &#125; public void setGrade(Grade grade) &#123; this.grade = grade; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 2.1.3映射文件SQL语句12345678910111213141516171819202122232425262728293031323334&lt;mapper namespace="studentNamespace"&gt; &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;/resultMap&gt; &lt;!--查询选修的java学科有多少位学生--&gt; &lt;!--由于我们只要查询学生的名字，而我们的实体studentMap可以封装学生的名字，那么我们返回studentMap即可，并不需要再关联到学科表--&gt; &lt;select id="findByGrade" parameterType="string" resultMap="studentMap"&gt; select s.sname,s.sid from zhongfucheng.students s,zhongfucheng.grades g WHERE s.sgid=g.gid and g.gname=#&#123;name&#125;; &lt;/select&gt;&lt;/mapper&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="gradeNamespace"&gt; &lt;resultMap type="zhongfucheng2.Grade" id="gradeMap"&gt; &lt;id property="id" column="gid"/&gt; &lt;result property="name" column="gname"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt;123456789101112131415161718192021222324252627282930313233 2.1.4DAO12345678910111213141516171819202122232425public List&lt;Student&gt; findByGrade(String grade) throws Exception &#123; //得到连接对象 SqlSession sqlSession = MybatisUtil.getSqlSession(); try&#123; return sqlSession.selectList("studentNamespace.findByGrade", grade); /* sqlSession.commit();*/ &#125;catch(Exception e)&#123; e.printStackTrace(); sqlSession.rollback(); throw e; &#125;finally&#123; MybatisUtil.closeSqlSession(); &#125; &#125; public static void main(String[] args) throws Exception &#123; StudentDao studentDao = new StudentDao(); List&lt;Student&gt; student = studentDao.findByGrade("java"); for (Student student1 : student) &#123; System.out.println(student1.getName()); &#125; &#125;123456789101112131415161718192021222324 1.3多对多 1.3.1数据库表12345678910111213141516171819202122232425262728293031create table students( sid int(5) primary key, sname varchar(10));create table courses( cid int(5) primary key, cname varchar(10));create table middles( msid int(5), mcid int(5), primary key(msid,mcid));insert into students(sid,sname) values(1,'哈哈');insert into students(sid,sname) values(2,'呵呵');insert into courses(cid,cname) values(1,'java');insert into courses(cid,cname) values(2,'android');insert into middles(msid,mcid) values(1,1);insert into middles(msid,mcid) values(1,2);insert into middles(msid,mcid) values(2,1);insert into middles(msid,mcid) values(2,2);select * from students;select * from courses;select * from middles;123456789101112131415161718192021222324252627282930 1.3.2 创建实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.itcast.javaee.mybatis.many2many;import java.util.ArrayList;import java.util.List;/** * 课程(多方) * @author AdminTC */public class Course &#123; private Integer id; private String name; private List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();//关联属性 public Course()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Student&gt; getStudentList() &#123; return studentList; &#125; public void setStudentList(List&lt;Student&gt; studentList) &#123; this.studentList = studentList; &#125;&#125;package cn.itcast.javaee.mybatis.many2many;import java.util.ArrayList;import java.util.List;/** * 学生(多方) * @author AdminTC */public class Student &#123; private Integer id; private String name; private List&lt;Course&gt; courseList = new ArrayList&lt;Course&gt;();//关联属性 public Student()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Course&gt; getCourseList() &#123; return courseList; &#125; public void setCourseList(List&lt;Course&gt; courseList) &#123; this.courseList = courseList; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 1.3.3映射文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="courseNamespace"&gt; &lt;resultMap type="cn.itcast.javaee.mybatis.many2many.Course" id="courseMap"&gt; &lt;id property="id" column="cid"/&gt; &lt;result property="name" column="cname"/&gt; &lt;/resultMap&gt; &lt;!-- 查询哈哈选学了哪些课程 --&gt; &lt;select id="findAllByName" parameterType="string" resultMap="courseMap"&gt; select c.cid,c.cname from students s inner join middles m on s.sid = m.msid inner join courses c on m.mcid = c.cid and s.sname = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="studentNamespace"&gt; &lt;resultMap type="cn.itcast.javaee.mybatis.many2many.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;/resultMap&gt; &lt;select id="findAllByCourseName" parameterType="string" resultMap="studentMap"&gt; select s.sname from students s inner join middles m on s.sid = m.msid inner join courses c on m.mcid = c.cid and c.cname = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 1.3.4创建DAO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast.javaee.mybatis.many2many;import java.util.List;import org.apache.ibatis.session.SqlSession;import cn.itcast.javaee.mybatis.util.MybatisUtil;/** * 持久层 * @author AdminTC */public class StudentCourseDao &#123; /** * 查询哈哈选学了哪些课程 * @param name 表示学生的姓名 */ public List&lt;Course&gt; findAllByName(String name) throws Exception&#123; SqlSession sqlSession = null; try&#123; sqlSession = MybatisUtil.getSqlSession(); return sqlSession.selectList("courseNamespace.findAllByName",name); &#125;catch(Exception e)&#123; e.printStackTrace(); throw e; &#125;finally&#123; MybatisUtil.closeSqlSession(); &#125; &#125; /** * 查询java课程有哪些学生选修 * @param name 表示学生的课程 */ public List&lt;Student&gt; findAllByCourseName(String name) throws Exception&#123; SqlSession sqlSession = null; try&#123; sqlSession = MybatisUtil.getSqlSession(); return sqlSession.selectList("studentNamespace.findAllByCourseName",name); &#125;catch(Exception e)&#123; e.printStackTrace(); throw e; &#125;finally&#123; MybatisUtil.closeSqlSession(); &#125; &#125; public static void main(String[] args) throws Exception&#123; StudentCourseDao dao = new StudentCourseDao(); List&lt;Course&gt; courseList = dao.findAllByName("哈哈"); System.out.print("哈哈选学了" + courseList.size()+"个课程,分别是："); for(Course c : courseList)&#123; System.out.print(c.getName()+" "); &#125; System.out.println("\n-----------------------------------------------------"); List&lt;Student&gt; studentList = dao.findAllByCourseName("android"); System.out.println("选修了android课程的学生有"+studentList.size()+"个，分别是："); for(Student s : studentList)&#123; System.out.print(s.getName()+" "); &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 九、MyBatis的动态sql语句1.什么是动态sql：通过mybatis提供的各种标签方法实现动态拼接sql。 1、if标签需求：根据客户名和级别查询客户 12345&lt;!--根据客户名和级别查询客户--&gt;&lt;select id="queryCustomerWhere" parameterType="customer" resultType="customer"&gt; select * from cst_customer where cust_name=#&#123;cust_name&#125; and cust_level=#&#123;cust_level&#125;&lt;/select&gt; 1234 存在问题 有可能传入的名称或级别为空 可以使用if标签来进行判断 注意：test:放的是Boolean表达式 12345678910&lt;select id="queryCustomerWhere" parameterType="customer" resultType="customer"&gt; select * from cst_customer where &lt;if test="cust_name !=null and cust_name=''"&gt; cust_name=#&#123;cust_name&#125; &lt;/if&gt; &lt;if test="cust_level !=null and cust_name=''"&gt; And cust_level=#&#123;cust_name&#125; &lt;/if&gt;&lt;/select&gt; 123456789 如果前一个条件这后,后面就会多一个and执行就会报错 2、Where标签where标签可以自动添加where，同时可以处理sql语句中第一个and关键字 123456789101112&lt;select id="queryCustomerWhere" parameterType="customer" resultType="customer"&gt; select * from cst_custome &lt;where&gt; &lt;if test="cust_name !=null and cust_name=''"&gt; cust_name=#&#123;cust_name&#125; &lt;/if&gt; &lt;if test="cust_level !=null and cust_name=''"&gt; And cust_level=#&#123;cust_name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 1234567891011 去掉第一个前And 3、trim标签 prefix：设置前缀，在第一个条件之前加上一个前缀 prefixOerrides：条件前缀覆盖，把第一个条件之前的and变成空 suffix：设置后缀，在最后一个条件之后加上一个后缀 suffixOverrides：条件后缀覆盖，把最后一个条件之后的and变成空 123456789101112 &lt;select id="getCustomer" resultType="domain.Customer"&gt; select * from `customer` &lt;trim prefix="where" prefixOverrides="and" suffixOverrides="" suffix="and"&gt; &lt;if test="name!=null and name!=''"&gt; and cust_name=#&#123;name&#125; &lt;/if&gt; &lt;if test="profession!=null and profession!=''"&gt; and cust_profession=#&#123;profession&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt;1234567891011 DAO层现在我想根据学生的编号查询学生的信息和身份证信息！ 由于该查询着重是查询学生的信息，于是我们在学生的映射文件中写SQL语句 按照需求，我们写出来的SQL语句是这样子的 4、choose标签choose用法基本和if一致 sqlsqlsql 注意：整个choose最终只会匹配一种情况 whenchoose标签：（只查满足条件的第一个，后面的条件都不执行） select * from customer 123456789101112&lt;where&gt; &lt;choose&gt; &lt;when test="profession!=null and profession!=''"&gt; cust_profession=#&#123;profession&#125; &lt;/when&gt; &lt;when test="name!=null and name!=''"&gt; cust_name=#&#123;name&#125; &lt;/when&gt; &lt;otherwise&gt;1=1&lt;/otherwise&gt; //当都没有满足条件的时候，执行该默认语句 &lt;/choose&gt;&lt;/where&gt;1234567891011 5、set标签6、foreach向sql传递数据或List,mybatis使用foreach解析，如下根据多个id查询用户信息查询sql：select * from user where id in(1,10,24)在pojo中定义list属性ids存储多个用户id，并添加getter/settter方法 123456@Getter@Setter@ToStringpublic class QueryVo&#123;//包含其他的pojoprivate User user;private list&lt;Integer&gt; ids;12345 Mapper.xml文件 123456789101112131415&lt;!--根据ids查询用户--&gt;&lt;select id="queryUserByIds" parameterType="queryVo" resultType="user"&gt; select * from user &lt;where&gt; &lt;!--foreach标签，进行遍历--&gt; &lt;!--collection：遍历的集合，这里是queryVo的ids的属性值-&gt; &lt;!--遍历的项目，可以随便写，但是和后面的#&#123;&#125;里面要保持一致--&gt; &lt;!--open：在前面添加sql片段--&gt; &lt;!--separator：指定遍历元素之间的分隔符--&gt; &lt;foreach collection="ids" item="item" open="id IN("close =")" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;1234567891011121314 7、bind用于绑定一个字符，并且取名 8、Sql片段使用include标签加载sql片段，refid是sql片段的id如果要使用别的Mapper.xml配置的sql片段，可以在refid前面加上对应的Mapper.xml的nameSpace如： 1234567891011121314151617&lt;include refid="com.lqg.mybatis.mapper.OrderMapper.userFirlds"/&gt;1&lt;select id="queryCustomerWhere" parameterType="customer" resultType="customer"&gt; select &lt;include refid="userFirlds"/&gt; from cst_custome &lt;where&gt; &lt;if test="cust_name !=null and cust_name=''"&gt; cust_name=#&#123;cust_name&#125; &lt;/if&gt; &lt;if test="cust_level !=null and cust_name=''"&gt; And cust_level=#&#123;cust_name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &lt;!--声明sql片段--&gt;&lt;sql id="userFieleds"&gt; cust_id,cust_name,cust_level &lt;/sql&gt;]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、MyBatis入门示例]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%BA%8C%E3%80%81MyBatis%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[二、MyBatis入门示例 在本篇博客中，我们来一起完成MyBatis的入门示例 准备数据库和表12345678910111213141516DROP TABLE student;CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100), gender VARCHAR(10), birthday DATE );INSERT INTO student (name,gender,birthday) VALUES ('波多结衣','female','1995-12-11');INSERT INTO student (name,gender,birthday) VALUES ('波少结衣','female','1996-11-12');INSERT INTO student (name,gender,birthday) VALUES ('杉原杏璃','female','1997-10-13');INSERT INTO student (name,gender,birthday) VALUES ('佐佐木希','female','1998-09-14');INSERT INTO student (name,gender,birthday) VALUES ('伊藤梅子','female','1999-08-15');12345678910111213141516 我们建立数据库mb，并创建一张表student并为其插入数据。 创建JavaBean1234567891011121314151617181920212223242526272829303132333435363738394041package cn.com.helloworld;import java.util.Date;public class Student &#123; private int id; private String name; private String gender; private Date birthday; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", gender=" + gender + ", birthday=" + birthday + "]"; &#125;&#125; 请注意：将JavaBean中的字段与数据库中表中的字段保持一致 导入MyBatis相关jar包请下载MyBatis开发所需jar包并存放至工程的lib目录。 SqlMapConfig.xml在有了数据库和JavaBean之后我们来编写MyBatis的全局配置文件SqlMapConfig.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mb?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt;12345678910111213141516 在该配置文件中配置由MyBatis所采用的事务和数据库连接池 StudentMapper.xml刚才我们编写了MyBatis的全局配置文件SqlMapConfig.xml，现在我们来编写与JavaBean相关的配置文件StudentMapper.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;student&quot;&gt;&lt;/mapper&gt;123456 我们在该配置文件中添加标签并设置其namespace为student。 再将StudentMapper.xml配置到SqlMapConfig.xml，代码如下： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mb?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/StudentMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt;123456789101112131415161718 请参见代码第15—17行 CRUD操作在完成了之上的准备工作后，我们来利用MyBatis实现简单的增删改查。 我们先来做一个最简单的例子：依据Stundet的id查询学生信息 首先在映射文件StudentMapper.xml中写sql语句： 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="student"&gt; &lt;select id="findStudentById" parameterType="int" resultType="cn.com.helloworld.Student"&gt; SELECT * FROM student WHERE id=#&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt;12345678910 在该xml文件中为我们的需求写了一个sql语句，请注意 id标识该sql语句的唯一性，因为之后随着功能的扩展在该xml文件中会有许多sql语句。其实，类似于StudentMapper.xml这样的mapper.xml文件中每一个sql语句都对应一个MappedStatement对象，sql语句的id即是MappedStatement的id。 parameterType表示输入参数类型。此处我们要依据id查询学生，那么输入参数就是一个int类型的数字 resultType表示查询结果的返回类型。在此，我们想得到一个Student对象，所以将resultType设置为cn.com.helloworld.Student #{ }表示占位符，用于接收输入参数。输入参数的类型可以是简单类型，pojo、HashMap。如果输入参数是简单类型那么#{}的括号中可以写成value或其它名称。 在完成了映射文件的编码之后，我们再来书写Java代码 1234567891011121314151617181920212223242526/** * 本文作者：谷哥的小弟 * 博客地址：http://blog.csdn.net/lfdfhl */package cn.com.helloworld;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;public class CRUDTest &#123; @Test public void findStudentById() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); Student student = sqlSession.selectOne("student.findStudentById", 1); System.out.println(student); sqlSession.close(); &#125;&#125; 代码详解如下： 获取MyBatis的全局配置文件SqlMapConfig.xml，请参见代码第18—19行 利用全局配置文件创建SqlSessionFactory，请参见代码第20行 利用SqlSessionFactory创建SqlSession，请参见代码第21行 利用SqlSession调用其selectOne()方法查询一条学生信息，请参见代码第22行。请注意该方法参数：第一个参数用于标识一条sql语句，其构成为：映射文件的namespace+”.”+MappedStatement的id(即sql语句的id)；第二参数是需要传递给sql语句的输入参数。 关闭SqlSession，释放资源；请参见代码第24行 输出结果如下： Student [id=1, name=波多结衣, gender=female, birthday=Mon Dec 11 00:00:00 CST 1995] 至此，我们走完了一个利用MyBatis查询数据的完整流程。 刚才这个例子是查询出来了单条记录，如果要查询多条记录又该怎么做呢？比如查询出学生名字中带有”结”这个字的所有学生，请看如下代码： 123&lt;select id="findStudentByName" parameterType="java.lang.String" resultType="cn.com.helloworld.Student"&gt; SELECT * FROM student WHERE name LIKE '%$&#123;value&#125;%'&lt;/select&gt; 在该映射文件中采用${ }表示拼接，它所接收的输入参数类型可以是简单类型，pojo，HashMap。如果接收简单类型，${}中只能写成value。当${}接收pojo对象值时可通过OGNL读取对象中的属性值；即利用属性.属性.属性…的方式获取对象属性值 在完成映射文件的编写之后，我们再来看Java代码： 123456789101112@Test public void findStudentByName() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;Student&gt; list = sqlSession.selectList("student.findStudentByName", "结"); for(Student student:list)&#123; System.out.println(student); &#125; sqlSession.close(); &#125; 在此利用了qlSession.selectList( )方法返回一个查询后的集合。 输出结果如下： Student [id=1, name=波多结衣, gender=female, birthday=Mon Dec 11 00:00:00 CST 1995]Student [id=2, name=波少结衣, gender=female, birthday=Tue Nov 12 00:00:00 CST 1996] 在完成查询操作后，我们向数据库插入一条新数据，并得到新数据被插入到数据库后它的主键值。 123456&lt;insert id="insertStudent" parameterType="cn.com.helloworld.Student"&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO student (name,gender,birthday) value (#&#123;name&#125;,#&#123;gender&#125;,#&#123;birthday&#125;) &lt;/insert&gt;123456 我们在标签中使用了标签获取插入数据的主键并将其设置到Student对象中. SELECT LAST_INSERT_ID()：得到insert记录的主键值，只适用与自增主键 keyProperty：用于指明将查询到的主键值设置到parameterType指定的对象的哪个属性 order：表示SELECT LAST_INSERT_ID()相对于insert语句的执行顺序。在该例子中用AFTER表示执行完该insert语句后再执行SELECT LAST_INSERT_ID() resultType：指定SELECT LAST_INSERT_ID()的结果的类型 123456789101112131415@Test public void insertStudent() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); Student student=new Student(); student.setName("右右木希"); student.setGender("female"); student.setBirthday(new Date()); sqlSession.insert("student.insertStudent",student); sqlSession.commit(); sqlSession.close(); System.out.println(""+student.getId()); &#125; 代码解析如下： 利用sqlSession.insert()将数据插入数据库，请参见代码第11行 利用sqlSession.commit()提交事务，请参见代码第12行 获取到新插入数据的主键值，请参见代码第14行 继续来看删除数据的操作 123&lt;delete id="deleteStudent" parameterType="java.lang.Integer"&gt; DELETE FROM student where id=#&#123;id&#125;&lt;/delete&gt;123 Java代码如下: 12345678910@Test public void deleteStudent() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.delete("student.deleteStudent", 1); sqlSession.commit(); sqlSession.close(); &#125;12345678910 最后来瞅瞅更新操作 123&lt;update id="updateStudent" parameterType="cn.com.helloworld.Student"&gt; UPDATE student set name=#&#123;name&#125;,gender=#&#123;gender&#125;,birthday=#&#123;birthday&#125; where id=#&#123;id&#125; &lt;/update&gt;123 Java代码如下: 123456789101112131415@Test public void updateStudent() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); Student student=new Student(); student.setId(3); student.setName("中中木希"); student.setGender("female"); student.setBirthday(new Date()); sqlSession.update("student.updateStudent", student); sqlSession.commit(); sqlSession.close(); &#125;123456789101112131415 嗯哼，至此我们关于MyBatis的入门示例就已经全部完成了。 项目结构图如下所示：]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、MyBatis概述]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%B8%80%E3%80%81MyBatis%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[MyBatis简介 MyBatis原本是apache的一个开源项目iBatis, 2010年该项目由apache software foundation 迁移到了google code并改名为MyBatis 。2013年11月MyBatis又迁移到Github。 The MyBatis SQL mapper framework makes it easier to use a relational database with object-oriented applications. MyBatis couples objects with stored procedures or SQL statements using a XML descriptor or annotations. Simplicity is the biggest advantage of the MyBatis data mapper over object relational mapping tools. MyBatis是一个优秀的持久层框架，它对JDBC操作数据库的过程进行了封装，使开发者只需要关注SQL本身，而不需要开发人员花费大量的精力去处理例如注册驱动、创建connection、创建statement、手动设置参数等JDBC操作。 Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由MyBatis框架执行sql并将结果映射成java对象并返回。 更多介绍，敬请参见MyBatis官方网站：http://www.mybatis.org/mybatis-3/ MyBatis框架1、SqlMapConfig.xml是MyBatis的全局配置文件，它配置了MyBatis的运行环境等信息。 2、mapper.xml是sql映射文件，它配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载 3、通过MyBatis配置信息构造SqlSessionFactory(会话工厂) 4、由会话SqlSessionFactory(工厂)创建SqlSession(会话)操作数据库 5、MyBatis底层自定义Executor(执行器)接口用于执行数据库操作，该接口有两个实现：基本执行器和缓存执行器。 6、MappedStatement是MyBatis的底层封装对象，它封装了操作数据库的sql语句，输入参数，输出结果等信息。mapper.xml文件中每一个sql语句对应一个MappedStatement对象，sql语句的id即是MappedStatement的id。 7、MappedStatement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过MappedStatement在执行sql前将输入的java对象映射至sql中 8、MappedStatement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过MappedStatement在执行sql后将输出结果映射至java对象中 MyBatis开发环境在利用MyBatis开发前，请移步MyBatis官网下载开发所有的jar包、开发指南，说明文档等资料。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、Spring Boot日志配置详解]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%BA%94%E3%80%81Spring-Boot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、Spring Boot多环境配置详解]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%9B%9B%E3%80%81Spring-Boot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot多环境配置详解一. 多环境配置的好处： 1.不同环境配置可以配置不同的参数 2.便于部署，提高效率，减少出错 二. Properties多环境配置 配置激活选项 spring.profiles.active=dev 2.添加其他配置文件 三．YAML多环境配置 ​ 1.配置激活选项 ​ spring: profiles:active: dev ​ 2.在配置文件添加三个英文状态下的短横线即可区分 ​ — spring: profiles: dev四．两种配置方式的比较 ​ 1. Properties配置多环境，需要添加多个配置文件，YAML只需要一个配件文件 ​ 2.书写格式的差异，yaml相对比较简洁，优雅 \3. YAML的缺点：不能通过@PropertySource注解加载。如果需要使用@PropertySource注解的方式加载值，那就要使用properties文件。 五．如何使用 ​ java -jar myapp.jar –spring.profiles.active=dev]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《WEB开发-HEXO博客搭建》第一章Hexo的简介与安装]]></title>
    <url>%2F2019%2F08%2F25%2F%E3%80%8AWEB%E5%BC%80%E5%8F%91-HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0Hexo%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[《WEB开发-HEXO博客搭建》第1章 Hexo博客搭建Hexo官方：https://hexo.io/Hexo官方(中文)：https://hexo.io/zh-cn/Node.js官方网站：https://nodejs.org/en/Node.js官方文档：https://nodejs.org/en/docs/Node.js安装文档：https://nodejs.org/en/download/package-manager/ 1.1 Hexo简介Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统。 1.2 node.js安装Hexo是基于node.js的，所以我们在安装它之前需要用到npm安装工具，这个工具是 node.js 安装包的工具，所以，我们先要安装 node.js。笔者是用的Windows 64位的，到node.js下载安装包。 图1 下载后直接安装就可以啦，和普通的软件没有什么大的区别，所有笔者就不赘述了。 1.3 GitHub账户创建及客户端安装关于git账户创建及客户端下载安装等可参看笔者的博客，笔者在这里就不在赘述了。GitHub官网：https://github.com/Git和Github的使用：https://blog.csdn.net/u013162035/article/details/78476880Git下载：https://git-scm.com/downloadsGit安装：https://blog.csdn.net/u013162035/article/details/78464161 在github网页上创建一个以username.github.io命名的repositories,此时username为自己github的账号名称。 1.4安装hexo使用npm安装Hexo，输入以下命令： 1$ npm install hexo-cli -g 1.5创建Blog笔者在D盘下新建一个blog的文件夹，然后进入blog文件夹，单击右键打开git bash。1. 创建一个叫blog网站$ hexo init 如果没有进入blog文件夹， 就会在当前目录进行初始化。这是初始化命令就要加blog。$ hexo init blog 如果后面跟了名子就会创建目录并在目录进行初始化操作, 以这个名子为目录名。2. 我们进入创建的blog目录里. 并运行该服务$ npm install $ hexo server 【注】hexo命令$ hexo install 3. 测试网页打开浏览器, 在地址栏输入http://localhost:4000/可以看到我们刚刚创建的blog首页 4.修改blog目录下的_config.yml配置文件将网站自部署到Github上$ vim _config.yml 添加如下内容 123git repo: git@github.com:用户名/用户名.github.io.gitbranch: master 【注】在type前面需要增加两个空格，在type的冒号后面需要增加一个空格。请保持代码风格一致，否则会出现错误或是不正确的问题。5.安装部署使用到的git插件在这里我们使用的是git源码管理工具，所以，我需要安装git包进行部署，安装这个插件才能使用git进行自动部署。 $ npm install hexo-deployer-git -save 在接下来，我们将要生成网站了，首先清理一下缓存。$hexo clean 6.进行生成网站当我们部署网站前，需要先生成静态网站。它会自动在目录下创建public的目录, 并将新生成的网页存放在这个目录里。 $ hexo g或hexo generate 7.进行自动部署网站注意部署前需要重新生成网站, 每一次修改后都需要重新生成网站并进行部署，生成网站前第6步。 $ hexo d或hexo deploy 如果在部署出现错误信息如果下: 请参考第5步，需要安装git插件ERROR Deployer not found: git以上两步可以使用一步就可以搞定： $hexo g -d 【注】上述的部署指令中hexo deploy可以换成hexo server，两者的区别在于，前者是将博客部署到远程的Github上，而后者是运行在本地，通过http://localhost:4000在浏览器中访问。后者是为了调试配置方便而使用，但是最终本地博客还是需要hexo deploy指令将其部署至Github上。接下来就是查看是否成功啦。打开浏览器输入IP地址。 图2 表明创建成功了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《WEB开发-HEXO博客搭建》第二章Hexo的博客配置]]></title>
    <url>%2F2019%2F08%2F25%2F%E3%80%8AWEB%E5%BC%80%E5%8F%91-HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0Hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[《WEB开发-HEXO博客搭建》第2章 Hexo博客配置Hexo官方Hexo官方(中文)Hexo主题Next 主题 图1 2.1 Hexo页面添加及设置默认有些页面是没有的，需要手动添加，进入博客文件夹，打开Git bash。 123$hexo new page &quot;categories&quot;$hexo new page &quot;tags&quot; $hexo new page &quot;about&quot; 编辑 tags/index.md 和categories/index.md和about/index.md分别添加如下内容： 12type: &quot;categories&quot;layout: &quot;categories&quot; 1234type: &quot;tags&quot;layout: &quot;tags&quot;type: &quot;about&quot;layout: &quot;about&quot; 主题的 _config.yml 文件中的 menu 中进行匹配。 123456menu: Home: / //主页 Archives: /archives //分类 categories: /categories //归档 tags: /tags //标签 about: /about //关于 2.2添加评论功能来必力官网： https://livere.com没有账号的注册账号，打开来必力官网： https://livere.com，点击上方的安装，选择免费的city版本。 图2 图3 点击【申请获得代码】，进入下一步操作。复制其中的uid字段。 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;MTAyMC8zNzMzMC8xMzg2NA==&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt;&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 图4 打开主题目录下的 blog/themes/某个主题/_config.yml 配置文件，定位到 livere_uid 字段，粘贴上刚刚复制的UID。 至此，大功告成。效果展示测试评论如图所示： 图5 2.3统计配置笔者使用的是不蒜子统计注意：此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后。 全局设置 编辑主题配置文件中的busuanzi_count的配置项。当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。  站点UV设置当site_uv: true时，代表在页面底部显示站点的UV值。site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_uv_header]UV值[site_uv_footer]。 //效果：本站访客数12345人次site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次  站点PV设置当site_pv: true时，代表在页面底部显示站点的PV值。site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_pv_header]PV值[site_pv_footer]。 //效果：本站总访问量12345次site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次  单页面PV配置当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。page_pv_header和page_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[page_pv_header]PV值[page_pv_footer]。 //效果：本文总阅读量12345次page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次 2.4搜索配置笔者使用的是Local Search，添加百度/谷歌/本地 自定义站点内容搜索。一、安装 hexo-generator-searchdb在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb —save 二、编辑站点配置文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 三、编辑主题配置文件，启用本地搜索功能 123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客之博客美化]]></title>
    <url>%2F2019%2F08%2F24%2FHexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Hexo 博客优化之博客美化（看板娘/鼠标点击爱心字体烟花爆炸/自定义鼠标指针样式/彩色滚动变换字体/背景音乐/网页标题恶搞/动态线条/人体时钟挂件/雪花飘落/背景动态彩带/背景代码雨……）转载自：链接：https://blog.csdn.net/qq_36759224/article/details/85420403 本文将讲述一些Hexo博客的美化，不同主题可能方法有些不同（本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例）实际效果欢迎访问我的博客：https://www.itrhx.com/ 进行查看，本文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 欢迎关注我的专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 推荐阅读：《Hexo 博客优化之实用功能添加（评论系统/字数统计/阅读时长/网站运行时间/百度统计/RSS订阅/Fork me on GitHub/更改本地预览端口号…）》 文章目录 ● 添加卡通人物（看板娘） ● 添加鼠标点击爱心效果 ● 添加鼠标点击显示字体效果 ● 添加鼠标点击烟花爆炸效果 ● 自定义鼠标指针样式 ● 添加彩色滚动变换字体 ● 添加背景音乐 ● 浏览器网页标题恶搞 ● 背景添加动态线条效果 ● 添加人体时钟等有趣的挂件 ● 添加网站雪花飘落效果 ● 添加背景动态彩带效果 ● 添加背景代码雨特效 未完待续…… ● 添加卡通人物（看板娘）我在逛别人博客的时候偶然发现右下角居然有一个萌萌的卡通人物，还能根据你鼠标位置摇头，瞬间被吸引到了，赶紧也给自己博客添加一个吧！点击此处进入该项目地址 输入如下命令获取 live2d ： 12$ npm install --save hexo-helper-live2d 1 输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请点击此处，各个模型的预览请访问原作者的博客 12$ npm install packagename1 打开站点目录下的 _config.yml 文件，添加如下代码： 123456789101112live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示1234567891011 设置好过后我们就拥有了一个卡通人物 ● 添加鼠标点击爱心效果在 /themes/hexo-theme-spfk/source/js 下新建文件 love.js，在 love.js 文件中添加以下代码： 12!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);1 在 \themes\hexo-theme-spfk\layout\layout.ejs 文件末尾添加以下代码： 123&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/love.js"&gt;&lt;/script&gt;12 完成以上操作后，当我们点击鼠标的时候就可以看见爱心的特效了 ● 添加鼠标点击显示字体效果在 /themes/hexo-theme-spfk/source/js 下新建文件 click_show_text.js，在 click_show_text.js 文件中添加以下代码： 12345678910111213141516171819202122232425262728293031323334var a_idx = 0;jQuery(document).ready(function($) &#123; $("body").click(function(e) &#123; var a = new Array ("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"); var $i = $("&lt;span/&gt;").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; "z-index": 5, "top": y - 20, "left": x, "position": "absolute", "font-weight": "bold", "color": "#FF0000" &#125;); $("body").append($i); $i.animate(&#123; "top": y - 180, "opacity": 0 &#125;, 3000, function() &#123; $i.remove(); &#125;); &#125;); setTimeout('delay()', 2000);&#125;);function delay() &#123; $(".buryit").removeAttr("onclick");&#125;123456789101112131415161718192021222324252627282930313233 其中的社会主义核心价值观可以根据你自己的创意替换为其他文字，然后在 \themes\hexo-theme-spfk\layout\layout.ejs 文件末尾添加以下代码： 123&lt;!--单击显示文字--&gt;&lt;script type="text/javascript" src="/js/click_show_text.js"&gt;&lt;/script&gt;12 最终实现效果如下： ● 添加鼠标点击烟花爆炸效果在 \themes\material-x\source\js 目录下新建一个 fireworks.js 的文件，里面写入以下代码： 12"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;;1 然后在 \themes\material-x\layout\layout.ejs 文件中写入以下代码： 1234&lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/fireworks.js"&gt;&lt;/script&gt;123 最终效果： ● 自定义鼠标指针样式在 \themes\material-x\source\less_base.less 文件 body 样式里写入如下代码： 1234567body &#123; cursor: url(https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur),auto; background-color: @theme_background; ...... ......&#125;123456 鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读参考文档或者参考以下兼容表： 浏览器 最低版本 格式 Internet Explorer 6.0 .cur / .ani Firefox (Gecko), Windows and Linux 1.5 (1.8) .cur / .png / .gif / .jpg Firefox (Gecko) 4.0 (2.0) .cur / .png / .gif / .jpg / .svg Opera — — Safari (Webkit) 3.0 (522-523) .cur / .png / .gif / .jpg 拓展阅读：《CSS 鼠标样式 cursor属性》 （By：歪脖先生的博客） ● 添加彩色滚动变换字体在你想要添加彩色滚动变换字体的地方写入以下代码即可，其中文字可自行更改： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id="binft"&gt;&lt;/div&gt; &lt;script&gt; var binft = function (r) &#123; function t() &#123; return b[Math.floor(Math.random() * b.length)] &#125; function e() &#123; return String.fromCharCode(94 * Math.random() + 33) &#125; function n(r) &#123; for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) &#123; var l = document.createElement("span"); l.textContent = e(), l.style.color = t(), n.appendChild(l) &#125; return n &#125; function i() &#123; var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) &#125; var l = "", o = ["青青陵上柏，磊磊涧中石。", "人生天地间，忽如远行客。","斗酒相娱乐，聊厚不为薄。", "驱车策驽马，游戏宛与洛。","洛中何郁郁，冠带自相索。","长衢罗夹巷，王侯多第宅。","两宫遥相望，双阙百余尺。","极宴娱心意，戚戚何所迫？"].map(function (r) &#123; return r + "" &#125;), a = 2, g = 1, s = 5, d = 75, b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"], c = &#123; text: "", prefixP: -s, skillI: 0, skillP: 0, direction: "forward", delay: a, step: g &#125;; i() &#125;; binft(document.getElementById('binft')); &lt;/script&gt;123456789101112131415161718192021222324252627282930313233343536373839404142 最终效果： ● 添加背景音乐打开网页版网易云音乐，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，复制底下的HTML代码 然后将此代码放到你想要放的地方，比如放在博客的左侧，则打开 \themes\hexo-theme-spfk\layout_partial\left-col.ejs 文件，将复制的HTML代码粘贴进去，再进行适当的位置设置让播放器更美观，其中 auto=1 表示打开网页自动播放音乐，auto=0 表示关闭自动播放音乐 最后效果如下：这种网易云音乐外链的方式有很多局限性，因此推荐使用aplayer，GitHub地址为：https://github.com/MoePlayer/APlayer ，参考教程：《hexo上的aplayer应用》 ● 浏览器网页标题恶搞当用户访问你的博客时点击到了其他网页，我们可以恶搞一下网页标题，呼唤用户回来，首先在目录 \Hexo\themes\hexo-theme-spfk\source\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 123456789101112131415161718&lt;!--浏览器搞笑标题--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/trhx2.png"); document.title = 'ヽ(●-`Д´-)ノ你丑你就走！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/img/trhx2.png"); document.title = 'ヾ(Ő∀Ő3)ノ你帅就回来！' + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;);1234567891011121314151617 然后在 \Hexo\themes\hexo-theme-spfk\layout\layout.ejs 文件中添加如下代码： 123&lt;!--浏览器搞笑标题--&gt;&lt;script type="text/javascript" src="\js\FunnyTitle.js"&gt;&lt;/script&gt;12 再次部署博客后就可以看见标题搞笑的效果了： ● 背景添加动态线条效果在 \Hexo\themes\hexo-theme-spfk\layout\layout.ejs 文件中添加如下代码： 12345&lt;!--动态线条背景--&gt;&lt;script type="text/javascript"color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;1234 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 最终实现效果： ● 添加人体时钟等有趣的挂件无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，点击此处访问作者博客，点击此处在作者原博客上查看动态样式，点击此处查看动态大图，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的 实现代码： 123456&lt;!--人体时钟背景透明--&gt;&lt;script charset="Shift_JIS" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js"&gt;&lt;/script&gt;&lt;!--人体时钟背景白--&gt;&lt;script charset="Shift_JIS" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js"&gt;&lt;/script&gt;12345 其他网页小挂件推荐： http://abowman.com/ 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用 http://www.revolvermaps.com/ 它提供网站访客地理信息，可以以2D、3D等形式显示 http://www.amazingcounters.com/ 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数 https://www.seniverse.com/widget/get 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览 ● 添加网站雪花飘落效果样式一和样式二分别如下： 实现方法：在 \Hexo\themes\hexo-theme-spfk\source\js 目录下新建一个 snow.js 文件，粘贴以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/*样式一*/(function($)&#123; $.fn.snow = function(options)&#123; var $flake = $('&lt;div id="snowbox" /&gt;').css(&#123;'position': 'absolute','z-index':'9999', 'top': '-50px'&#125;).html('&amp;#10052;'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = &#123; minSize : 10, maxSize : 20, newOn : 1000, flakeColor : "#AFDAEF" /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ &#125;, options = $.extend(&#123;&#125;, defaults, options); var interval= setInterval( function()&#123; var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css(&#123; left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor &#125;).animate(&#123; top: endPositionTop, left: endPositionLeft, opacity: 0.2 &#125;,durationFall,'linear',function()&#123; $(this).remove() &#125;); &#125;, options.newOn); &#125;;&#125;)(jQuery);$(function()&#123; $.fn.snow(&#123; minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ &#125;);&#125;);123456789101112131415161718192021222324252627282930313233343536373839404142/*样式二*//* 控制下雪 */function snowFall(snow) &#123; /* 可配置属性 */ snow = snow || &#123;&#125;; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function()&#123; /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123; /* 添加Dom结点 */ var snowcanvas = document.createElement("canvas"); snowcanvas.id = "snowfall"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute("style", "position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;"); document.getElementsByTagName("body")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext("2d"); /* 窗口大小改变的处理 */ window.onresize = function() &#123; snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123; this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function() &#123; var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) &#123; this.velY = this.speed &#125; this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123; this.reset(canvas.width, canvas.height) &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) &#123; this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) &#123; var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, "rgba(255, 255, 255, 0.9)"); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, "rgba(255, 255, 255, 0.5)"); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, "rgba(255, 255, 255, 0)"); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123; var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) &#123; flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) &#125;&#125;/* 画雪 */function drawSnow() &#123; var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) &#123; flakes[e].update(); flakes[e].render(ctx); &#125; /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() &#123; drawSnow.apply(that); &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;maxFlake:60&#125;);snow.start();123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 然后在 \Hexo\themes\hexo-theme-spfk\layout\layout.ejs 文件里引用即可： 123&lt;!-- 雪花特效 --&gt;&lt;script type="text/javascript" src="\js\snow.js"&gt;&lt;/script&gt;12 如果没效果，请确认网页是否已载入JQurey，如果没有请在下雪代码之前引入JQ即可： 123&lt;script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.min.js"&gt;&lt;/script&gt;12 原文链接：《分享两种圣诞节雪花特效JS代码(网站下雪效果)》 ● 添加背景动态彩带效果样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带： 实现方法：在 \themes\material-x\layout\layout.ejs 文件的body前面添加如下代码： 123456&lt;!-- 样式一（鼠标点击更换样式） --&gt;&lt;script src=&quot;https://g.joyinshare.com/hc/ribbon.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;12&lt;!-- 样式二（飘动的彩带） --&gt;&lt;script src=&quot;https://g.joyinshare.com/hc/piao.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;12 ● 添加背景代码雨特效新建 DigitalRain.js，写入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758window.onload = function()&#123; //获取画布对象 var canvas = document.getElementById("canvas"); //获取画布的上下文 var context =canvas.getContext("2d"); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++)&#123; drops.push(0); &#125; //运动的文字 var str ="WELCOME TO WWW.ITRHX.COM"; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw()&#123; context.fillStyle = "rgba(238,238,238,.08)";//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = "600 "+fontSize+"px Georgia"; //给字体添加颜色 context.fillStyle = ["#33B5E5", "#0099CC", "#AA66CC", "#9933CC", "#99CC00", "#669900", "#FFBB33", "#FF8800", "#FF4444", "#CC0000"][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++)&#123; var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99)&#123; drops[i] = 0; &#125; drops[i]++; &#125; &#125;; function randColor()&#123;//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return "rgb("+r+","+g+","+b+")"; &#125; draw(); setInterval(draw,35);&#125;;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\themes\material-x-1.2.1\source\less_main.less 文件末尾）添加以下代码： 1234567891011canvas &#123; position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;&#125;12345678910 然后在主题的 layout.ejs 文件中引入即可： 1234 &lt;!-- 数字雨 --&gt; &lt;canvas id="canvas" width="1440" height="900" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="/js/DigitalRain.js"&gt;&lt;/script&gt;123 最终效果：代码来源：http://www.lxl8800.cn/Main/Resource 未完待续…]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客的背景设置]]></title>
    <url>%2F2019%2F08%2F24%2Fhexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo博客的背景设置主要有以下30种： 在右上角或者左上角实现fork me on github 添加RSS 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改“代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加网易云跟帖(跟帖关闭，已失效，改为来必力) 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 1. 在右上角或者左上角实现fork me on github实现效果图 具体实现方法 点击这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码： 然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 2.添加RSS实现效果图 具体实现方法 切换到你的blog（我是取名blog，具体的看你们的取名是什么）的路径，例如我是在/Users/chenzekun/Code/Hexo/blog这个路径上，也就是在你的根目录下 然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里) 1$ npm install --save hexo-generator-feed 1 1 接下来打开画红线的文件，如下图： 在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) 123456789# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 12345678910111213# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 配置完之后运行： 1$ hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 3. 添加动态背景实现效果图 具体实现方法 这个我之前有一篇文章有讲过了，详情点击我的博客 4. 实现点击出现桃心效果实现效果图 具体实现方法 在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12345&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 5. 修改文章内链接文本样式实现效果图 具体实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011121314151617181920212223242526272829303132333435363738394041// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 6. 修改文章底部的那个带#号的标签实现效果图 具体实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 7. 在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 1234567891011121314151617&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 1234567891011121314151617&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123456789# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 8. 修改作者头像并旋转实现效果图 具体实现方法 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125; img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; /* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 9. 博文压缩在站点的根目录下执行以下命令： 12345$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在如下图所示，新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 10. 修改“代码块自定义样式实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 11. 侧边栏社交小图标设置实现效果图 具体实现方法 打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 12. 主页文章添加阴影效果实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 1234567891011121314151617181920212223242526272829// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 13. 在网站底部加上访问量实现效果图 具体实现方法 打开\themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话： 代码如下： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图： 代码如下： 1234567891011121314151617&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： \1. pv的方式，单个用户连续点击n篇文章，记录n次访问量 123456789&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123456789&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 14. 添加热度实现效果图 具体实现方法 next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了 15. 网站底部字数统计实现效果图 具体方法实现 切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 1 1 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 12345678910111213&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 16. 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为 1skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 17. 设置网站的图标Favicon实现效果图 具体方法实现 在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12345# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 18. 实现统计功能实现效果图 具体实现方法 在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456789101112131415161718192021# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 19. 添加顶部加载条实现效果图 具体实现方法 打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码 代码如下： 12345&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 1 2 1 2 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 目前，博主的增加顶部加载条的pull request 已被Merge��===&gt;详情 现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图： 20. 在文章底部增加版权信息实现效果图 在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); clipboard.on(&apos;success&apos;, $(function()&#123; $(&quot;.fa-clipboard&quot;).click(function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 1234567891011121314151617&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 1234567891011121314151617&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot; 保存重新生成即可。 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： 这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去 (注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 21. 添加网易云跟帖(跟帖关闭，已失效，改为来必力)实现效果图 具体方法实现 有两种实现方法： ①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置: 1gentie_productKey: #your-gentie-product-key ②如果你不想更新的话，那么按下面步骤进行： 首先，还是在主题配置文件_config.yml 文件中添加如下配置: 1gentie_productKey: #your-gentie-product-key 你的productKey就是下面画红线部分 然后在在layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: &quot;&quot;, productKey: &quot;&#123;&#123;gentie_productKey&#125;&#125;&quot;, target: &quot;cloud-tie-wrapper&quot; &#125;; &lt;/script&gt; &lt;script src=&quot;https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include &apos;./comments/gentie.swig&apos; %&#125; 1 1 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 123456789&#123;% elseif theme.gentie_productKey %&#125; &lt;div id=&quot;cloud-tie-wrapper&quot; class=&quot;cloud-tie-wrapper&quot;&gt; &lt;/div&gt; 具体位置如下： 可能你hexo s时可能看不到，直接hexo d就可以看到了 近日，我朋友发来消息，说网易云跟帖要关了，我网上查了一下，果然如此 ��都是泪,上次用了多说，结果多说关了，接着是网易云跟帖��，这次直接用国外的来必力，应该不会这么容易关吧�� 方法其实还是跟上面差不多的 首先在 _config.yml 文件中添加如下配置： 123456789# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid 其中，livere_uid就是画红线的部分 然后在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在 layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include &apos;./comments/livere.swig&apos; %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加 LiveRe 插件是否引用的判断逻辑： 123456789&#123;% elseif theme.livere_uid %&#125; &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&#123;&#123; theme.livere_uid &#125;&#125;&quot;&gt;&lt;/div&gt;&#123;% endif %&#125; 完 22. 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： 23. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 24. 文章加密访问实现效果图 具体实现方法 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 25. 添加jiathis分享在主题配置文件中，jiathis为true，就行了，如下图 默认是这样子的： 如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了 26. 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如 1234567891011121314151617181920212223242526272829---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 27. 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示： 1$font-size-base =16px 28. 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 29. 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接): 1234567891011121314151617181920212223242526272829303132333435363738394041# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 30. 自定义鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码 12345678910111213141516171819202122232425// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 其中 url 里面必须是 ico 图片，ico 图片可以上传到网上（我是使用七牛云图床），然后获取外链，复制到 url 里就行了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo博客的背景设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis入门，读这一篇就够了]]></title>
    <url>%2F2019%2F08%2F23%2FRedis%E5%85%A5%E9%97%A8%EF%BC%8C%E8%AF%BB%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[目录 一. redis 1.1.什么是NOSQL 1.1.1. NOSQL和关系型数据库比较 1.1.2. 非关系型数据库的优势： 1.1.3. 关系型数据库的优势： 1.1.4. 总结 1.2.主流的NOSQL产品 1.3 什么是Redis 1.3.1 redis的应用场景(重要) 二. 下载安装 三. 命令操作 1. redis的数据结构： 2. 字符串类型 string 3. 哈希类型 hash 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 5. 集合类型 set ： 不允许重复元素 6. 有序集合类型 sortedset： 7. 通用命令 四. 持久化 五. Java客户端 Jedis 六. 案例： 一. redis**概念**： redis是一款高性能的NOSQL系列的非关系型数据库1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较**优点：** 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关 系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql 数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 ​ 缺点： 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 1） 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候 使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在 nosql 数据库中备份存储关系型数据库的数据1.2.主流的NOSQL产品• 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset1.3.1 redis的应用场景(重要)• 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离二. 下载安装1. [官网](https://redis.io) 2. [Redis中文网](http://www.redis.net.cn/) 3. 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端三. 命令操作1. redis的数据结构： redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构： 字符串类型 string 哈希类型 hash ： map格式 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 13. 哈希类型 hash**1. 存储**： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 **2. 获取**： hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; **3. 删除**： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 14. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素**1. 存储**：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 **2. 获取**：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; **3. 删除**：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 16. 有序集合类型 sortedset：​ 不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 ​ 1. 存储：zadd key score value​ 127.0.0.1:6379&gt; zadd mysort 60 zhangsan​ (integer) 1​ 127.0.0.1:6379&gt; zadd mysort 50 lisi​ (integer) 1​ 127.0.0.1:6379&gt; zadd mysort 80 wangwu​ (integer) 1​ 2. 获取：zrange key start end [withscores]​ 127.0.0.1:6379&gt; zrange mysort 0 -1​ 1) “lisi”​ 2) “zhangsan”​ 3) “wangwu” ​ 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores​ 1) “zhangsan”​ 2) “60”​ 3) “wangwu”​ 4) “80”​ 5) “lisi”​ 6) “500”​ 3. 删除：zrem key value​ 127.0.0.1:6379&gt; zrem mysort lisi​ (integer) 1 7. 通用命令1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value四. 持久化1. redis是一个内存数据库​ 当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制：1. RDB：默认方式，不需要进行配置，默认就使用这种机制在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 after 900 sec (15 min) if at least 1 key changed save 900 1 after 300 sec (5 min) if at least 10 keys changed save 300 10 after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） \# appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 \# appendfsync no ： 不进行持久化五. Java客户端 Jedis​ Jedis: 一款java操作redis数据库的工具.​ 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(“localhost”,6379); //2. 操作 jedis.set(“username”,”zhangsan”); //3. 关闭连接 jedis.close(); ​ Jedis操作各种redis中的数据结构​ 1) 字符串类型 string​ set​ get​​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ //存储​ jedis.set(“username”,”zhangsan”);​ //获取​ String username = jedis.get(“username”);​ System.out.println(username);​​ //可以使用setex()方法存储可以指定过期时间的 key value​ jedis.setex(“activecode”,20,”hehe”);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对​​ //3. 关闭连接​ jedis.close(); ​ 2) 哈希类型 hash ： map格式​ hset​ hget​ hgetAll​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ // 存储hash​ jedis.hset(“user”,”name”,”lisi”);​ jedis.hset(“user”,”age”,”23”);​ jedis.hset(“user”,”gender”,”female”);​​ // 获取hash​ String name = jedis.hget(“user”, “name”);​ System.out.println(name);​​​ // 获取hash的所有map中的数据​ Map&lt;String, String&gt; user = jedis.hgetAll(“user”);​​ // keyset​ Set keySet = user.keySet();​ for (String key : keySet) {​ //获取value​ String value = user.get(key);​ System.out.println(key + “:” + value);​ }​​ //3. 关闭连接​ jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​​​ // set 存储​ jedis.sadd(“myset”,”java”,”php”,”c++”);​​ // set 获取​ Set myset = jedis.smembers(“myset”);​ System.out.println(myset);​​ //3. 关闭连接​ jedis.close();​ 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序​ zadd​ zrange ​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ // sortedset 存储​ jedis.zadd(“mysortedset”,3,”亚瑟”);​ jedis.zadd(“mysortedset”,30,”后裔”);​ jedis.zadd(“mysortedset”,55,”孙悟空”);​​ // sortedset 获取​ Set mysortedset = jedis.zrange(“mysortedset”, 0, -1);​​ System.out.println(mysortedset);​​​ //3. 关闭连接​ jedis.close(); jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils {​ private static JedisPool jedisPool;​​ static{​ //读取配置文件​ InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(“jedis.properties”);​ //创建Properties对象​ Properties pro = new Properties();​ //关联文件​ try {​ pro.load(is);​ } catch (IOException e) {​ e.printStackTrace();​ }​ //获取数据，设置到JedisPoolConfig中​ JedisPoolConfig config = new JedisPoolConfig();​ config.setMaxTotal(Integer.parseInt(pro.getProperty(“maxTotal”)));​ config.setMaxIdle(Integer.parseInt(pro.getProperty(“maxIdle”)));​​ //初始化JedisPool​ jedisPool = new JedisPool(config,pro.getProperty(“host”),Integer.parseInt(pro.getProperty(“port”)));​​​​ }​​​ /*​ \ 获取连接方法​ */​ public static Jedis getJedis(){​ return jedisPool.getResource();​ }​ } 六. 案例：​ 案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 注意：使用redis缓存一些不经常发生变化的数据。* 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。]]></content>
      <categories>
        <category>非关系型数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、Spring Boot配置文件详解：Properties和YAML]]></title>
    <url>%2F2019%2F08%2F23%2FSpring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%EF%BC%9AProperties%E5%92%8CYAML%2F</url>
    <content type="text"><![CDATA[Spring Boot配置文件详解：Properties和YAML一.配置文件的生效顺序，会对值进行覆盖： @TestPropertySource 注解 命令行参数 Java系统属性（System.getProperties()） 操作系统环境变量 只有在random.*里包含的属性会产生一个RandomValuePropertySource 在properties文件中设置随机值，随机数等 123456789101112131415161718192021222324252627#这个优先级较低#32位随机字符串roncoo.secret=$&#123;random.value&#125;#int类型的随机数字roncoo.number=$&#123;random.int&#125;roncoo.name=www.roncoo.com#属性占位符属性roncoo.desc=$&#123;roncoo.name&#125; is a domain name#应用端口server.port=8090#时间格式化spring.jackson.date-format=yyyy-MM-dd HH:mm:ss#时区设置spring.jackson.time-zone=Asia/Chongqing 在IndexController层中获取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.roncoo.education.controller;import java.util.Date;import java.util.HashMap;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.roncoo.education.bean.User;/** * spring-boot-demo-3-1 * * @author wujing */@RestController@RequestMapping(value = "/index")public class IndexController &#123; @Value(value = "$&#123;roncoo.secret&#125;") private String secret; @Value(value = "$&#123;roncoo.number&#125;") private int id; @Value(value = "$&#123;roncoo.desc&#125;") private String desc; @RequestMapping public String index() &#123; return "hello world"; &#125; // @RequestParam 简单类型的绑定，可以出来get和post @RequestMapping(value = "/get") public HashMap&lt;String, Object&gt; get(@RequestParam String name) &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("title", "hello world"); map.put("name", name); map.put("secret", secret); map.put("id", id); map.put("desc", desc); return map; &#125; // @PathVariable 获得请求url中的动态参数 @RequestMapping(value = "/get/&#123;id&#125;/&#123;name&#125;") public User getUser(@PathVariable int id, @PathVariable String name) &#123; User user = new User(); user.setId(id); user.setName(name); user.setDate(new Date()); return user; &#125;&#125; 二．配置随机值roncoo.secret=${random.value} roncoo.number=${random.int} roncoo.bignumber=${random.long} roncoo.number.less.than.ten=${random.int(10)} roncoo.number.in.range=${random.int[1024,65536]} 读取使用注解：@Value(value = “${roncoo.secret}”) 注：出现黄点提示，是要提示配置元数据，可以不配置 在打包的jar外的应用程序配置文件（application.properties，包含YAML和profile变量） 在打包的jar内的应用程序配置文件（application.properties，包含YAML和profile变量） 在@Configuration类上的@PropertySource注解 默认属性（使用SpringApplication.setDefaultProperties指定） 三．属性占位符当application.properties里的值被使用时，它们会被存在的Environment过滤，所以你能够引用先前定义的值（比如，系统属性）。 roncoo.name=www.roncoo.com roncoo.desc=${roncoo.name} is a domain name 四．Application属性文件，按优先级排序，位置高的将覆盖位置低的 当前目录下的一个/config子目录 当前目录 一个classpath下的/config包 classpath根路径（root） 这个列表是按优先级排序的（列表中位置高的将覆盖位置低的） 五. 配置应用端口和其他配置的介绍#端口配置： server.port=8090 #时间格式化 spring.jackson.date-format=yyyy-MM-dd HH:mm:ss #时区设置 spring.jackson.time-zone=Asia/Chongqing 六. 使用YAML代替Properties注意写法：冒号后要加个空格]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章，教你学会Git]]></title>
    <url>%2F2019%2F08%2F23%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E6%95%99%E4%BD%A0%E5%AD%A6%E4%BC%9AGit%2F</url>
    <content type="text"><![CDATA[一篇文章，教你学会Git 在日常工作中，经常会用到Git操作。但是对于新人来讲，刚上来对Git很陌生，操作起来也很懵逼。本篇文章主要针对刚开始接触Git的新人，理解Git的基本原理，掌握常用的一些命令。 一、Git工作流程 以上包括一些简单而常用的命令，但是先不关心这些，先来了解下面这4个专有名词。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 工作区 程序员进行开发改动的地方，是你当前看到的，也是最新的。 平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。 暂存区 .git目录下的index文件, 暂存区会记录git add添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用git status查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。 当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过git add先提交到暂存区，被git管理。 本地仓库 保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。 git commit后同步index的目录树到本地仓库，方便从下一步通过git push同步本地仓库与远程仓库的同步。 远程仓库 远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。 小结 任何对象都是在工作区中诞生和被修改； 任何修改都是从进入index区才开始被版本控制； 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹； 与协作者分享本地的修改，可以把它们push到远程仓库来共享。 下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。 二、常用Git命令 网上找了个图，别人整理的一张图，很全很好，借来用下。下面详细解释一些常用命令。 HEAD 在掌握具体命令前，先理解下HEAD。 HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。 add add相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。 git add . 添加当前目录的所有文件到暂存区 git add 添加指定目录到暂存区，包括子目录 git add 添加指定文件到暂存区 commit commit相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。 git commit -m 提交暂存区到本地仓库,message代表说明信息 git commit -m 提交暂存区的指定文件到本地仓库 git commit –amend -m 使用一次新的commit，替代上一次提交 branch 涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 git branch 新建一个分支，但依然停留在当前分支 git checkout -b 新建一个分支，并切换到该分支 git branch –track 新建一个分支，与指定的远程分支建立追踪关系 git checkout 切换到指定分支，并更新工作区 git branch -d 删除分支 git push origin –delete 删除远程分支 关于分支的操作虽然比较多，但都比较简单好记。 merge merge命令把不同的分支合并起来。如上图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。 git fetch merge之前先拉一下远程仓库最新代码 git merge 合并指定分支到当前分支 一般在merge之后，会出现conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。如下图所示，需要手动解除。 rebase rebase又称为衍合，是合并的另外一种选择。 在开始阶段，我们处于new分支上，执行git rebase dev，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。git rebase dev，通俗的解释就是new分支想站在dev的肩膀上继续下去。rebase也需要手动解决冲突。 rebase与merge的区别 现在我们有这样的两个分支,test和master，提交如下： 123456789D---E test /A---B---C---F master 在master执行git merge test,然后会得到如下结果： 123456789D--------E / \A---B---C---F----G test, master 在master执行git rebase test，然后得到如下结果： 1A---B---D---E---C&apos;---F&apos; test, master 可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。 如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge reset reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。 git reset —soft 只改变提交点，暂存区和工作目录的内容都不改变 git reset —mixed 改变提交点，同时改变暂存区的内容 git reset —hard 暂存区、工作区的内容都会被修改到与提交点完全一致的状态 git reset –hard HEAD 让工作区回到上次提交时的状态 revert git revert用一个新提交来消除一个历史提交所做的任何修改。 revert与reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 push上传本地仓库分支到远程仓库分支，实现同步。 git push 上传本地指定分支到远程仓库 git push –force 强行推送当前分支到远程仓库，即使有冲突 git push –all 推送所有分支到远程仓库 其他命令 git status 显示有变更的文件 git log 显示当前分支的版本历史 git diff 显示暂存区和工作区的差异 git diff HEAD 显示工作区与当前分支最新commit之间的差异 git cherry-pick 选择一个commit，合并进当前分支 以上就是关于Git的一些常用命令及详细阐述，相信能对Git有一个初步的认识。]]></content>
      <categories>
        <category>Git管理工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot RESTfull API简单项目的快速搭建]]></title>
    <url>%2F2019%2F08%2F23%2FRESTfull-API%E7%AE%80%E5%8D%95%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Spring Boot RESTfull API简单项目的快速搭建对spring框架盛行了多年的java方向开发人员来说，每个人java开发已经把spring框架当做开发中不可或缺的一部分。之前传统的模式都是以applicationContext.xml配置文件的形式存在，而对应大多数入门级开发人员来说配置出现一点纰漏就会导致运行失败或者更大的问题，因此会浪费开发人员很多宝贵的时间，对公司来说也是有所损失。那么spring开源组织很早之前就意识到这种问题的存在，于是他们便对spring框架的全系列组件进行了内部封装。对外只是提供maven（jar管理、项目打包工具）或者gradle（新兴jar管理、项目打包工具）的形式来进行引入parent.pom（maven配置文件）或者parent.gradle（gradle配置文件），让每一个spring项目都是以spring的子项目的形式来运行，这样开发人员不用再去注重配置文件的繁琐而是把精力放到业务逻辑以及更深层次的架构方面。自此SpringBoot就诞生了，它有着纯正的开源血统，在此非常感谢spring开源组织给我们java开发人员带来的便利！ SpringBoot主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 提供一系列大型企业级项目的功能性特性（比如：安全、健康检测、外部化配置、数据库访问、restful搭建等很多特性这里就不一一叙说了，后期文章会陆续更新） 本章目的使用springboot完成一个简单的web（springmvc）应用程序，通过@restController输出”HelloWord”到界面，让我们初步体验springboot的快速开发、简单的特性。 系统要求 jdk1.8 springboot 1.5.2.RELEASE 开发工具（IntelliJ IDEA 2017.1.1） 数据库管理工具（Navicat Premium 11.1.7） 文本管理工具（sublime text 3） apache maven（3.3.9，本章采用maven形式管理jar包，具体配置环境变量以及使用请自行查找资料） 开始构建项目目前构建项目有多种方式我这里简单介绍两种。1、使用spring官网 SPRING INITIALIZR 来构建项目结构（地址：http://start.spring.io/）2、使用IntelliJ IDEA开发工具来构建项目结构 使用SPRING INITIALIZR构建访问start.spring.io/网址就会看到如下 “图1” 界面：界面主要部分包括：管理工具，springboot版本，包名（group），工程名（Artifact），已选模块（我已经选择了一个web模块）。点击Generate Project就会下载一个根据你输入的信息创建的项目工程架构源码的压缩包。解压压缩包到指定目录（目录你可以随意定义）我这里为了后续操作先定义到E:/lessions内可以看到如下“图2”所示：解压完成之后我们就可以通过IntelliJ IDEA开发工具导入到工程， 菜单中选择File–&gt;New–&gt;Project from Existing Sources… 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 若你的环境有多个版本的JDK，注意到选择Java SDK的时候请选择系统安装1.8版本 使用IntelliJ IDEA构建打开工具，界面如下 “图3” 所示：我们点击Create New Project来创建一个新的springboot应用程序，点击后如下“图4”所示：我们点击Next继续下一步操作，根据界面输入选项填写对应的内容即可如“图5”所示：点击Next即可完成创建项目，而且创建完成后会自动导入到项目工程内就不需要再次import操作，这种方式会比较简单些，所以我们的文章内都会采用第二种形式来创建新工程。 在下一步我们勾选Web依赖加入到我们的项目中，如下图所示： 项目目录结构我们来看看工具为我们生成新工程的目录结构，如”图6“所示：我们可以看到目录结构有如下几个： 1、/src/main/java/ 存放项目所有源代码目录2、/src//main/resources/ 存放项目所有资源文件以及配置文件目录3、/src/test/ 存放测试代码目录 自动生成的文件解释SpringBoot21Application 该类是程序的入口类内有个main方法，可以直接通过run as运行项目application.properties 该配置文件是项目的核心配置文件，以xx.xx.xx的形式存在pom.xml maven配置文件，因为我们采用的maven管理jar，所以这里会自动生成一个pom文件 @SpringBootApplication注解我们可以看到工具为我们自动生成的入口程序是有@SpringBootApplication的这么一个注解，那它主要是做什么的呢？不难看出，它是声明当前类为sprinboot的入口类。而一个springboot项目内有且只能有一个这个注解存在。 初尝试运行项目我们在入口程序类中右键-&gt;Run LessonOneApplication在控制台的输出如下”图8“所示，证明你已经成功的运行了springboot项目。 可以看到我们的项目是通过内置的tomcat容器启动的，并且端口号默认是8080（至于如何修改端口号后期文章中更新）。我们现在通过浏览器直接访问是得不到任何回应的，只是会有一个错误页面，如下”图9“所示 编写IndexController我们首先在/src/main/java/com/lqg (该目录是你构建项目的目录) 目录下创建一个叫做controller的包，然后在controller包下再创建一个叫做IndexController的类，我们使用@RestController来声明我们新创建的IndexController是一个访问控制器,详细代码如下： 1234567891011121314package com.lqg.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String index()&#123; return "hello spring boot"; &#125;&#125;12345678910111213 可以看到我在IndexController类上配置了一个@RequestMapping注解来声明index()方法可以通过127.0.0.1:8080/index访问到，那么我们接下来重新启动项目（项目中如果重启出错应该是注解配置问题），访问地址如下”图10“所示：在IndexController类里面在写一个方法，返回值是map集合，参数列表是String类型的name，@RequestParam简单类型的绑定的注解，这个注解要放在参数列表的前面 1234567891011121314151617181920212223242526272829303132package com.lqg.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String hello()&#123; return "hello spring boot "; &#125; /** * @RequestParam 简单类型的绑定，可以出来get和post * @param name * @return */ @RequestMapping(value = "/get") public HashMap&lt;String,Object&gt; get(@RequestParam String name)&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("title", "hello world"); map.put("name", name); return map; &#125;&#125;12345678910111213141516171819202122232425262728293031 那么Controller层是如何返回一个Bean对象呢？先在/src/main/java/com/lqg下面创建一个bean包，在bean包里创建一个User类，详细代码如下： 1234567891011121314151617181920package com.lqg.bean;import lombok.Getter;import lombok.Setter;import java.util.Date;/** * @author 凌枫lqg */@Getter@Setterpublic class User &#123; private int id; private String name; private Date date;&#125;12345678910111213141516171819 @Getter@Setter：注解是lombok插件里面的，用这个注解就可以省略getter和setter方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lqg.controller;import com.lqg.bean.User;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.xml.crypto.Data;import java.util.Date;import java.util.HashMap;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String hello()&#123; return "hello spring boot "; &#125; /** * @RequestParam 简单类型的绑定，可以出来get和post * @param name * @return */ @RequestMapping(value = "/get") public HashMap&lt;String,Object&gt; get(@RequestParam String name)&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("title", "hello world"); map.put("name", name); return map; &#125; /** * @PathVariable 获得请求url中的动态参数 * @param id * @param name * @return */ @RequestMapping(value = "/find/&#123;id&#125;/&#123;name&#125;") public User get(@PathVariable int id,@PathVariable String name)&#123; User user = new User(); user.setId(id); user.setName(name); user.setDate(new Date()); return user; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 第二个方法访问的结果如下第三个方法访问的结果如下： SpringBoot的测试SpringBoot测试可以通过Spring提供的测试类MockMvc 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lqg;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import com.lqg.controller.IndexController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import com.lqg.controller.IndexController;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootDemo21ApplicationTests &#123; //SpringBoot测试可以通过Spring提供的测试类MockMvc private MockMvc mvc; @Before public void setup() &#123; //这是通过setup方法引入mvc this.mvc = MockMvcBuilders.standaloneSetup(new IndexController()).build(); &#125; @Test public void contextLoads() throws Exception &#123; //生成request一个请求 RequestBuilder request = get("/index"); //用mvc的请求，期望它的状态码是ok的，期望它返回的内容，返回的是一个字符串hello spring boot mvc.perform(request).andExpect(status().isOk()).andExpect(content().string("hello spring boot")); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940 SpringBoot打包 打包成功后的jar包，打包命令mvn clean install -DskipTests 在命令行运行spring boot]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea中如何导入mysql驱动包]]></title>
    <url>%2F2019%2F08%2F23%2Fidea%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5mysql%E9%A9%B1%E5%8A%A8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[IDEA怎样导入mysql的驱动包注：刚开始用用csdn写博文，写的不好，还请各位博客好友见谅，也可以互相提意见，共同进步！首先需要有mysql的驱动包，没有可以在mysql官网下载 有了驱动包后，就开始进入怎样用IDEA导入mysql驱动包了 1. 打开你的idea工程，点击File2.找到Project Structure并点击3.找到Modules并点击4.找到Dependencies并点击2.找到Project Structure并点击5.找到Scope右边的+号并点击2.选第一个JARs or directories，找到文件mysql-connector-java-版本号-bin.jar，然后点击ok就成功了]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019最新的解决百度网盘下载限速的方法，不限速下载百度云破解版]]></title>
    <url>%2F2019%2F08%2F23%2F2019%E6%9C%80%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%B8%8B%E8%BD%BD%E9%99%90%E9%80%9F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%99%90%E9%80%9F%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E4%BA%91%E7%A0%B4%E8%A7%A3%E7%89%88%2F</url>
    <content type="text"><![CDATA[2019最新的解决百度网盘下载限速的方法，不限速下载百度云破解版下载地址，点击下载，提取码：c25f 永久有效https://pan.baidu.com/s/1G2X8diMTPzTyC_oOvgkyWw 不限速下载以下为软件使用教程，必看 软件使用教程：首先：在打开软件以后先观察是否弹出更新提示，如果有更新提示则必须要更新，一般选择在线自动更新。 第一步，把压缩包下载并解压到你的电脑上，但不要解压到C盘和桌面上。解压完成以后文件夹里的文件如图所示图中用红圈圈出来的文件就是运行的主程序第二步：点击红框中的文件会出现下图中的样子第三步：然后登陆自己的网盘账号以后开始下载情况1、下载自己网盘里的东西 登录之后找到你网盘里的想要下载的文件（不要直接点下载），点击“分享并下载”，然后再确认下载就OK了。 情况2、如果下载在别处获得的链接，请在“下载”栏目下面的“下载分享链接”处下载。如果出现无限验证码或其他错误也可以先保存到自己网盘，然后用1中的方法。软件非常好用，需要的同学可以点击下载了：链接：https://pan.baidu.com/s/1G2X8diMTPzTyC_oOvgkyWw&gt; 提取码：c25f 永久有效]]></content>
      <categories>
        <category>百度云</category>
      </categories>
      <tags>
        <tag>baiduyun</tag>
      </tags>
  </entry>
</search>
