<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring MVC表单验证器的使用]]></title>
    <url>%2F2019%2F08%2F27%2FSpring-MVC%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SpringMVC表单验证器的使用本章讲解SpringMVC中怎么通过注解对表单参数进行验证。 SpringBoot配置使用springboot， spring-boot-starter-web会自动引入 hiberante-validator, validation-api依赖。 在 WebMvcConfigurerAdapter实现类里面添加验证器及国际化指定资源文件。 1234567891011@Overridepublic Validator getValidator() &#123; LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean(); validator.setValidationMessageSource(messageSource()); return validator;&#125;@Beanpublic MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename("i18n/ValidationMessages"); messageSource.setDefaultEncoding(StandardCharsets.US_ASCII.name()); return messageSource;&#125; 验证器使用接收参数的表单类： 1234567891011121314151617181920public class LoginForm &#123; @NotNull(message = "&#123;login.loginName.length&#125;") @Size(min = 4, max = 20, message = "&#123;login.loginName.length&#125;") private String loginName; @NotNull(message = "&#123;login.loginPassword.length&#125;") @Size(min = 8, max = 20, message = "&#123;login.loginPassword.length&#125;") private String loginPassword; public String getLoginName() &#123; return loginName; &#125; public void setLoginName(String loginName) &#123; this.loginName = loginName; &#125; public String getLoginPassword() &#123; return loginPassword; &#125; public void setLoginPassword(String loginPassword) &#123; this.loginPassword = loginPassword; &#125;&#125; 在要验证的字段上面加入验证注解，更多参考 validation-apijar包下的 javax.validation.constraints包。 SpringMVC控制器： 123@PostMapping(value = "/login")public String login(@Validated LoginForm form) &#123; ...&#125; 使用 @Validated注解表示该参数需要验证。 国际化message里面 {}引用的是国际化的资源。 添加国际化资源文件： ValidationMessages.properties ValidationMessageszhCN.properties 需要指定编码为 ASCII，不然会乱码。 异常处理异常全局处理时进行处理： 123456789101112131415@ControllerAdvicepublic class ExceptionResolver &#123; @ExceptionHandler(Throwable.class) @ResponseBody Object handleEntityException(HttpServletRequest request, Throwable ex) &#123; ... if (ex instanceof BindException) &#123; BindException c = (BindException) ex; List&lt;ObjectError&gt; errors = c.getBindingResult().getAllErrors(); StringBuilder errorMsg = new StringBuilder(); errors.forEach(x -&gt; errorMsg.append(x.getDefaultMessage()).append(",")); &#125; ... &#125;&#125; 或者在验证的类后面加 BindingResult，错误信息都会放在该对象里面，而不会抛出异常。如： 1234@PostMapping(value = "/login")public String login(@Validated LoginForm form, BindingResult bindingResult) &#123;...&#125;]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始手写一个Spring MVC框架，向高手进阶！]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AASpring-MVC%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%EF%BC%81%2F</url>
    <content type="text"><![CDATA[从 0 开始手写一个 Spring MVC 框架，向高手进阶！Spring框架对于Java后端程序员来说再熟悉不过了，以前只知道它用的反射实现的，但了解之后才知道有很多巧妙的设计在里面。如果不看Spring的源码，你将会失去一次和大师学习的机会：它的代码规范，设计思想很值得学习。 我们程序员大部分人都是野路子，不懂什么叫代码规范。写了一个月的代码，最后还得其他老司机花3天时间重构，相信大部分老司机都很头疼看新手的代码。 废话不多说，我们进入今天的正题，在Web应用程序设计中，MVC模式已经被广泛使用。SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。点击这里学习 Spring MVC 常用注解。 想要实现自己的SpringMVC框架，需要从以下几点入手： 了解SpringMVC运行流程及九大组件 梳理自己的SpringMVC的设计思路 实现自己的SpringMVC框架 一、了解SpringMVC运行流程及九大组件1、SpringMVC的运行流程 ⑴ 用户发送请求至前端控制器DispatcherServlet ⑵ DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ⑶ 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ⑷ DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 ⑸ 执行处理器(Controller，也叫后端控制器)。 ⑹ Controller执行完成返回ModelAndView ⑺ HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet ⑻ DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ⑼ ViewReslover解析后返回具体View ⑽ DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 ⑾ DispatcherServlet响应用户。从上面可以看出，DispatcherServlet有接收请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度。 2、SpringMVC的九大组件1234567891011121314151617181920protected void initStrategies(ApplicationContext context) &#123; //用于处理上传请求。处理方法是将普通的request包装成 MultipartHttpServletRequest，后者可以直接调用getFile方法获取File. initMultipartResolver(context); //SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。 initLocaleResolver(context); //用于解析主题。SpringMVC中一个主题对应 一个properties文件，里面存放着跟当前主题相关的所有资源、//如图片、css样式等。SpringMVC的主题也支持国际化， initThemeResolver(context); //用来查找Handler的。 initHandlerMappings(context); //从名字上看，它就是一个适配器。Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。//如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情 initHandlerAdapters(context); //其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？//这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。 initHandlerExceptionResolvers(context); //有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，//如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。 initRequestToViewNameTranslator(context);//ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。//View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。 initViewResolvers(context); //用来管理FlashMap的，FlashMap主要用在redirect重定向中传递参数。 initFlashMapManager(context); &#125; 二、梳理SpringMVC的设计思路本文只实现自己的@Controller、@RequestMapping、@RequestParam注解起作用，其余SpringMVC功能读者可以尝试自己实现。 1、读取配置 从图中可以看出，SpringMVC本质上是一个Servlet,这个 Servlet 继承自 HttpServlet。FrameworkServlet负责初始化SpringMVC的容器，并将Spring容器设置为父容器。因为本文只是实现SpringMVC，对于Spring容器不做过多讲解。点击这里学习 Spring MVC 常用注解。 为了读取web.xml中的配置，我们用到ServletConfig这个类，它代表当前Servlet在web.xml中的配置信息。通过web.xml中加载我们自己写的MyDispatcherServlet和读取配置文件。 2、初始化阶段在前面我们提到DispatcherServlet的initStrategies方法会初始化9大组件，但是这里将实现一些SpringMVC的最基本的组件而不是全部，按顺序包括： 加载配置文件 扫描用户配置包下面所有的类 拿到扫描到的类，通过反射机制，实例化。并且放到ioc容器中(Map的键值对 beanName-bean) beanName默认是首字母小写 初始化HandlerMapping，这里其实就是把url和method对应起来放在一个k-v的Map中,在运行阶段取出 3、运行阶段每一次请求将会调用doGet或doPost方法，所以统一运行阶段都放在doDispatch方法里处理，它会根据url请求去HandlerMapping中匹配到对应的Method，然后利用反射机制调用Controller中的url对应的方法，并得到结果返回。按顺序包括以下功能： 异常的拦截 获取请求传入的参数并处理参数 通过初始化好的handlerMapping中拿出url对应的方法名，反射调用。 三、实现自己的SpringMVC框架工程文件及目录： 首先，新建一个maven项目，在pom.xml中导入以下依赖： 12345678910111213141516171819202122&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.liugh&lt;/groupId&gt; &lt;artifactId&gt;liughMVC&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF- 8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 接着，我们在WEB-INF下创建一个web.xml，如下配置： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;MySpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;com.liugh.servlet.MyDispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;application.properties&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MySpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; application.properties文件中只是配置要扫描的包到SpringMVC容器中。 1scanPackage=com.liugh.core 创建自己的Controller注解，它只能标注在类上面： 12345678910111213141516171819package com.liugh.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyController &#123; /** * 表示给controller注册别名 * @return */ String value() default "";&#125; RequestMapping注解，可以在类和方法上： RequestParam注解,只能注解在参数上 12345678910111213141516171819package com.liugh.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyRequestParam &#123; /** * 表示参数的别名，必填 * @return */ String value();&#125; 然后创建MyDispatcherServlet这个类，去继承HttpServlet，重写init方法、doGet、doPost方法，以及加上我们第二步分析时要实现的功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245package com.liugh.servlet;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Method;import java.net.URL;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Properties;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.liugh.annotation.MyController;import com.liugh.annotation.MyRequestMapping;public class MyDispatcherServlet extends HttpServlet&#123;private Properties properties = new Properties();private List&lt;String&gt; classNames = new ArrayList&lt;&gt;();private Map&lt;String, Object&gt; ioc = new HashMap&lt;&gt;();private Map&lt;String, Method&gt; handlerMapping = new HashMap&lt;&gt;();private Map&lt;String, Object&gt; controllerMap =new HashMap&lt;&gt;();@Overridepublic void init(ServletConfig config) throws ServletException &#123; //1.加载配置文件 doLoadConfig(config.getInitParameter("contextConfigLocation")); //2.初始化所有相关联的类,扫描用户设定的包下面所有的类 doScanner(properties.getProperty("scanPackage")); //3.拿到扫描到的类,通过反射机制,实例化,并且放到ioc容器中(k-v beanName-bean) beanName默认是首字母小写 doInstance(); //4.初始化HandlerMapping(将url和method对应上) initHandlerMapping(); &#125;@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req,resp);&#125;@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; //处理请求 doDispatch(req,resp); &#125; catch (Exception e) &#123; resp.getWriter().write("500!! Server Exception"); &#125;&#125;private void doDispatch(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; if(handlerMapping.isEmpty())&#123; return; &#125; String url =req.getRequestURI(); String contextPath = req.getContextPath(); url=url.replace(contextPath, "").replaceAll("/+", "/"); if(!this.handlerMapping.containsKey(url))&#123; resp.getWriter().write("404 NOT FOUND!"); return; &#125; Method method =this.handlerMapping.get(url); //获取方法的参数列表 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //获取请求的参数 Map&lt;String, String[]&gt; parameterMap = req.getParameterMap(); //保存参数值 Object [] paramValues= new Object[parameterTypes.length]; //方法的参数列表 for (int i = 0; i&lt;parameterTypes.length; i++)&#123; //根据参数名称，做某些处理 String requestParam = parameterTypes[i].getSimpleName(); if (requestParam.equals("HttpServletRequest"))&#123; //参数类型已明确，这边强转类型 paramValues[i]=req; continue; &#125; if (requestParam.equals("HttpServletResponse"))&#123; paramValues[i]=resp; continue; &#125; if(requestParam.equals("String"))&#123; for (Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123; String value =Arrays.toString(param.getValue()).replaceAll("\[|\]", "").replaceAll(",\s", ","); paramValues[i]=value; &#125; &#125; &#125; //利用反射机制来调用 try &#123; method.invoke(this.controllerMap.get(url), paramValues);//第一个参数是method所对应的实例 在ioc容器中 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;private void doLoadConfig(String location)&#123; //把web.xml中的contextConfigLocation对应value值的文件加载到流里面 InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(location); try &#123; //用Properties文件加载文件里的内容 properties.load(resourceAsStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //关流 if(null!=resourceAsStream)&#123; try &#123; resourceAsStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;private void doScanner(String packageName) &#123; //把所有的.替换成/ URL url =this.getClass().getClassLoader().getResource("/"+packageName.replaceAll("\.", "/")); File dir = new File(url.getFile()); for (File file : dir.listFiles()) &#123; if(file.isDirectory())&#123; //递归读取包 doScanner(packageName+"."+file.getName()); &#125;else&#123; String className =packageName +"." +file.getName().replace(".class", ""); classNames.add(className); &#125; &#125;&#125;private void doInstance() &#123; if (classNames.isEmpty()) &#123; return; &#125; for (String className : classNames) &#123; try &#123; //把类搞出来,反射来实例化(只有加@MyController需要实例化) Class&lt;?&gt; clazz =Class.forName(className); if(clazz.isAnnotationPresent(MyController.class))&#123; ioc.put(toLowerFirstWord(clazz.getSimpleName()),clazz.newInstance()); &#125;else&#123; continue; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); continue; &#125; &#125;&#125;private void initHandlerMapping()&#123; if(ioc.isEmpty())&#123; return; &#125; try &#123; for (Entry&lt;String, Object&gt; entry: ioc.entrySet()) &#123; Class&lt;? extends Object&gt; clazz = entry.getValue().getClass(); if(!clazz.isAnnotationPresent(MyController.class))&#123; continue; &#125; //拼url时,是controller头的url拼上方法上的url String baseUrl =""; if(clazz.isAnnotationPresent(MyRequestMapping.class))&#123; MyRequestMapping annotation = clazz.getAnnotation(MyRequestMapping.class); baseUrl=annotation.value(); &#125; Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; if(!method.isAnnotationPresent(MyRequestMapping.class))&#123; continue; &#125; MyRequestMapping annotation = method.getAnnotation(MyRequestMapping.class); String url = annotation.value(); url =(baseUrl+"/"+url).replaceAll("/+", "/"); handlerMapping.put(url,method); controllerMap.put(url,clazz.newInstance()); System.out.println(url+","+method); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;/** * 把字符串的首字母小写 * @param name * @return */private String toLowerFirstWord(String name)&#123; char[] charArray = name.toCharArray(); charArray[0] += 32; return String.valueOf(charArray);&#125;&#125; 这里我们就开发完了自己的SpringMVC，现在我们测试一下： 123456789101112131415161718192021222324252627282930313233343536package com.liugh.core.controller;import java.io.IOException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.liugh.annotation.MyController;import com.liugh.annotation.MyRequestMapping;import com.liugh.annotation.MyRequestParam;@MyController@MyRequestMapping("/test")public class TestController &#123; @MyRequestMapping("/doTest") public void test1(HttpServletRequest request, HttpServletResponse response, @MyRequestParam("param") String param)&#123; System.out.println(param); try &#123; response.getWriter().write( "doTest method success! param:"+param); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @MyRequestMapping("/doTest2") public void test2(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; response.getWriter().println("doTest2 method success!"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 访问 http://localhost:8080/liughMVC/test/doTest?param=liugh如下： 访问一个不存在的试试： 到这里我们就大功告成了！水平有限，文章难免有错误，欢迎牺牲自己宝贵时间的读者，就本文内容直抒己见，我的目的仅仅是希望对读者有所帮助。 源码地址：/github.com/qq53182347/liughMVC]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC表单防止重复提交]]></title>
    <url>%2F2019%2F08%2F27%2FSpring-MVC%E8%A1%A8%E5%8D%95%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[Spring MVC表单防重复提交利用Spring MVC的过滤器及token传递验证来实现表单防重复提交。 创建注解1234567@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Token &#123; boolean create() default false; boolean remove() default false;&#125; 在跳转页面的方法上加上：@Token(create = true)\ 在提交的action方法上加上：@Token(remove = true) 创建过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TokenInterceptor extends HandlerInterceptorAdapter &#123; private Logger logger = Logger.getLogger(TokenInterceptor.class); private static final String TOKEN = "token"; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod) &#123; Method method = ((HandlerMethod) handler).getMethod(); Token annotation = method.getAnnotation(Token.class); if (annotation != null) &#123; HttpSession session = request.getSession(); // 创建token boolean create = annotation.create(); if (create) &#123; session.setAttribute(TOKEN, UUID.randomUUID().toString()); return true; &#125; // 删除token boolean remove = annotation.remove(); if (remove) &#123; if (isRepeatSubmit(request)) &#123; logger.warn("表单不能重复提交:" + request.getRequestURL()); return false; &#125; session.removeAttribute(TOKEN); &#125; &#125; &#125; else &#123; return super.preHandle(request, response, handler); &#125; return true; &#125; private boolean isRepeatSubmit(HttpServletRequest request) &#123; String token = (String) request.getSession().getAttribute(TOKEN); if (token == null) &#123; return true; &#125; String reqToken = request.getParameter(TOKEN); if (reqToken == null) &#123; return true; &#125; if (!token.equals(reqToken)) &#123; return true; &#125; return false; &#125; &#125; 配置拦截器123456&lt;!--配置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean class="com.example.web.interceptor.TokenInterceptor"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 表单添加token1&lt;input type=&quot;hidden&quot; id=&quot;token&quot; name=&quot;token&quot; value=&quot;$!&#123;session.getAttribute(&apos;token&apos;)&#125;&quot;/&gt; 在form表单里面添加token域，提交表单时需要传过去。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Controller,@Service,@Component详解]]></title>
    <url>%2F2019%2F08%2F27%2FController-Service-Component%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@Controller,@Service,@Repository,@Component详解。@Controller 用来表示一个web控制层bean，如SpringMvc中的控制器。 @Service 用来表示一个业务层bean。 @Repository 用来表示一个持久层bean，即数据访问层DAO组件。 @Component 用来表示一个平常的普通组件，当一个类不合适用以上的注解定义时用这个组件修饰。 需要注意的是@Controller，@Service，@Repository都有带@Component父注解，说明它们除了基本组件的属性外还有其他的的场景应用，即如果不用SpringMVC其实它们就是一个普通的组件，但普通组件建议最好还是用@Component修饰。 为了让Spring自动扫描注册这些组件，需要在配置文件中加上扫描的配置，如扫描com.test包下的注解。 &lt;context:component-scan base-package=”com.test” /&gt; 些扫描配置默认use-default-filters=”true”，默认扫描@Component注解及子注解，可以配置过滤只扫描哪些注解不扫描哪些注解。 要过滤扫描注解，需要相应的带上下面的子标签，可以有多个。 context:include-filter context:exclude-filter 如只扫描com.test包下的@Controller和@Service注解的组件。 &lt;context:component-scan base-package=”com.test” use-default-filters=”false”&gt; ​ &lt;context:include-filter type=”annotation” expression=”org.springframework.stereotype.Controller”/&gt; ​ &lt;context:include-filter type=”annotation” expression=”org.springframework.stereotype.Service”/&gt; 关于type的定义 Filter Type Examples Expression Description annotation org.example.SomeAnnotation 符合SomeAnnoation的target class assignable org.example.SomeClass 指定class或interface的全名 aspectj org.example..*Service+ AspectJ语法 regex org.example.Default.* Regelar Expression custom org.example.MyTypeFilter 自定义Type，实现接口org.springframework.core.type.TypeFilter 另外，context:component-scan配置可以有多个。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC常用注解，你会几个]]></title>
    <url>%2F2019%2F08%2F27%2FSpring-MVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%87%A0%E4%B8%AA%2F</url>
    <content type="text"><![CDATA[常用注解 Controller 注解一个类表示控制器，Spring MVC会自动扫描标注了这个注解的类。 RequestMapping 请求路径映射，可以标注类，也可以是方法，可以指定请求类型，默认不指定为全部接收。 RequestParam 放在参数前，表示只能接收参数a=b格式的数据，即 Content-Type为 application/x-www-form-urlencoded类型的内容。 RequestBody 放在参数前，表示参数从request body中获取，而不是从地址栏获取，所以这肯定是接收一个POST请求的非a=b格式的数据，即 Content-Type不为 application/x-www-form-urlencoded类型的内容。 ResponseBody 放在方法上或者返回类型前，表示此方法返回的数据放在response body里面，而不是跳转页面。一般用于ajax请求，返回json数据。 RestController 这个是Controller和ResponseBody的组合注解，表示@Controller标识的类里面的所有返回参数都放在response body里面。 PathVariable 路径绑定变量，用于绑定restful路径上的变量。 @RequestHeader 放在方法参数前，用来获取request header中的参数值。 @CookieValue; 放在方法参数前，用来获取request header cookie中的参数值。 GetMapping PostMapping PutMapping.. *Mapping的是Spring4.3加入的新注解，表示特定的请求类型路径映射，而不需要写RequestMethod来指定请求类型。 演示12345678910111213141516171819import org.dom4j.util.UserDataElement;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody; @Controller @RequestMapping("/test") public class TestController &#123; @RequestMapping(value = "/get/&#123;no&#125;", method = RequestMethod.GET) @ResponseBody public Object get(@PathVariable("no") String no) &#123; return new UserDataElement(""); &#125; @RequestMapping(value = "/save", method = RequestMethod.POST) public void save(@RequestBody UserDataElement user) &#123; &#125; &#125;]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis第2天]]></title>
    <url>%2F2019%2F08%2F26%2FMyBatis%E7%AC%AC2%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1关联查询1.1 案例：用户和定单 Ø user和orders：User 与orders：一个用户可以创建多个订单，一对多Orders 与 user：多个订单只由一个用户创建，多对一Ø orders**和orderdetail：Orders 与 orderdetail：一个订单可以包括 多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系orderdetail 与orders：多个订单明细包括在一个订单中, 多对一Ø** orderdetail**和items：**Orderdetail 与 items：多个订单明细只对应一个商品信息，多对一Items 与 orderdetail:一个商品可以包括在多个订单明细 ，一对多 需求：根据**商品ID查找定单信息，包括用户名和地址** #查找id为10的所有定单SELECT orders.id, orders.number,orders.createtime,orders.note,user.username,user.addressFROM orders ,user WHERE orders.user_id = user.id AND user.id = 10; 1.2 一对一 resultType实现复杂查询时，单表对应的po类已不能满足输出结果集的映射。所以要根据需求建立一个扩展类来作为resultType的类型。 #查找某个定单id的信息，包括用户名字和地址SELECT o.*,u.username,u.address FROM orders o,user uWHERE o.user_id = u.id AND o.id = 3 第一步：写个定单的扩展类 第二步：声明定单接口 第三步：声明定单配置文件 第四步：**加载映射文件** 第五步：测试 一对一 resultMap实现掌握association的使用 OrdersMapper.java添加一个方法 OrdersMapper.xml 测试 总结resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。 resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的对象属性中。 resultMap可以实现延迟加载，resultType无法实现延迟加载。 1.3 一对多需求：根据定单ID查找定单信息、用户信息和定单明细信息 Select orders.id, orders.user_id, orders.number, orders.createtime, orders.note, user.username, user.address, orderdetail.id detail_id, orderdetail.items_id, orderdetail.items_num from orders,user,orderdetail where orders.user_id = user.id and orders.id = orderdetail.orders_id and orders.id = #{?}; SELECT o.*, u.username, u.address, od.id detail_id, od.items_id, od.items_numFROM orders o, user u, orderdetail odWHERE o.user_id = u.id AND o.id = od.orders_id AND o.id = 3 目标：掌握collection的使用 第一步：在Orders中添加定单明细 第二步：Mapper接口 第三步：OrderMapper.xmlresultMap中有个extends属性，可以继承【自行研究】 第四步：测试 总结mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。 使用resultType实现： 需要对结果集进行二次处理。 将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。 1.4 多对多需求查询用户信息及用户购买的商品信息，要求将关联信息映射到主pojo的pojo属性中 Sql Select user.id, user.username, user.address, orders.id orders_id, orders.user_id, orders.number, orders.createtime, orders.note, orderdetail.id detail_id, orderdetail.items_id, orderdetail.items_num, items.name items_name, items.detail items_detail FROM USER,orders,orderdetail,items WHERE user.id = orders.user_id AND orders.id = orderdetail.orders_id AND orderdetail.items_id = items.id SELECT u.id, u.username, u.address, o.id order_id, o.number, o.createtime, o.note, od.id detail_id, od.items_id, od.items_num, it.name, it.price, it.detailFROM user u, orders o, orderdetail od, items itWHERE o.user_id = u.id AND o.id = od.orders_id AND od.items_id = it.id; 映射思路v 将用户信息映射到user中。 v 在user类中添加订单列表属性List orderslist，将用户创建的订单映射到orderslist v 在Orders中添加订单明细列表属性List detailList，将订单的明细映射到detailList v 在Orderdetail中添加Items属性，将订单明细所对应的商品映射到Items 第一步：UserMapper.java 第二步：User/Orders/Orderdetail.java 第三步：UserMapper.xml 第四步：测试 打印效果 总结resultType：将查询结果按照sql列名pojo属性名一致性映射到pojo中。 resultMap：使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。 association：将关联查询信息映射到一个pojo对象中。 collection：将关联查询信息映射到一个list集合中。 2 延时加载2.1 延迟加载延迟加载又叫懒加载，也叫按需加载。也就是说先加载主信息，在需要的时候，再去加载从信息。 在mybatis中，resultMap标签 的association标签和collection标签具有延迟加载的功能。 2.1 案例：Mapper.java Mapper.xml UserMappler.xml OrdersMapper.xml 测试 配置懒加载 3查询缓存3.1 M**ybatis的缓存理解**Mybatis的缓存，包括一级缓存和二级缓存，一级缓存是默认使用的。二级缓存需要手动开启。 一级缓存指的就是sqlsession，在sqlsession中有一个数据区域，是map结构，这个区域就是一级缓存区域。一级缓存中的key是由sql语句、条件、statement等信息组成一个唯一值。一级缓存中的value，就是查询出的结果对象。 二级缓存指的就是同一个namespace下的mapper，二级缓存中，也有一个map结构，这个区域就是一级缓存区域。一级缓存中的key是由sql语句、条件、statement等信息组成一个唯一值。一级缓存中的value，就是查询出的结果对象。 3.2 一级缓存原理： 测试1 测试2 3.3 二级缓存原理： 使用：开启二级缓存**总开关** UserMapper中配置二级缓存 User系列化 测试 禁用**指定方法二级**缓存 刷新缓存 3.4 整合**ehcache**Mybatis本身是一个持久层框架，它不是专门的缓存框架，所以它对缓存的实现不够好，不能支持分布式。 Ehcache是一个分布式的缓存框架。 什么是分布式系统为了提高性能，通常会对系统采用分布式部署（集群部署方式） 整合思路Cache是一个接口，它的默认实现是mybatis的PerpetualCache。如果想整合mybatis的二级缓存，那么实现Cache接口即可。 添加jar包 设置映射文件中cache标签的type值为ehcache的实现类 在src下**添加ehcache的配置文件** Ø maxElementsInMemory :设置基于内存的缓存中可存放的对象最大数目 Ø eternal:设置对象是否为永久的,true表示永不过期,此时将忽略Ø timeToIdleSeconds 和 timeToLiveSeconds属性; 默认值是false Ø timeToIdleSeconds:设置对象空闲最长时间,以秒为单位, 超过这个时间,对象过期。当对象过期时,EHCache会把它从缓存中清除。如果此值为0,表示对象可以无限期地处于空闲状态。 Ø timeToLiveSeconds:设置对象生存最长时间,超过这个时间,对象过期。如果此值为0,表示对象可以无限期地存在于缓存中. 该属性值必须大于或等于 timeToIdleSeconds 属性值 Ø overflowToDisk:设置基于内在的缓存中的对象数目达到上限后,是否把溢出的对象写到基于硬盘的缓存中 Ø diskPersistent 当jvm结束时是否持久化对象 true false 默认是falseØ diskExpiryThreadIntervalSeconds 指定专门用于清除过期对象的监听线程的轮询时间memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） 测试：用上面二级缓存例子即可二级缓存**应用场景**使用场景：对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。 注意：在使用二级缓存的时候，要设置一下刷新间隔（cache标签中有一个flashInterval属性）来定时刷新二级缓存，这个刷新间隔根据具体需求来设置，比如设置30分钟、60分钟等，单位为毫秒。 局限性M**ybatis二级缓存对细粒度的数据，缓存实现不好。** 场景： 对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次查询都是最新的商品信息，此时如果使用二级缓存，就无法实现当一个商品发生变化只刷新该商品的缓存信息而不刷新其他商品缓存信息，因为二级缓存是mapper级别的，当一个商品的信息发送更新，所有的商品信息缓存数据都会清空。 解决此类问题，需要在业务层根据需要对数据有针对性的缓存。 比如可以对经常变化的 数据操作单独放到另一个namespace的mapper中。 4. mybaties整合springSSH:struts2+spring+hibernate SSM:SpringMVC + Spring + MyBatis Spring 3.2 Mybaties 3.2.7 4.1 创建工程导包导入mybaties包 mybaties核心包 mybatis依赖包 导入mysql数据库驱动 数据库dbcp连接池 导入spring+mvc包 Mybatis-spring整合包 4.2 配置mybatis的核心配置文件核心配置文件、创建User模型、映射文件， 4.3 spring的数据源&lt;beans xmlns=*”http://www.springframework.org/schema/beans&quot;* xmlns:xsi=*”http://www.w3.org/2001/XMLSchema-instance&quot;* xmlns:mvc=*”http://www.springframework.org/schema/mvc&quot;* xmlns:context=*”http://www.springframework.org/schema/context&quot;* xmlns:aop=*”http://www.springframework.org/schema/aop&quot;* xmlns:tx=*”http://www.springframework.org/schema/tx&quot;* xsi:schemaLocation=*”http://www.springframework.org/schema/beans* http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd “&gt; &lt;bean id=*”datasourse”* class=*”org.apache.commons.dbcp.BasicDataSource”&gt; &lt;property name=“driverClassName”* value=*”xxx“/&gt; &lt;property name=“url”* value=*”xxx“/&gt; &lt;property name=“username”* value=*”xxx/&gt; &lt;property name=“password”* value=*”xxx*”/&gt; &lt;property name=*”maxActive”* value=*”10”/&gt; &lt;property name=“maxIdle”* value=*”5”*/&gt; 4.4 spring配置SqlSessionFactory 4.5 编写个UserDaoImpl,接口省略 4.6 spring中配置daobean 4.7测试 4.8 换成Mapper接口整合dao创建Mapper映射文件 UserMapper UserMapper.xml 核心配置文件加载映射文件 Spring配置MapperFactoryBean使用工厂Bean生成userMapper对象 测试 用**MapperScannerConfigurer批量扫描创建代理对象**【上面的代码麻烦，每一个mappler就创建一个工厂bean】 测试与上一个测试一样 5. 逆向工程简介简单点说**，就是通过数据库中的单表，自动生成java代码**。 Mybatis官方提供了逆向工程 可以针对单表自动生成mybatis代码（mapper.java\mapper.xml\po类） 企业开发中，逆向工程是个很常用的工具。 下载逆向工程https://github.com/mybatis/generator/releases/tag/mybatis-generator-1.3.2 使用方法1、 创建简单的java项目 2、 导入jar包,创建generator配置文件； 3、 使用java类来执行逆向工程； 4、 把生成的代码拷贝到项目中。 5、 在正式项目中使用逆向工程生成的代码 第一步**：创建generator配置文件**在classpath下，创建generator.xml配置文件：（文件内容可以从逆向工程的jar包中docs目录下的index.html中找到相关代码） &lt;context id=*”mysqlTable”* targetRuntime=*”MyBatis3”&gt; &lt;jdbcConnection driverClass=“com.mysql.jdbc.Driver”* connectionURL=*”jdbc:mysql://localhost:3306/mybatis”* userId=*”root”* password=*”123456”&gt; &lt;property name=“forceBigDecimals”* value=*”false”* /&gt; &lt;javaModelGenerator targetPackage=*”com.gyf.backoffice.domain”* targetProject=*”.\src”&gt; &lt;property name=“enableSubPackages”* value=*”true”* /&gt; &lt;property name=*”trimStrings”* value=*”true”* /&gt; &lt;sqlMapGenerator targetPackage=*”com.gyf.backoffice.mapper”* targetProject=*”.\src”&gt; &lt;property name=“enableSubPackages”* value=*”true”* /&gt; &lt;javaClientGenerator type=*”XMLMAPPER”* targetPackage=*”com.gyf.backoffice.mapper”* targetProject=*”.\src”&gt; &lt;property name=“enableSubPackages”* value=*”true”* /&gt; &lt;table tableName=*”items”/&gt; &lt;table tableName=“orderdetail”/&gt; &lt;table tableName=“orders”/&gt; &lt;table tableName=“user”*/&gt; 第二步：使用java类来执行逆向工程需要导入mysql的驱动包和mybatis的逆向工程包 public class Generator { public static void main(String[] args) throws Exception{ List warnings = new ArrayList(); boolean overwrite = true; File configFile = new File(“config/generator.xml”); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); }} 第三步：**把生成的代码拷贝到项目中**如果正式项目中已经有po类所在的包了，那么就只需要拷贝po类到指定包下就可以。 如果正式项目中没有po包，那么就把逆向工程中整个po类的包拷贝过去。 Mapper.xml和mapper.java的拷贝与po类一样。 第四步：测试逆向工程提供了很多查询方法，可以不用写sql,这个根hibernate有点类似]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis第1天]]></title>
    <url>%2F2019%2F08%2F26%2FMyBatis%E7%AC%AC1%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1 MyBatis简介1.1 MyBatisMyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，实质上Mybatis对ibatis进行一些改进。 MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 对jdbc的封装框架有哪些：Hibernate,dbutils,jdbcTemplate[spring]，mybatis 原理：Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 1.2 jdbc程序代码 存在的问题 v 数据库连接频繁开启和关闭，会严重影响数据库的性能。 v 代码中存在硬编码，分别是数据库部分的硬编码和SQL执行部分的硬编码。 1.3 MyBatis的框架核心1、 mybatis配置文件，包括M**ybatis全局配置文件和**Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息；映射文件配置了SQL执行相关的 信息。2、 mybatis通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory**，即会话工厂。3、 通过SqlSessionFactory，可以创建SqlSession即会话。Mybatis是通过SqlSession来操作数据库的。4、 SqlSession本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。5、 Executor执行器要处理的SQL信息是封装到一个底层对象MappedStatement中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括HashMap集合对象、POJO对象类型**。 2 Mybatis入门2.1 环境准备创建数据库表 下载MyBatismybaits的代码由github.com管理，下载地址：https://github.com/mybatis/mybatis-3/releases 创建项目导包导入下面的包 添加log4j.propertiesMybatis使用的日志包是log4j的，所以需要添加log4j.properties。 在classpath下创建log4j.properties如下：【文件内容可以从mybatis-3.2.7.pdf中拷贝】 # Global logging configuration log4j.rootLogger=DEBUG, stdout # Console output… log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 日志级别在开发阶段设置成DEBUG，在生产阶段设置成INFO或者ERROR。 2.2 开发步骤1、 创建PO（model）类，根据需求创建；2、 创建全局配置文件SqlMapConfig.xml；3、 编写映射文件；4、 加载映射文件，在SqlMapConfig.xml中进行加载；5、 编写测试程序，即编写Java代码，连接并操作数据库。 思路：a) 读取配置文件；b) 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。c) 通过SqlSessionFactory创建SqlSession。d) 调用SqlSession的操作数据库方法。e) 关闭SqlSession。 创建PO类 创建SqlMapConfig.xml在classpath(src)下，创建SqlMapConfig.xml文件【SqlMapConfig.xml（文件头可以从mybatis-3.2.7.pdf文档的2.1.2小节中拷贝）】 &lt;environments default=*”development”&gt; &lt;environment id=“development”&gt; &lt;transactionManager type=“JDBC”&gt; &lt;dataSource type=“POOLED”&gt; &lt;property name=“driver”* value=*”com.mysql.jdbc.Driver”/&gt; &lt;property name=“url”* value=*”jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8”/&gt; &lt;property name=“username”* value=*”root”/&gt; &lt;property name=“password”* value=*”123456”*/&gt; 映射文件在classpath下，创建sqlmap文件夹。在sqlmap目录下，创建User.xml映射文件。 【Mybatis的映射文件头（可以从mybatis-3.2.7.pdf文件中拷贝）】 SELECT * FROM USER WHERE id = #{id} 配置文件加载映射文件 测试类 2.3 更多案例讲解模糊查询用户信息 &lt;select id=*”findUserByName”* parameterType=*”String”* resultType=*”com.gyf.domain.User”*&gt; SELECT * FROM USER WHERE username like ‘%${value}%’ 插入用户信息 删除用户 更新用户 主键返回之MySQL自增主键思路： Ø MySQL自增主键，是指在insert之前MySQL会自动生成一个自增的主键。 Ø 我们可以通过MySQL的函数获取到刚插入的自增主键: LAST_INSERT_ID() Ø 这个函数是在insert语句之后去调用。 &lt;insert id=*”insertUser”* parameterType=*”com.gyf.domain.User”&gt; &lt;selectKey keyProperty=“id”* resultType=*”int”* order=*”AFTER”*&gt; SELECT LAST_INSERT_ID() INSERT INTO USER (username,sex,birthday,address) VALUES(#{username},#{sex},#{birthday},#{address}) 主键返回之MySQL自增**UUID**&lt;insert id=*”insertUser”* parameterType=*”com.gyf.domain.User”&gt; &lt;selectKey keyProperty=“id”* resultType=*”String“* order=*”BEFORE“*&gt; SELECT UUID() INSERT INTO USER (username,sex,birthday,address) VALUES(#{username},#{sex},#{birthday},#{address}) ORCLE主键SELECT user_seq.nextval() FROM dual 小结：parameterType和**resultTypeparameterType指定输入参数的java类型，可以填写别名或Java类的全限定名。resultType指定输出结果的java类型，可以填写别名或Java类的全限定名。 #{}和**${}#{}：相当于预处理中的占位符？。#{}里面的参数表示接收java输入参数的名称。#{}可以接受HashMap、POJO类型的参数。当接受简单类型的参数时，#{}里面可以是value，也可以是其他。#{}可以防止SQL注入。${}：相当于拼接SQL串，对传入的值不做任何解释的原样输出。${}会引起SQL注入，所以要谨慎使用。${}可以接受HashMap、POJO类型的参数。当接受简单类型的参数时，${}里面只能是value。 selectOne和selectListselectOne：只能查询0或1条记录，大于1条记录的话，会报错：selectList：可以查询0或N条记录 2.4 MyBatis的Dao编写 【一般不用，有更多好方式】dao 测试 2.5 MyBatis的Dao编写【mapper代理方式实现】Mapper代理的开发方式，程序员只需要编写mapper接口（相当于dao接口）即可。Mybatis会自动的为mapper接口生成动态代理实现类。 不过要实现mapper代理的开发方式，需要遵循一些开发规范。 开发规范 mapper接口的全限定名要和mapper映射文件的namespace的值相同。2. mapper接口的方法名称要和mapper映射文件中的statement的id相同；3. mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。4. mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致； 通过规范式的开发mapper接口，可以解决原始dao开发当中存在的问题：l 模板代码已经去掉；l 剩下去不掉的操作数据库的代码，其实就是一行代码。这行代码中硬编码的部分，通过第一和第二个规范就可以解决。 编写步骤第一步：【】重新写个UserMapper配置文件和定义mapper映射文件UserMapper.xml（内容同Users.xml，除了namespace的值），放到新创建的目录mapper下。 第二步：【添加映射配置文件】 第三步：测试 3 全局配置文件其它配置3.1 properties数据库文件配置在src下配置个db.properties文件 修改全局的配置文件 3.2 setting【了解】 具体配置详解 3.3 typeAliases别名是使用是为了在映射文件中，更方便的去指定参数和结果集的类型，不再用写很长的一段全限定名。 mybatis支持的别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal 自定义别名 mappers&lt;mapper resource=’’/&gt;使用相对于类路径的资源 如： 【不用】使用完全限定路径 如： 使用mapper接口的全限定名 如： 也可使用注解开发，把xml文件删除 注意：此种方法要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下； （推荐）注册指定包下的所有映射文件 如： 注意**：此种方法要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下**； 4 Mybatis的映射文件4.1 输入映射ParameterType指定输入参数的java类型，可以使用别名或者类的全限定名。它可以接收简单类型**,POJO对象**、HashMap。 传递简单类型根据用户ID查询用户信息。 传递POJO对象 传递POJO包装对象开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。 需求 综合查询用户信息，需要传入查询条件复杂，比如（用户信息、订单信息、商品信息）。 vo:键值对对象，相对于kv po:persist object 持久化对象 pojo:简单的java对象 entity:实体 定义POJO包装类 修改UserMapper.java 修改UsrMappler.xml 测试 传递Map对象 修改UserMapper.java 修改UserMapper.xml 测试 4.2 输出映射 resultType/resultMapresultType使用resultType进行结果映射时，查询的列名和映射的pojo属性名完全一致，该列才能映射成功。 如果查询的列名和映射的pojo属性名全部不一致，则不会创建pojo对象； 如果查询的列名和映射的pojo属性名有一个一致，就会创建pojo对象。 输出简单类型当输出结果只有一列时，可以使用ResultType指定简单类型作为输出结果类型。 案例：输出一个count(*) UserMapper.java UserMapper.xml 测试 输出POJO单个对象 输出POJO列表 总结： 输出单个pojo对象和pojo列表时，mapper映射文件中的resultType的类型是一样的，mapper接口的方法返回值不同。 同样的mapper映射文件，返回单个对象和对象列表时，mapper接口在生成动态代理的时候，会根据返回值的类型，决定调用selectOne方法还是selectList方法。 resultMap如果查询出来的列名和属性名不一致，通过定义一个resultMap将列名和pojo属性名之间作一个映射关系。 1、 定义resultMap 2、使用resultMap作为statement的输出映射类型 UserMapper.java UserMapper.xml 测试 5 动态SQL5.1 if和whereØ If标签：作为判断入参来使用的，如果符合条件，则把if标签体内的SQL拼接上。 注意**：用if进行判断是否为空时，不仅要判断null，也要判断空字符串‘’；** Ø Where标签：会去掉条件中的第一个and符号。 5.2 SQL片断Mybatis提供了SQL片段的功能，可以提高SQL的可重用性。 5.3 foreach 遍历案例：查询指定id的用户【SELECT * FROM user where id in (31,32,33); 】 UserQueryVO.java UserMapper.xml 测试： 另一种遍历，参数直接传入id集合【自己练】 6 mybatis与hibernate的区别【面试题】Mybatis技术特点：好处： 通过直接编写SQL语句，可以直接对SQL进行性能的优化； 学习门槛低，学习成本低。只要有SQL基础，就可以学习mybatis，而且很容易上手； 由于直接编写SQL语句，所以灵活多变，代码维护性更好。 缺点： 不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。 Mysql:limit Oracle:rownum 需要编写结果映射。 Hibernate技术特点：好处： 标准的orm框架，程序员不需要编写SQL语句。 具有良好的数据库无关性，即数据库发生变化的话，代码无需再次编写。 以后,mysql数据迁移到oracle，只需要改方言配置 缺点: 学习门槛高，需要对数据关系模型有良好的基础，而且在设置OR映射的时候，需要考虑好性能和对象模型的权衡。 程序员不能自主的去进行SQL性能优化。 Mybatis应用场景：需求多变的互联网项目，例如电商项目。 Hibernate.应用场景：需求明确、业务固定的项目，例如OA项目、ERP项目等。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring第3天]]></title>
    <url>%2F2019%2F08%2F26%2FSpring%E7%AC%AC3%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1 事务管理1.1 事务回顾事务简介一组业务ABCD操作，要么全部成功，要么全部不成功。 事务特性：ACIDØ 原子性：整体 【原子性是指事务包含的所有操作要么全部成功，要么全部失败】 Ø 一致性：数据 【一个事务执行之前和执行之后都必须处于一致性状态】 Ø 隔离性：并发 【对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。】 Ø 持久性：结果 【持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的】 隔离问题Ø 脏读：一个事务读到另一个事务未提交的内容【读取未提交内容】 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。 Ø 不可重复读：一个事务读到另一个事务已提交的内容（insert）【读取提交内容】 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。 Ø 虚读（幻读）：一个事务读到另一个事务已提交的内容（update） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。 Ø Serializable（可串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 隔离级别–解决问题Ø read uncommittd，读未提交。存在3个问题。 Ø read committed，读已提交。解决：脏读。存在2个问题。 Ø repeatable read ，可重复读。解决：脏读、不可重复读。存在1个问题。 Ø serializable，串行化。单事务。没有问题。 mysql 事务操作–简单ABCD 一个事务Connection conn = null;try{ //1 获得连接 conn = …; //2 开启事务 conn.setAutoCommit(false); A B C D //3 提交事务 conn.commit();} catche(){ //4 回滚事务 conn.rollback();} mysql 事务操作–Savepoint需求：AB（必须），CD（可选） Connection conn = null;Savepoint savepoint = null; //保存点，记录操作的当前位置，之后可以回滚到指定的位置。（可以回滚一部分）try{ //1 获得连接 conn = …; //2 开启事务 conn.setAutoCommit(false); A B savepoint = conn.setSavepoint(); C D //3 提交事务 conn.commit();} catche(){ if(savepoint != null){ //CD异常 // 回滚到CD之前 conn.rollback(savepoint); // 提交AB conn.commit(); } else{ //AB异常 // 回滚AB conn.rollback(); }} 1.2 Spring事务管理介绍1.2.1 Spring提供的事务jar包transaction = tx 1.2.2 Jar中的三个顶级接口 PlatformTransactionManager**：平台事务管理器，spring要管理事务，必须使用事务管理器,进行事务配置时，必须配置事务管理器** TransactionDefinition：事务详情（事务定义、事务属性），spring用于确定事务具体详情，例如：隔离级别、是否只读、超时时间 等进行事务配置时，必须配置详情。spring将配置项封装到该对象实例。 TransactionStatus：事务状态，spring用于记录当前事务运行状态。例如：是否有保存点，事务是否完成。spring底层根据状态进行相应操作。 1.2.3 PlatformTransactionManager 事务管理器先导入两个包 常用的两个事务管理器 1.2.4 TransactionStatus 事务状态 1.2.5 TransactionDefinition 传播行为：在两个业务之间如何共享事务 PROPAGATION_REQUIREDrequired , 必须 【默认值】 支持当前事务，A如果有事务，B将使用该事务。如果A没有事务，B将创建一个新的事务。 PROPAGATION_SUPPORTSsupports ，支持 支持当前事务，A如果有事务，B将使用该事务。如果A没有事务，B将以非事务执行。 PROPAGATION_MANDATORYmandatory ，强制 支持当前事务，A如果有事务，B将使用该事务。如果A没有事务，B将抛异常。 PROPAGATION_REQUIRES_NEW requires_new ，必须新的 如果A有事务，将A的事务挂起，B创建一个新的事务如果A没有事务，B创建一个新的事务 PROPAGATION_NOT_SUPPORTEDnot_supported ,不支持 如果A有事务，将A的事务挂起，B将以非事务执行如果A没有事务，B将以非事务执行 PROPAGATION_NEVERnever，从不 如果A有事务，B将抛异常如果A没有事务，B将以非事务执行 PROPAGATION_NESTEDnested ，嵌套 A和B底层采用保存点机制，形成嵌套事务。 掌握：PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED 1.3 案例：转帐​ 1.3.1 环境搭建创建数据库表create database spring_day3;use spring_day3;create table account( id int primary key auto_increment, username varchar(50), money int);insert into account(username,money) values(‘jack’,’10000’);insert into account(username,money) values(‘rose’,’10000’); 导入jar包l 核心：4+1 l aop ： 4 (aop联盟、spring aop、aspectj规范、spring aspect) l 数据库：2 （jdbc/tx） l 驱动：mysql l 连接池：c3p0 Dao层 Service层 Spring的配置配置c3p0数据源-&gt;dao -&gt; service 测试转帐 1.3.2 手动管理事务【了解】spring底层使用 TransactionTemplate 事务模板进行操作。 操作 1.service 需要获得 TransactionTemplate 2.spring 配置模板，并注入给service 3.模板需要注入事务管理器 4.配置事务管理器：DataSourceTransactionManager ，需要注入DataSource 了解底层即可，因为以后都是通过aop来配置事务 修改Service 修改spring的配置文件 1.3.3 工厂bean生成代理：半自动Spring提供 管理事务的代理工厂bean TransactionProxyFactoryBean 修改spring配置文件transactionAttributes:事务详情prop.key ：确定哪些方法使用当前事务配置 prop.text:用于配置事务详情 格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception 传播行为 隔离级别 是否只读 异常回滚 异常提交 测试： 1.3.4 基本AOP的事务配置【掌握】Spring的配置文件 测试同上1.3.5 基本于注解的事务spring配置 1.3.5 整合Junit目的：少写一些代码 导入一个spring-test包 2. SSH整合2.1 web 整合spring配置tomcat加载spring的配置文件 第一步：需要添加 第二步：在web.xml配置spring的监听 出现下面的错误是配置文件加载位置不对，在web.xml改成classpath目录下 第三步：创建Servlet获取Spring的应用上下文件ApplicationContext 2.2 web整合struts+hibernate+spring整合版本struts-2.3.33-all spring-framework-3.0.2.RELEASE hibernate-distribution-3.6.10.Final-dist 第一步：jar包整合Struts的jar包 Spring的jar包基础：4+1 ， beans、core、context、expression ， commons-logging (struts已经导入)AOP：aop联盟(aopalliance)、spring aop 、aspect规范（aspect.weaver）、spring aspectdb：jdbc、tx测试：testweb开发：spring web驱动：mysql连接池：c3p0整合hibernate：spring orm Hibernate的jar包 核心包 required包下的介绍 jpa用于注解开发@Entity @Id 整合log4j导入 log4j…jar (struts已经导入) 整合（过渡）：slf4j-log4j12-1.7.2.jar 二级缓存Commons-loggin.jar已经存在 整合包spring整合hibernate： spring orm struts 整合spring：struts2-spring-plugin-2.3.15.3.jar 删除重复jar包 第二步：spring整合hibernate的单元测试创建表create table t_user( id int primary key auto_increment, username varchar(50), password varchar(32), age int ); po类和映射文件 public class User { private Integer id; private String username; private String password; private Integer age; &lt;class name=*”com.gyf.borrowsys.domain.User”* table=*”t_user”&gt; &lt;id name=“id”&gt; &lt;generator class=“native”&gt; &lt;property name=“username”&gt; &lt;property name=“password”&gt; &lt;property name=“age”*&gt; dao Service hibernate.cfg.xml &lt;property name=*”hibernate.connection.driver_class”&gt;com.mysql.jdbc.Driver &lt;property name=“hibernate.connection.url”&gt;jdbc:mysql://localhost:3306/web_ssh &lt;property name=“hibernate.connection.username”&gt;root &lt;property name=“hibernate.connection.password”&gt;123456 &lt;property name=“show_sql”&gt;true &lt;property name=“format_sql”&gt;true &lt;property name=“hibernate.hbm2ddl.auto”&gt;update &lt;property name=“hibernate.dialect”&gt;org.hibernate.dialect.MySQL5Dialect &lt;mapping resource=“com/gyf/borrowsys/domain/User.hbm.xml”*/&gt; applicationContext.xml 单元测试 配置Hibrenate的事务 简化：去除hibernate.cfg.xml文件 org.hibernate.dialect.MySQL5Dialect true true update thread 第三步：spring整合struts编写action类，并将其配置给spring ，spring可以注入service 编写struts.xml 表单jsp页面 web.xml 配置1.确定配置文件contextConfigLocation 2.配置监听器 ContextLoaderListener 3.配置前端控制器 StrutsPrepareAndExecuteFitler contextConfigLocation classpath:applicationContext.xml org.springframework.web.context.ContextLoaderListener struts2 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter struts2 /* action和spring配置文件 action中service默认会根据名称注入**默认情况下框架使用的自动装配策略是name，也就是说框架会去 Spring中寻找与action属性名字相同的bean** actoin对象由spring创建]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring第2天]]></title>
    <url>%2F2019%2F08%2F26%2FSpring%E7%AC%AC2%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1、AOP1.1 AOP概述1) 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 2) AOP是OOP（面向对象编程）的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 3) 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 4) AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码 5) 经典应用：事务管理、性能监视、安全检查、缓存 、日志等**【画图】** 6) Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码 7) AspectJ是一个基于Java语言的AOP框架，Spring2.0开始，Spring AOP引入对Aspect的支持，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的织入 1.2 AOP实现原理a. aop底层将采用代理机制进行实现。 b. 接口 + 实现类 ：spring采用 jdk 的动态代理Proxy。 c. 实现类：spring 采用 cglib字节码增强。 1.3 AOP术语1.target：目标类，需要被代理的类。例如：UserService 2.Joinpoint(连接点):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法 3.PointCut 切入点：已经被增强的连接点。例如：addUser() 4.advice 通知/增强，增强代码。例如：after、before 5. Weaving(织入):是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程. 6.proxy 代理类 7. Aspect(切面): 是切入点pointcut和通知advice的结合 ​ 一个线是一个特殊的面。 ​ 一个切入点和一个通知，组成成一个特殊的面。 1.4 手动代理1.4.1 JDK动态代理目标类 切面类 工厂类 测试类 1.4.2 cglib 增强字节码n 没有接口，只有实现类。 n 采用字节码增强框架 cglib，在运行时 创建目标类的子类，从而对目标类进行增强。 n 导入jar包： 自己导包（了解）： ​ 核心：hibernate-distribution-3.6.10.Final\lib\bytecode\cglib\cglib-2.2.jar ​ 依赖：struts-2.3.15.3\apps\struts2-blank\WEB-INF\lib\asm-3.3.jar ​ spring-core..jar 已经整合以上两个内容 工厂类 测试结果 1.5 AOP联盟通知类型AOP联盟为通知Advice定义了org.aopalliance.aop.AdviceSpring按照通知Advice在目标类方法的连接点位置，可以分为5类 •前置通知 org.springframework.aop.MethodBeforeAdvice •在目标方法执行前实施增强 •后置通知 org.springframework.aop.AfterReturningAdvice •在目标方法执行后实施增强 •环绕通知 org.aopalliance.intercept.MethodInterceptor •在目标方法执行前后实施增强 •异常抛出通知 org.springframework.aop.ThrowsAdvice •在方法抛出异常后实施增强 •引介通知 org.springframework.aop.IntroductionInterceptor 在目标类中添加一些新的方法和属性 环绕通知，必须手动执行目标方法try{ //前置通知 //执行目标方法 //后置通知} catch(){ //抛出异常通知} 1.6 Spring编写代理半自动目标：掌握让spring 创建代理对象，从spring容器中手动的获取代理对象。 第一步：导Jar包【核心4+1 、AOP联盟（规范）、spring-aop （实现）】 第二步：目标类 第三步：切面类 第四步：spring配置 第五步：测试 1.7 Spring AOP全自动编程目录：明白什么是全自动织入 第一步：**导入jar包**spring-framework-3.0.2.RELEASE-dependencies\org.aspectj\com.springsource.org.aspectj.weaver\1.6.8.RELEASE 第二步：Spring 的AOP配置 第三步：测试 2、**AspectJ**2.1 AspectJ简介v AspectJ是一个基于Java语言的AOP框架 v Spring2.0以后新增了对AspectJ切点表达式支持 v @AspectJ 是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面 v 新版本Spring框架，建议使用AspectJ方式来开发AOP v 主要用途：自定义开发 2.2 切入点表达式【掌握】execution()用于描述方法 【掌握】 语法：execution(修饰符 返回值 包.类.方法名(参数) throws异常) 修饰符，一般省略 ​ public 公共方法 ​ * 任意 返回值，不能省略 ​ void 返回没有值 ​ String 返回值字符串 ​ * 任意 包，[省略] ​ com.gyf.crm 固定包 ​ com.gyf.crm.*.service crm包下面子包任意 （例如：com.gyf.crm.staff.service） ​ com.gyf.crm.. crm包下面的所有子包（含自己） ​ com.gyf.crm.*.service.. crm包下面任意子包，固定目录service，service目录任意包 类，[省略] ​ UserServiceImpl 指定类 ​ *Impl 以Impl结尾 ​ User* 以User开头 ​ * 任意 方法名，不能省略 ​ addUser 固定方法 ​ add* 以add开头 ​ *Do 以Do结尾 ​ * 任意 (参数) ​ () 无参 ​ (int) 一个整型 ​ (int ,int) 两个 ​ (..) 参数任意 throws ,可省略，一般不写。 案例1： execution(com.gyf.crm..service...(..)) 案例2：或 &lt;aop:pointcut expression=”execution(* com.gyf.crm.service.*.*(..)) || ​ execution(* com.gyf.*Do.*(..))” id=”myPointCut”/&gt; within:匹配包或子包中的方法(了解) within(com.gyf.aop..*) this:匹配实现接口的代理对象中的方法(了解) this(com.gyf.aop.user.UserDAO) target:匹配实现接口的目标对象中的方法(了解) target(com.gyf.aop.user.UserDAO) args:匹配参数格式符合标准的方法(了解) args(int,int) bean(id)对指定的bean所有的方法(了解) bean(‘userServiceId’) 2.3 AspectJ 通知类型aop联盟定义通知类型，具有特性接口，必须实现，从而确定方法名称。aspectj 通知类型，只定义类型名称，以及方法格式。个数：6种，知道5种，掌握1中。 before:前置通知(应用：各种校验) 在方法执行前执行，如果通知抛出异常，阻止方法运行 afterReturning:后置通知(应用：常规数据处理) 方法正常返回后执行，如果方法中抛出异常，通知无法执行 必须在方法执行后才执行，所以可以获得方法的返回值。 around:环绕通知(应用：十分强大，可以做任何事情) 方法执行前后分别执行，可以阻止方法的执行 必须手动执行目标方法 afterThrowing:抛出异常通知(应用：包装异常信息) 方法抛出异常后执行，如果方法没有抛出异常，无法执行 after:最终通知(应用：清理现场) 方法执行完毕后执行，无论方法中是否出现异常 查看源码 2.4 Aspect案例讲解【其于xml】第一步：导包 AOP联盟规范 AOP实现 规范 aspectj实现 第二步：实现类和切面类 第三步：spring的xml配置 第四步：测试 2.5 Aspect案例讲解【其于xml】第1步：声明使用注解 第2步：替换service和 切面 bean 第3步：声明切面 第4步：声明前置通知 第5步：声明公共切入点 第6步：声明后置通知 第7步：声明环绕通知 第8步：声明异常通知 第9步：声明最终通知 注解总结@Aspect 声明切面，修饰切面类，从而获得 通知。 通知 ​ @Before 前置 ​ @AfterReturning 后置 ​ @Around 环绕 ​ @AfterThrowing 抛出异常 ​ @After 最终 切入点 ​ @PointCut ，修饰方法 private void xxx(){} 之后通过“方法名”获得切入点引用 3 JdbcTemplate3.1 简介Ø jdbcTemplate类似人DBUtils,用于操作Jdbc的工具类，它需要依赖于连接池DataSource(数据源) Ø JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API Ø ODBC（Open Database Connectivity，ODBC）开放数据库连接,是微软公司开提供了一组对数据库访问的标准API（应用程序编程接口） Ø DBCP（DataBase Connection Pool）数据库连接池，是java数据库连接池的一种，由Apache开发 Ø C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。 c3p0与dbcp区别 dbcp没有自动回收空闲连接的功能 c3p0有自动回收空闲连接功能 3.2 环境搭建创建数据库和表create database spring_day02;use spring_day02;create table t_user( id int primary key auto_increment, username varchar(50), password varchar(32)); insert into t_user(username,password) values(‘jack’,’520’);insert into t_user(username,password) values(‘rose’,’521’); 创建工程导入Jar包 创建JavaBean,数据模型 3.3 API使用【了解】 3.4 配置DBCP beans.xml 测试 3.5 配置c3p0 3.6 使用JdbcDaoSupportdao层 Beans.xml 源码分析通过数据源创建模板 3.7 配置properties目数据库的连接信息配置到一个独立的文件中 在src写个db.properties文件 beans.xml]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring第1天]]></title>
    <url>%2F2019%2F08%2F26%2FSpring%E7%AC%AC1%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1 Spring介绍1.1 Spring概述Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 1.2 Spring好处方便解耦，简化开发: Ø Spring就是一个大工厂，专门负责生成Bean，可以将所有对象创建和依赖关系维护由Spring管理 AOP**编程的支持:** Ø Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 Ø 声明式事务的支持: 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序的测试: Ø Spring对Junit4支持，可以通过注解方便的测试Spring程序 方便集成各种优秀框架: Ø Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的支持 降低JavaEE API的使用难度 Spring: Ø 对JavaEE开发中一些难用的API（JDBC、JavaMail、远程调webservice用等），都提供了封装，使这些API应用难度大大降低 1.3 Spring体系结构Spring 框架是一个分层架构,,它包含一系列的功能要素并被分为大约20个模块。这些模块分为Core Container、Data Access/Integration、Web、AOP（Aspect Oriented Programming)、Instrumentation和测试部分,如下图所示： 1.4 在项目中的架构web层：Struts,SpringMVC dao层：Hibernate,mybatis 2 Spring 快速入门目标：掌握web中集成Spring需要哪些包 掌握IOC是什么 2.1 编写流程l 下载Spring 开发包 l 导入Spring的jar包 l 配置Spring的核心xml文件 l 在程序中读取Spring的配置文件来获取Bean【Bean其实就是一个new好的对象】 2.2 下载官网v Spring现在有很多框架，如Spring SpringMVC,Spring-Data,Sprint-Boot 2.3 Spring的核心jar包 spring-core-3.2.2.RELEASE.jar包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类,是其它组件的基本核心。 spring-beans-3.2.2.RELEASE.jar所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control(IoC) / Dependency Injection(DI)操作相关的所有类 spring-context-3.2.2.RELEASE.jarSpring提供在基础IoC功能上的扩展服务，此外还提供许多企业级服务的支持,如邮件服务、任务调度、JNDI定位、EJB集成、远程访问、缓存以及各种视图层框架的封装等。 spring-expression-3.2.2.RELEASE.jarSpring表达式语言 com.springsource.org.apache.commons.logging-1.1.1.jar第三方的主要用于处理日志 2.4 Spring的入门案例第一步：² 下载Spring的包 spring-framework-3.2.0.RELEASE-dist.zip 【Spring的核心包】spring-framework-3.0.2.RELEASE-dependencies.zip 【Spring的依赖包】 第二步：² 创建Web项目，导Spring的jar包 n 导入4核心(beans、core、context,expression) + 1个依赖(common-logging.jar) n 注意导入时，不要导入带sources的源文件了 第三步：² 写个简单的Service 并在main方法中调用 第四步：² Spring IoC控制反转创建实例 1&gt; 写了个配置文件beans.xml，配置文件的约束可以访问 spring-framework-3.2.0.RC2-docs/reference/html/xsd-config.html网页查看 2&gt; 离线配置文件约束提示的配置 xsd可以在schema目录中找 3&gt; Beans.xml文件配置 第五步：² 从beans.xml获取bean 总结：【IoC】1) IoC Inverse of Control 反转控制的概念，就是将原本在程序中手动创建UserService对象的控制权，交由Spring框架管理，简单说，就是创建**User**Service对象控制权被反转到了Spring框架 2.5 DI解释² Dependency Injection 依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件。 例子：在UserService中提供一个get/set的name方法，在beans.xml中通过property去注入 3、**加载Spring容器的三种方式**3.1 类路径获得配置文件ApplicationContext context = new ClassPathXmlApplicationContext(“com/gyf/spring/demo01/beans.xml”); 3.2 文件系统路径获得配置文件 3.3使用BeanFactory(了解) 3.4BeanFactory和ApplicationContext对比Ø BeanFactory 采取延迟加载，第一次getBean时才会初始化Bean Ø ApplicationContext是对BeanFactory扩展，提供了更多功能 l 国际化处理 l 事件传递 l Bean自动装配 l 各种不同应用层的Context实现 4、**装配Bean(xml)**4.1 实例化Bean的三种方式4.1.1 使用构造方法实例化4.1.2 使用静态工厂方法实例化 Bean.xml ** ** &lt;bean id**=”userService1”* class**=”com.gyf.service.UserServiceImpl”&gt;&lt;/bean**&gt; *&lt;!– 第二种方式：通过静态工厂方法 spring的版本过低，3.0版本,把jdk改成1.7 –&gt; &lt;bean id**=”userService2”* class**=”com.gyf.service.UserSereviceFactory1”** factory-method**=”createUserService”&gt;&lt;/bean**&gt; * ** &lt;bean id**=”factory2”** class**=”com.gyf.service.UserSereviceFactory2”&gt;&lt;/bean&gt; &lt;bean** id**=”userService3”** factory-bean**=”factory2”** factory-method**=”createUserService”&gt;&lt;/bean**&gt; test @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(“beans3.xml”); //new 对象 //IUserService userService1 = (IUserService) context.getBean(“userService1”); //userService1.add(); //静态工厂 //IUserService userService2 = UserSereviceFactory1.createUserService(); //IUserService userService2 = (IUserService) context.getBean(“userService2”); //userService2.add(); //实例工厂 //1.创建工厂 // UserSereviceFactory2 factory2 = new UserSereviceFactory2(); //IUserService userService3 = factory2.createUserService(); IUserService userService3 = (IUserService) context.getBean(“userService3”); userService3.add(); } 4.1.3 使用实例工厂方法实例化4.2 bean的作用域掌握红色两个常用的即可 类别 说明 singleton 在Spring IoC容器中仅存在一个Bean实例，Bean以单例方式存在，默认值 prototype 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时 ，相当于执行new XxxBean() request 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HTTP Session 共享一个Bean，不同Session使用不同Bean，仅适用于WebApplicationContext 环境 globalSession 一般用于Portlet应用环境，该作用域仅适用于WebApplicationContext 环境 案例： 5、bean的生命周期【了解】生命周期图 生命周期图解释1.instantiate bean对象实例化 2.populate properties 封装属性 3.如果Bean实现BeanNameAware 执行 setBeanName 4.如果Bean实现BeanFactoryAware 执行setBeanFactory ，获取Spring容器 5.如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization 6.如果Bean实现InitializingBean 执行 afterPropertiesSet 7.调用 指定初始化方法 init 8.如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization 执行业务处理 9.如果Bean实现 DisposableBean 执行 destroy 101.调用 指定销毁方法 customerDestroy 演示 6、**依赖注入Bean属性(xml)**6.1**手动装配，使用xml配置**构造方法注入 属性setter方法注入setter方法有两种注入，一般使用第一种直观 &lt;bean id=*”user”* class=*”com.gyf.spring.demo04.User”&gt; &lt;property name=“username”* value=*”zhangsan”&gt; &lt;property name=“password”* value=*”123456”*&gt; p命名空间注入【了解】 6.2 SpEL表达式【了解】Spring 表达式 Ø 对进行统一编程，所有的内容都使用value Ø #{123}、#{‘jack’} ： 数字、字符串 #{beanId} ：另一个bean引用 #{beanId.propName} ：操作数据 #{beanId.toString()} ：执行方法 #{T(类).字段|方法} ：静态方法或字段 ​ 6.3 集合注入集合的注入都是给添加子标签 ​ 数组： ​ List： ​ Set： ​ Map： ，map存放k/v 键值对，使用描述 ​ Properties： 【】 ​ 普通数据： 引用数据： List Set Map Properties 数组 6.4 注解注入Ø 注解：就是一个类，使用@注解名称 Ø 开发中：使用注解 取代 xml配置文件。 6.4.1 @Component@component取代 6.4.2 @Component(“id”)取代 6.4.4 web开发，提供3个@Component注解衍生注解（功能一样）取代@Repository(“名称”)：dao层 @Service(“名称”)：service层 @Controller(“名称”)：web层 @Autowired：自动根据类型注入 @Qualifier(“名称”):指定自动注入的id名称 @Resource(“名称”) @ PostConstruct 自定义初始化 @ PreDestroy 自定义销毁 6.4.5 使用案例第一个案例 第二个案例 第三个案例 第四个案例 第五个案例 第六个案例]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三十、Spring Boot生产部署-注意事项和如何使用脚本详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%B8%89%E5%8D%81%E3%80%81Spring-Boot%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十九、Spring Boot集成Swagger详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81Spring-Boot%E9%9B%86%E6%88%90Swagger%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十八、Spring Boot整合Druid详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81Spring-Boot%E6%95%B4%E5%90%88Druid%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十七、Spring Boot整合MyBatis详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81Spring-Boot%E6%95%B4%E5%90%88MyBatis%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十六、Spring Boot生产准备-基于HTTP的监控]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81Spring-Boot%E7%94%9F%E4%BA%A7%E5%87%86%E5%A4%87-%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十五、Spring Boot如何进行远程调试详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81Spring-Boot%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十四、Spirng Boot使用Spring Session实现集群-redis详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81Spirng-Boot%E4%BD%BF%E7%94%A8Spring-Session%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4-redis%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十三、Spring Boot发送邮件-使用模板邮件并实现多账号轮询发送]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81Spring-Boot%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E9%82%AE%E4%BB%B6%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E8%BD%AE%E8%AF%A2%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十二、Spring Boot调用REST服务-如何使用代理详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81Spring-Boot%E8%B0%83%E7%94%A8REST%E6%9C%8D%E5%8A%A1-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十一、Spring Boot使用异步消息服务-AMQP(RabbitMQ)详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81Spring-Boot%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1-AMQP-RabbitMQ-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十、Spring Boot使用异步消息服务JMS(ActiveMQ)]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%8C%E5%8D%81%E3%80%81Spring-Boot%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1JMS-ActiveMQ%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十九、Spring Boot之使用Caching-Redis详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E4%B9%9D%E3%80%81Spring-Boot%E4%B9%8B%E4%BD%BF%E7%94%A8Caching-Redis%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十八、Spring Boot之使用Caching-EhCache详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E5%85%AB%E3%80%81Spring-Boot%E4%B9%8B%E4%BD%BF%E7%94%A8Caching-EhCache%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十七、Spring Boot整合NoSQL数据库-mongodb详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E4%B8%83%E3%80%81Spring-Boot%E6%95%B4%E5%90%88NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十六、Spring Boot整合NoSQL数据库-redis详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E5%85%AD%E3%80%81Spring-Boot%E6%95%B4%E5%90%88NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93-redis%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十五、Spring Boot之h2嵌入式数据库的使用详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E4%BA%94%E3%80%81Spring-Boot%E4%B9%8Bh2%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring-Boot之h2嵌入式数据库的使用详解什么是h2嵌入式数据库？ H2是一个Java编写的关系型数据库，它可以被嵌入Java应用程序中使用，或者作为一个单独的数据库服务器运行。 H2数据库的前身是 HypersonicSQL，它的名字的含义是 Hypersonic2，但是它的代码是从头开始编写的，没有使用HypersonicSQL或者HSQLDB的代码。 Spring Boot使用 SQL 关系型数据库-h2 嵌入式数据库的步骤 1、添加依赖 123456一、添加依赖&lt;dependency&gt;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 2、在application.properties配置如下代码 12345#h2#spring.datasource.url=jdbc:h2:~/test;AUTO_SERVER=TRUE;DB_CLOSE_ON_EXIT=FALSEspring.datasource.url=jdbc:h2:file:D:/roncoo_h2/roncoo_spring_boot;AUTO_SERVER=TRUE;DB_CLOSE_ON_EXIT=FALSEspring.datasource.username=saspring.datasource.password= 注： 1.”~”这个符号代表的就是当前登录到操作系统的用户对应的用户目录 2.账号密码我们指定之后，就会自动创建 指定路径： spring.datasource.url=jdbc:h2:file:D:/roncoo_h2/roncoo_spring_ boot;AUTO_SERVER=TRUE;DB_CLOSE_ON_EXIT=FALSE 内存模式： spring.datasource.url=jdbc:h2:mem:test 三、进入控制台 路径：http://localhost:8080/h2-console]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十四、Spring Boot之事务处理详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E5%9B%9B%E3%80%81Spring-Boot%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[使用 SQL 数据库-事务处理一、事务有四个特性：ACID原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 二、传播行为 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中行，也可能开启一个新事务，并在自己的事务中运行。 Spring 定义了七种传播行为：PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务，Spring 默认使用 PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行 PROPAGATION_MANDATORY 表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常 PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用 JTATransactionManager 的话，则需访问 TransactionManager PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用 JTATransactionManager 的话，则需要访问 TransactionManagerPROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常 PROPAGATION_NESTED 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED 一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务 三、隔离级别 隔离级别定义了一个事务可能受其他并发事务影响的程度。 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别，Spring 默认使用，mysql 默认的隔离级别为：Repeatable Read(可重复读) ISOLATION_READ_UNCOMMITTED 读未提交，最低的隔离级别，允许读取尚未提交的数据变更，可能会导脏读、幻读或不可重复读 ISOLATION_READ_COMMITTED 读已提交，允许读取并发事务已经提交的数据，可以阻止脏读，但是幻Spring Boot 基础教程作者：冯永伟或不可重复读仍有可能发生 ISOLATION_REPEATABLE_READ 可重复读，对同一字段的多次读取结果都是一致的，除非数据是被本身务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生 ISOLATION_SERIALIZABLE 可串行化，最高的隔离级别，完全服从 ACID 的隔离级别，确保阻止脏读、不重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的 脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写再稍后被回滚了，那么第一个事务获取的数据就是无效的。 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。 幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存的记录。 四、属性说明 @Transactional a、isolation：用于指定事务的隔离级别。默认为底层事务的隔离级别。 b、noRollbackFor：指定遇到指定异常时强制不回滚事务。 c、noRollbackForClassName：指定遇到指定多个异常时强制不回滚事务。该属性可以指定多个异常类名。 d、propagation:指定事务的传播属性。 e、readOnly：指定事务是否只读。表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。若真的是一个只读取的数据库应设置 readOnly=true f、rollbackFor：指定遇到指定异常时强制回滚事务。 g、rollbackForClassName：指定遇到指定多个异常时强制回滚事务。该属性可以指定多个异常类名。 h、timeout：指定事务的超时时长。 使用Spring Boot处理事务的步骤1、创建RoncooUser实体类 123456789101112131415package com.roncoo.education.bean;import java.util.Date;/** * 实体类 * * @author wujing */public class RoncooUser &#123; private int id; private String name; private Date createTime; //省略getter、setter和toString方法&#125; 2.创建RoncooUserDao接口类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.roncoo.education.dao;import com.roncoo.education.bean.RoncooUser;/** * @author wujing */public interface RoncooUserDao &#123; /** * 插入 * * @param roncooUser * @return */ int insert(RoncooUser roncooUser); /** * 删除 * * @param id * @return */ int deleteById(int id); /** * 更新 * * @param roncooUser * @return */ int updateById(RoncooUser roncooUser); /** * 查找 * * @param id * @return */ RoncooUser selectById(int id);&#125; 3.创建UserService类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.roncoo.education.service;import java.util.Date;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.roncoo.education.bean.RoncooUser;import com.roncoo.education.bean.RoncooUserLog;import com.roncoo.education.dao.RoncooUserDao;import com.roncoo.education.dao.RoncooUserLogDao;@Servicepublic class UserService &#123; @Autowired private RoncooUserDao roncooUserDao; @Autowired private RoncooUserLogDao roncooUserLogDao; /** * 用户注册 * * @return */ @Transactional public String register(String name, String ip) &#123; // 1.添加用户 RoncooUser roncooUser = new RoncooUser(); roncooUser.setName(name); roncooUser.setCreateTime(new Date()); roncooUserDao.insert(roncooUser); // 测试使用 boolean flag = true; if (flag) &#123; throw new RuntimeException(); &#125; // 2.添加注册日志 RoncooUserLog roncooUserLog = new RoncooUserLog(); roncooUserLog.setUserName(name); roncooUserLog.setUserIp(ip); roncooUserLog.setCreateTime(new Date()); roncooUserLogDao.save(roncooUserLog); return "success"; &#125;&#125; 4.测试 123456789101112131415161718192021222324package com.roncoo.education;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import com.roncoo.education.service.UserService;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootDemo151ApplicationTests &#123; @Autowired private UserService userService; @Test public void register() &#123; String result = userService.register("无境ff", "192.168.1.1"); System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十三、Spring Boot整合Spring-data-jpa详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E4%B8%89%E3%80%81Spring-Boot%E6%95%B4%E5%90%88Spring-data-jpa%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot Jpa 介绍首先了解 Jpa 是什么？Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。它为 Java 开发人员提供了一种对象/关联映射工具来管理 Java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。 值得注意的是，Jpa是在充分吸收了现有 Hibernate，TopLink，JDO 等 ORM 框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，Jpa 受到了极大的支持和赞扬，其中就包括了 Spring 与 EJB3. 0的开发团队。 注意:Jpa 是一套规范，不是一套产品，那么像 Hibernate,TopLink,JDO 他们是一套产品，如果说这些产品实现了这个 Jpa 规范，那么我们就可以叫他们为 Jpa 的实现产品。 Spring Boot JpaSpring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data Jpa 可以极大提高开发效率！ Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现 基本查询基本查询也分为两种，一种是 Spring Data 默认已经实现，一种是根据查询的方法来自动解析成 SQL。 预先生成方法Spring Boot Jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等 1 继承 JpaRepository 12public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125;//集成JpaRepository，泛型里面第一个是User类，第二个Long是int类型的值 2 使用默认方法 123456789@Testpublic void testBaseQuery() throws Exception &#123; User user=new User(); userRepository.findAll(); userRepository.findOne(1l); userRepository.save(user); userRepository.delete(user); userRepository.count(); userRepository.exists(1l); // ...&#125; 就不解释了根据方法名就看出意思来 自定义简单查询自定义的简单查询就是根据方法名来自动生成 SQL，主要的语法是 findXXBy, readAXXBy, queryXXBy, countXXBy, getXXBy后面跟属性名称： 1User findByUserName(String userName); 也使用一些加一些关键字 And、 Or 1User findByUserNameOrEmail(String username, String email); 修改、删除、统计也是类似语法 1Long deleteById(Long id);Long countByUserName(String userName); 基本上 SQL 体系中的关键词都可以使用，例如： LIKE、 IgnoreCase、 OrderBy。 1List&lt;User&gt; findByEmailLike(String email);User findByUserNameIgnoreCase(String userName);List&lt;User&gt; findByUserNameOrderByEmailDesc(String email); 具体的关键字，使用方法和生产成SQL如下表所示 Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstnameIs,findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age ⇐ ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection age) … where x.age not in ?1 TRUE findByActiveTrue() … where x.active = true FALSE findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 复杂查询在实际的开发中我们需要用到分页、删选、连表等查询的时候就需要特殊的方法或者自定义 SQL 分页查询分页查询在实际使用中非常普遍了，Spring Boot Jpa 已经帮我们实现了分页的功能，在查询的方法中，需要传入参数 Pageable ,当查询中有多个参数的时候 Pageable建议做为最后一个参数传入. 1Page&lt;User&gt; findALL(Pageable pageable);Page&lt;User&gt; findByUserName(String userName,Pageable pageable); Pageable 是 Spring 封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则 123456@Testpublic void testPageQuery() throws Exception &#123; int page=1,size=10; Sort sort = new Sort(Direction.DESC, "id"); Pageable pageable = new PageRequest(page, size, sort); userRepository.findALL(pageable); userRepository.findByUserName("testName", pageable);&#125; 限制查询 有时候我们只需要查询前N个元素，或者支取前一个实体。 12345User findFirstByOrderByLastnameAsc();User findTopByOrderByAgeDesc();Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable); 自定义SQL查询其实 Spring Data 觉大部分的 SQL 都可以根据方法名定义的方式来实现，但是由于某些原因我们想使用自定义的 SQL 来查询，Spring Data 也是完美支持的；在 SQL 的查询方法上面使用 @Query注解，如涉及到删除和修改在需要加上 @Modifying.也可以根据需要添加 @Transactional对事物的支持，查询超时的设置等。 123456789@Modifying@Query("update User u set u.userName = ?1 where u.id = ?2")int modifyByIdAndUserId(String userName, Long id);@Transactional@Modifying@Query("delete from User where id = ?1")void deleteByUserId(Long id);@Transactional(timeout = 10)@Query("select u from User u where u.emailAddress = ?1")User findByEmailAddress(String emailAddress); 多表查询多表查询 Spring Boot Jpa 中有两种实现方式，第一种是利用 Hibernate 的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。 首先需要定义一个结果集的接口类。 12345678public interface HotelSummary &#123; City getCity(); String getName(); Double getAverageRating(); default Integer getAverageRatingRounded() &#123; return getAverageRating() == null ? null : (int) Math.round(getAverageRating()); &#125;&#125; 查询的方法返回类型设置为新创建的接口 12@Query("select h.city as city, h.name as name, avg(r.rating) as averageRating " - "from Hotel h left outer join h.reviews r where h.city = ?1 group by h")Page&lt;HotelSummary&gt; findByCity(City city, Pageable pageable);@Query("select h.name as name, avg(r.rating) as averageRating " - "from Hotel h left outer join h.reviews r group by h")Page&lt;HotelSummary&gt; findByCity(Pageable pageable); 使用 1234Page&lt;HotelSummary&gt; hotels = this.hotelRepository.findByCity(new PageRequest(0, 10, Direction.ASC, "name"));for(HotelSummary summay:hotels)&#123; System.out.println("Name" +summay.getName()); &#125; 在运行中 Spring 会给接口（HotelSummary）自动生产一个代理类来接收返回的结果，代码汇总使用 getXX的形式来获取 多数据源的支持同源数据库的多源支持日常项目中因为使用的分布式开发模式，不同的服务有不同的数据源，常常需要在一个项目中使用多个数据源，因此需要配置 Spring Boot Jpa 对多数据源的使用，一般分一下为三步： 1 配置多数据源 2 不同源的实体类放入不同包路径 3 声明不同的包路径下使用不同的数据源、事务支持 异构数据库多源支持比如我们的项目中，即需要对 mysql 的支持，也需要对 Mongodb 的查询等。 实体类声明 @Entity 关系型数据库支持类型、声明 @Document 为 Mongodb 支持类型，不同的数据源使用不同的实体就可以了1234interface PersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;@Entitypublic class Person &#123; …&#125;interface UserRepository extends Repository&lt;User, Long&gt; &#123; …&#125;@Documentpublic class User &#123; …&#125; 但是，如果 User 用户既使用 Mysql 也使用 Mongodb 呢，也可以做混合使用 123interface JpaPersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;@Entity@Documentpublic class Person &#123; …&#125; 也可以通过对不同的包路径进行声明，比如 A 包路径下使用 mysql,B包路径下使用 MongoDB 1@EnableJpaRepositories(basePackages = "com.neo.repositories.jpa")@EnableMongoRepositories(basePackages = "com.neo.repositories.mongo")interface Configuration &#123; &#125; 其它使用枚举 使用枚举的时候，我们希望数据库中存储的是枚举对应的 String 类型，而不是枚举的索引值，需要在属性上面添加 @Enumerated(EnumType.STRING) 注解 1@Enumerated(EnumType.STRING) @Column(nullable = true)private UserType type; 不需要和数据库映射的属性 正常情况下我们在实体类上加入注解 @Entity，就会让实体类和表相关连如果其中某个属性我们不需要和数据库来关联只是在展示的时候做计算，只需要加上 @Transient属性既可。 1@Transientprivate String userName; 使用Spring Boot Jpa的步骤1、配置数据源：在application.properties或者application.yaml配置文件中配置数据库连接配置，如下代码 123456789#数据库连接配置spring.datasource.url=jdbc:mysql://localhost:3307/spring_boot_demo?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driver# JPAspring.jpa.hibernate.ddl-auto= updatespring.jpa.show-sql=true spring.jpa.hibernate.ddl-auto= update：修改代码后，sql语句自动更新 2.配置pom文件：在pom文件中添加如下依赖： 12345678910&lt;!-- 数据库 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 3.创建数据库：创建一个spring_boot_demo的数据库 4.在bean包里面创建一个RoncooUserLog的实体类12345678910111213141516171819202122232425262728package com.roncoo.education.bean;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class RoncooUserLog &#123; @Id @GeneratedValue private Integer id; @Column private Date createTime; @Column private String userName; @Column private String userIp; //省略getter、setter、toString方法&#125; @Entity：实体类声明 @Entity 关系型数据库支持类型 @Id ：标识这个属性是主键 @GeneratedValue(strategy = GenerationType.IDENTITY)自增长策略 @Column(nullable = false, length = 20) // 映射为字段，值不能为空 //设置那些字段不能为空 5.创建RoncooUserLogDao的接口RoncooUserLogDao继承JPA中的CrudRepository接口，接口的泛型是&lt;RoncooUserLog,Integer&gt;，既然它继承的接口里面已经提供了方法，那个之前在接口中提供的方法就可以删除掉了 1234567891011121314151617181920212223242526272829303132333435package com.roncoo.education.dao;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import com.roncoo.education.bean.RoncooUserLog;public interface RoncooUserLogDao extends JpaRepository&lt;RoncooUserLog, Integer&gt; &#123; /** * @param * @return * 如果JPA中没有满足的需求，我们就会用到@Query()注解,括号里面可以写sql语句 */ @Query(value = "select u from RoncooUserLog u where u.userName=?1") List&lt;RoncooUserLog&gt; findByUserName(String userName); /** * @param string * @param string2 * @return */ List&lt;RoncooUserLog&gt; findByUserNameAndUserIp(String string, String string2); /** * @param * @param pageable * @return */ Page&lt;RoncooUserLog&gt; findByUserName(String userName, Pageable pageable);&#125; 6.创建测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.roncoo.education;import java.util.Date;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.test.context.junit4.SpringRunner;import com.roncoo.education.bean.RoncooUserLog;import com.roncoo.education.dao.RoncooUserLogDao;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootDemo141ApplicationTests &#123; @Autowired private RoncooUserLogDao roncooUserLogDao; @Test public void insert() &#123; RoncooUserLog entity = new RoncooUserLog(); entity.setUserName("无境"); entity.setUserIp("192.168.0.1"); entity.setCreateTime(new Date()); roncooUserLogDao.save(entity); &#125; @Test public void delete() &#123; roncooUserLogDao.delete(1); &#125; @Test public void update() &#123; RoncooUserLog entity = new RoncooUserLog(); entity.setId(2); entity.setUserName("无境2"); entity.setUserIp("192.168.0.1"); entity.setCreateTime(new Date()); roncooUserLogDao.save(entity); &#125; @Test public void select() &#123; RoncooUserLog result = roncooUserLogDao.findOne(1); System.out.println(result); &#125; @Test public void select2() &#123; List&lt;RoncooUserLog&gt; result = roncooUserLogDao.findByUserName("无境"); System.out.println(result); &#125; @Test public void select3() &#123; List&lt;RoncooUserLog&gt; result = roncooUserLogDao.findByUserNameAndUserIp("无境", "192.168.0.1"); System.out.println(result); &#125; // 分页 @Test public void queryForPage() &#123; //Pageable：分页类,分页类的参数类型 0 代表当前第几页，20代表当前页有第几条 ， new Sort是排序，排序是按组件倒序来排 Pageable pageable = new PageRequest(0, 20, new Sort(new Order(Direction.DESC, "id"))); Page&lt;RoncooUserLog&gt; result = roncooUserLogDao.findByUserName("无境", pageable); System.out.println(result.getContent()); &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十二、Spring Boot整合JdbcTemplate详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E4%BA%8C%E3%80%81Spring-Boot%E6%95%B4%E5%90%88JdbcTemplate%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[使用 SQL 关系型数据库-JdbcTemplate 一、配置数据源： 嵌入式数据库的支持：Spring Boot 可以自动配置 H2, HSQL and Derby 数据库，不需要提供任何的 链接 URLs，只需要加入相应的 jar 包，Spring boot 可以自动发现装配]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十一、Spring Boot之文件上传详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E4%B8%80%E3%80%81Spring-Boot%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十、Spring Boot CROS支持]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%8D%81%E3%80%81Spring-Boot-CROS%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九、Spring Boot整合Servlet、Fitter和Listener详解]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%B9%9D%E3%80%81Spring-Boot%E6%95%B4%E5%90%88Servlet%E3%80%81Fitter%E5%92%8CListener%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八、Spring Boot异常处理详解]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%85%AB%E3%80%81Spring-Boot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot异常处理详解]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七、Spring Boot整合JSP详解]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%B8%83%E3%80%81Spring-Boot%E6%95%B4%E5%90%88JSP%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot整合JSP详解]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五、Spring Boot整合FreeMarker详解]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%BA%94%E3%80%81Spring-Boot%E6%95%B4%E5%90%88FreeMarker%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot整合FreeMarker详解]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六、Spring Boot整合Thymeleaf详解]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%85%AD%E3%80%81Spring-Boot%E6%95%B4%E5%90%88Thymeleaf%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Thymeleaf的基本语法和常用方法简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： 1.Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 2.Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 3.Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 标准表达式语法它们分为四类： 1.变量表达式 2.选择或星号表达式 3.文字国际化表达式 4.URL表达式 变量表达式变量表达式即OGNL表达式或Spring EL表达式(在Spring术语中也叫model attributes)。如下所示：${session.user.name} 它们将以HTML标签的一个属性来表示： 12&lt;span th:text=&quot;$&#123;book.author.name&#125;&quot;&gt; &lt;li th:each=&quot;book : $&#123;books&#125;&quot;&gt; 选择(星号)表达式选择表达式很像变量表达式，不过它们用一个预先选择的对象来代替上下文变量容器(map)来执行，如下：*{customer.name} 被指定的object由th:object属性定义： 12345&lt;div th:object=&quot;$&#123;book&#125;&quot;&gt; ... &lt;span th:text=&quot;*&#123;title&#125;&quot;&gt;...&lt;/span&gt; ... &lt;/div&gt; 文字国际化表达式文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用Key索引Value，还可以提供一组参数(可选). 12#&#123;main.title&#125; #&#123;message.entrycreated($&#123;entryId&#125;)&#125; 可以在模板文件中找到这样的表达式代码： 123456&lt;table&gt; ... &lt;th th:text=&quot;#&#123;header.address.city&#125;&quot;&gt;...&lt;/th&gt; &lt;th th:text=&quot;#&#123;header.address.country&#125;&quot;&gt;...&lt;/th&gt; ... &lt;/table&gt; URL表达式URL表达式指的是把一个有用的上下文或回话信息添加到URL，这个过程经常被叫做URL重写。@{/order/list}URL还可以设置参数：@{/order/details(id=${orderId})}相对路径：@{../documents/report} 让我们看这些表达式： 12&lt;form th:action=&quot;@&#123;/createOrder&#125;&quot;&gt; &lt;a href=&quot;main.html&quot; th:href=&quot;@&#123;/main&#125;&quot;&gt; 变量表达式和星号表达有什么区别吗？如果不考虑上下文的情况下，两者没有区别；星号语法评估在选定对象上表达，而不是整个上下文什么是选定对象？就是父标签的值，如下： 12345&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 这是完全等价于： 12345&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;$&#123;session.user.firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;$&#123;session.user.lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;$&#123;session.user.nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 当然，美元符号和星号语法可以混合使用： 12345&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;$&#123;session.user.lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 表达式支持的语法字面（Literals） 文本文字（Text literals）: &#39;one text&#39;, &#39;Another one!&#39;,… 数字文本（Number literals）: 0, 34, 3.0, 12.3,… 布尔文本（Boolean literals）: true, false 空（Null literal）: null 文字标记（Literal tokens）: one, sometext, main,… 文本操作（Text operations） 字符串连接(String concatenation): + 文本替换（Literal substitutions）: |The name is ${name}| 算术运算（Arithmetic operations） 二元运算符（Binary operators）: +, -, *, /, % 减号（单目运算符）Minus sign (unary operator): - 布尔操作（Boolean operations） 二元运算符（Binary operators）:and, or 布尔否定（一元运算符）Boolean negation (unary operator):!, not 比较和等价(Comparisons and equality) 比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 等值运算符（Equality operators）:==, != (eq, ne) 条件运算符（Conditional operators） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) 所有这些特征可以被组合并嵌套： 1&apos;User is of type &apos; + ($&#123;user.isAdmin()&#125; ? &apos;Administrator&apos; : ($&#123;user.type&#125; ?: &apos;Unknown&apos;)) 常用th标签都有那些？ 关键字 功能介绍 案例 th:id 替换id &lt;input th:id=&quot;&#39;xxx&#39; + ${collect.id}&quot;/&gt; th:text 文本替换 &lt;p th:text=&quot;${collect.description}&quot;&gt;description&lt;/p&gt; th:utext 支持html的文本替换 &lt;p th:utext=&quot;${htmlcontent}&quot;&gt;conten&lt;/p&gt; th:object 替换对象 &lt;div th:object=&quot;${session.user}&quot;&gt; th:value 属性赋值 &lt;input th:value=&quot;${user.name}&quot; /&gt; th:with 变量赋值运算 &lt;div th:with=&quot;isEven=${prodStat.count}%2==0&quot;&gt;&lt;/div&gt; th:style 设置样式 th:style=&quot;&#39;display:&#39; + @{(${sitrue} ? &#39;none&#39; : &#39;inline-block&#39;)} + &#39;&#39;&quot; th:onclick 点击事件 th:onclick=&quot;&#39;getCollect()&#39;&quot; th:each 属性赋值 tr th:each=&quot;user,userStat:${users}&quot;&gt; th:if 判断条件 &lt;a th:if=&quot;${userId == collect.userId}&quot; &gt; th:unless 和th:if判断相反 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; th:href 链接地址 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; /&gt; th:switch 多路选择 配合th:case 使用 &lt;div th:switch=&quot;${user.role}&quot;&gt; th:case th:switch的一个分支 &lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;/p&gt; th:fragment 布局标签，定义一个代码片段，方便其它地方引用 &lt;div th:fragment=&quot;alert&quot;&gt; th:include 布局标签，替换内容到引入的文件 &lt;head th:include=&quot;layout :: htmlhead&quot; th:with=&quot;title=&#39;xx&#39;&quot;&gt;&lt;/head&gt; /&gt; th:replace 布局标签，替换整个标签到引入的文件 &lt;div th:replace=&quot;fragments/header :: title&quot;&gt;&lt;/div&gt; th:selected selected选择框 选中 th:selected=&quot;(${xxx.id} == ${configObj.dd})&quot; th:src 图片类地址引入 &lt;img class=&quot;img-responsive&quot; alt=&quot;App Logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt; th:inline 定义js脚本可以使用变量 &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt; th:action 表单提交的地址 &lt;form action=&quot;subscribe.html&quot; th:action=&quot;@{/subscribe}&quot;&gt; th:remove 删除某个属性 &lt;tr th:remove=&quot;all&quot;&gt; 1.all:删除包含标签和所有的孩子。2.body:不包含标记删除,但删除其所有的孩子。3.tag:包含标记的删除,但不删除它的孩子。4.all-but-first:删除所有包含标签的孩子,除了第一个。5.none:什么也不做。这个值是有用的动态评估。 th:attr 设置标签属性，多个属性可以用逗号分隔 比如 th:attr=&quot;src=@{/image/aa.jpg},title=#{logo}&quot;，此标签不太优雅，一般用的比较少。 还有非常多的标签，这里只列出最常用的几个,由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为:include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。 几种常用的使用方法1、赋值、字符串拼接12&lt;p th:text=&quot;$&#123;collect.description&#125;&quot;&gt;description&lt;/p&gt;&lt;span th:text=&quot;&apos;Welcome to our application, &apos; + $&#123;user.name&#125; + &apos;!&apos;&quot;&gt; 字符串拼接还有另外一种简洁的写法 1&lt;span th:text=&quot;|Welcome to our application, $&#123;user.name&#125;!|&quot;&gt; 2、条件判断 If/UnlessThymeleaf中使用th:if和th:unless属性进行条件判断，下面的例子中，&lt;a&gt;标签只有在th:if中条件成立时才显示： 12&lt;a th:if=&quot;$&#123;myself==&apos;yes&apos;&#125;&quot; &gt; &lt;/i&gt; &lt;/a&gt;&lt;a th:unless=$&#123;session.user != null&#125; th:href=&quot;@&#123;/login&#125;&quot; &gt;Login&lt;/a&gt; th:unless于th:if恰好相反，只有表达式中的条件不成立，才会显示其内容。 也可以使用 (if) ? (then) : (else) 这种语法来判断显示的内容 3、for 循环12345678910 &lt;tr th:each=&quot;collect,iterStat : $&#123;collects&#125;&quot;&gt; &lt;th scope=&quot;row&quot; th:text=&quot;$&#123;collect.id&#125;&quot;&gt;1&lt;/th&gt; &lt;td &gt; &lt;img th:src=&quot;$&#123;collect.webLogo&#125;&quot;/&gt; &lt;/td&gt; &lt;td th:text=&quot;$&#123;collect.url&#125;&quot;&gt;Mark&lt;/td&gt; &lt;td th:text=&quot;$&#123;collect.title&#125;&quot;&gt;Otto&lt;/td&gt; &lt;td th:text=&quot;$&#123;collect.description&#125;&quot;&gt;@mdo&lt;/td&gt; &lt;td th:text=&quot;$&#123;terStat.index&#125;&quot;&gt;index&lt;/td&gt;&lt;/tr&gt; iterStat称作状态变量，属性有： index:当前迭代对象的index（从0开始计算） count: 当前迭代对象的index(从1开始计算) size:被迭代对象的大小 current:当前迭代变量 even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算） first:布尔值，当前循环是否是第一个 last:布尔值，当前循环是否是最后一个 4、URLURL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。如果需要Thymeleaf对URL进行渲染，那么务必使用th:href，th:src等属性，下面是一个例子 12345&lt;!-- Will produce &apos;http://localhost:8080/standard/unread&apos; (plus rewriting) --&gt; &lt;a th:href=&quot;@&#123;/standard/&#123;type&#125;(type=$&#123;type&#125;)&#125;&quot;&gt;view&lt;/a&gt;&lt;!-- Will produce &apos;/gtvg/order/3/details&apos; (plus rewriting) --&gt;&lt;a href=&quot;details.html&quot; th:href=&quot;@&#123;/order/&#123;orderId&#125;/details(orderId=$&#123;o.id&#125;)&#125;&quot;&gt;view&lt;/a&gt; 设置背景 1&lt;div th:style=&quot;&apos;background:url(&apos; + @&#123;/&lt;path-to-image&gt;&#125; + &apos;);&apos;&quot;&gt;&lt;/div&gt; 根据属性值改变背景 1&lt;div class=&quot;media-object resource-card-image&quot; th:style=&quot;&apos;background:url(&apos; + @&#123;($&#123;collect.webLogo&#125;==&apos;&apos; ? &apos;img/favicon.png&apos; : $&#123;collect.webLogo&#125;)&#125; + &apos;)&apos;&quot; &gt;&lt;/div&gt; 几点说明： 上例中URL最后的(orderId=${o.id}) 表示将括号内的内容作为URL参数处理，该语法避免使用字符串拼接，大大提高了可读性 @{...}表达式中可以通过{orderId}访问Context中的orderId变量 @{/order}是Context相关的相对路径，在渲染时会自动添加上当前Web应用的Context名字，假设context名字为app，那么结果应该是/app/order 5、内联js内联文本：[[…]]内联文本的表示方式，使用时，必须先用th:inline=”text/javascript/none”激活，th:inline可以在父级标签内使用，甚至作为body的标签。内联文本尽管比th:text的代码少，不利于原型显示。 12345678&lt;script th:inline=&quot;javascript&quot;&gt;/*&lt;![CDATA[*/...var username = /*[[$&#123;sesion.user.name&#125;]]*/ &apos;Sebastian&apos;;var size = /*[[$&#123;size&#125;]]*/ 0;.../*]]&gt;*/&lt;/script&gt; js附加代码： 123/*[+var msg = &apos;This is a working application&apos;;+]*/ js移除代码： 123/*[- */var msg = &apos;This is a non-working template&apos;;/* -]*/ 6、内嵌变量为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问： dates ： java.util.Date的功能方法类。 calendars : 类似#dates，面向java.util.Calendar numbers : 格式化数字的功能方法类 strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。 objects: 对objects的功能类操作。 bools: 对布尔值求值的功能方法。 arrays：对数组的功能类方法。 lists: 对lists功能类方法 sets maps… 下面用一段代码来举例一些常用的方法： dates123456789101112131415161718/* * Format date with the specified pattern * Also works with arrays, lists or sets */$&#123;#dates.format(date, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.arrayFormat(datesArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.listFormat(datesList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.setFormat(datesSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;/* * Create a date (java.util.Date) object for the current date and time */$&#123;#dates.createNow()&#125;/* * Create a date (java.util.Date) object for the current date (time set to 00:00) */$&#123;#dates.createToday()&#125; strings12345678910111213141516171819202122232425262728293031323334/* * Check whether a String is empty (or null). Performs a trim() operation before check * Also works with arrays, lists or sets */$&#123;#strings.isEmpty(name)&#125;$&#123;#strings.arrayIsEmpty(nameArr)&#125;$&#123;#strings.listIsEmpty(nameList)&#125;$&#123;#strings.setIsEmpty(nameSet)&#125;/* * Check whether a String starts or ends with a fragment * Also works with arrays, lists or sets */$&#123;#strings.startsWith(name,&apos;Don&apos;)&#125; // also array*, list* and set*$&#123;#strings.endsWith(name,endingFragment)&#125; // also array*, list* and set*/* * Compute length * Also works with arrays, lists or sets */$&#123;#strings.length(str)&#125;/* * Null-safe comparison and concatenation */$&#123;#strings.equals(str)&#125;$&#123;#strings.equalsIgnoreCase(str)&#125;$&#123;#strings.concat(str)&#125;$&#123;#strings.concatReplaceNulls(str)&#125;/* * Random */$&#123;#strings.randomAlphanumeric(count)&#125; 使用thymeleaf布局使用thymeleaf布局非常的方便 定义代码片段 123&lt;footer th:fragment=&quot;copy&quot;&gt; &amp;copy; 2016&lt;/footer&gt; 在页面任何地方引入： 1234&lt;body&gt; &lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt; &lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt; &lt;/body&gt; th:include 和 th:replace区别，include只是加载，replace是替换 返回的HTML如下： 1234&lt;body&gt; &lt;div&gt; &amp;copy; 2016 &lt;/div&gt; &lt;footer&gt;&amp;copy; 2016 &lt;/footer&gt;&lt;/body&gt; 下面是一个常用的后台页面布局，将整个页面分为头部，尾部、菜单栏、隐藏栏，点击菜单只改变content区域的页面 123456789&lt;body class=&quot;layout-fixed&quot;&gt; &lt;div th:fragment=&quot;navbar&quot; class=&quot;wrapper&quot; role=&quot;navigation&quot;&gt; &lt;div th:replace=&quot;fragments/header :: header&quot;&gt;Header&lt;/div&gt; &lt;div th:replace=&quot;fragments/left :: left&quot;&gt;left&lt;/div&gt; &lt;div th:replace=&quot;fragments/sidebar :: sidebar&quot;&gt;sidebar&lt;/div&gt; &lt;div layout:fragment=&quot;content&quot; id=&quot;content&quot; &gt;&lt;/div&gt; &lt;div th:replace=&quot;fragments/footer :: footer&quot;&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 任何页面想使用这样的布局值只需要替换中见的 content模块即可 1234&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; layout:decorator=&quot;layout&quot;&gt; &lt;body&gt; &lt;section layout:fragment=&quot;content&quot;&gt; ... 也可以在引用模版的时候传参 1&lt;head th:include=&quot;layout :: htmlhead&quot; th:with=&quot;title=&apos;Hello&apos;&quot;&gt;&lt;/head&gt; layout 是文件地址，如果有文件夹可以这样写 fileName/layout:htmlheadhtmlhead 是指定义的代码片段 如 th:fragment=&quot;copy&quot; Spring Boot整合Thymeleaf的步骤：Spring boot 在spring默认基础上，自动配置添加了以下特性: 包含了ContentNegotiatingViewResolver和BeanNameViewResolver beans。 对静态资源的支持，包括对WebJars的支持。 自动注册Converter，GenericConverter，Formatter beans。 对HttpMessageConverters的支持。 自动注册MessageCodeResolver。 对静态index.html的支持。 对自定义Favicon的支持。 主动使用ConfigurableWebBindingInitializer bean 1、在pom文件中配置如下依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 2.在templates文件夹中创建一个index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head lang="en"&gt; &lt;title&gt;Spring Boot Demo - FreeMarker&lt;/title&gt; &lt;link href="/css/index.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;img src="/images/logo.png" /&gt; &lt;h1 id="title" th:text="$&#123;title&#125;"&gt;&lt;/h1&gt;&lt;/center&gt;&lt;script type="text/javascript" src="/webjars/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $('#title').click(function()&#123; alert('点击了'); &#125;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.在controller包中创建一个WebController 123456789101112131415161718192021package com.lqg.controller;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("/web")@Slf4jpublic class WebController &#123; private static final Logger logger = LoggerFactory.getLogger(WebController.class); @RequestMapping("/index") public String index(ModelMap map)&#123; map.put("title","hello world"); logger.info("这里是controller"); return "index";//注意，不要在最前面加上/，Linux下会出错 &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、Spring Boot整合日志详解]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%9B%9B%E3%80%81Spring-Boot%E6%95%B4%E5%90%88%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot整合日志详解]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis[从入门到基本精通]]]></title>
    <url>%2F2019%2F08%2F25%2FMyBatis-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%9F%BA%E6%9C%AC%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[MyBatis【从入门到基本精通】 一、MyBatis的基本使用1、MyBatis作用 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML用于配置和原始映射，将接口和Java的POJO类映射成数据库中的记录 使开发者只需要关注 SQL本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 2.MyBatis的历史 原是apache的一个开源项目iBatis，2010年6月这个项目由apache software foundation迁移到了google code，并且改名为MyBatis 。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 3.为什么要使用MyBatis？JDBC的缺点 SQL夹在Java代码块里，耦合度高导致硬编码内伤 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 要自已创建connection、创建statement、手动设置参数、结果集检索等 Hibernate的缺点 长难复杂SQL，对于Hibernate而言处理也不容易 内部自动生产的SQL，不容易做特殊优化。 MyBatis的好处： 对开发人员而言，核心sql还是需要自己优化 MyBatis是一个半自动化的持久化层框架。 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 二、MyBatis的开发步骤1、下载Mybatis核心包http://www.mybatis.org/mybatis-3/getting-started.html https://github.com/mybatis/mybatis-3/releases 2、创建工程,引入MyBatis核心包及依赖包 3、创建customer表123456781 CREATE TABLE customer(2 cust_id int PRIMARY KEY,3 cust_name varchar(50),4 cust_profession VARCHAR(50),5 cust_phone VARCHAR(50),6 cust_email VARCHAR(50)7 )1234567 4、建立与表对象的domain，创建Customer实体类我在IDEA中用了lombok jar包1234567891011121314151617181920212223242526 package com.lqg.domain; 2 3 import lombok.Getter; 4 import lombok.Setter; 5 6 @Setter@Getter 7 public class Customer &#123; 8 9 private Integer cust_id;10 private String cust_name;11 private String cust_profession;12 private String cust_phone;13 private String cust_email;14 15 @Override16 public String toString() &#123;17 return "Customer&#123;" +18 "cust_id=" + cust_id +19 ", cust_name='" + cust_name + '\'' +20 ", cust_profession='" + cust_profession + '\'' +21 ", cust_phone='" + cust_phone + '\'' +22 ", cust_email='" + cust_email + '\'' +23 '&#125;';24 &#125;25 &#125;12345678910111213141516171819202122232425 5、创建与表对象的关系映射Mapping文件编写sql语句12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt; 2 &lt;!DOCTYPE mapper 3 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 4 "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; 5 &lt;mapper namespace="Mytest"&gt; 6 &lt;!--根据id查询用户--&gt; 7 &lt;select id="queryCustomerById" parameterType="Int" resultType="com.lqg.domain.Customer"&gt; 8 select * from `customer` where cust_id = #&#123;cust_id&#125; 9 &lt;/select&gt;10 11 &lt;/mapper&gt;123456789101112 6、在核心配置文件当中引入Mapping12345&lt;!--加载映射文件--&gt;&lt;mappers&gt;&lt;mapper resource="com/lqg/domain/Customer.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt;1234 7、创建工厂,执行sql语句1234567891011121314151617181920212223242526272829303132package com.lqg.test;import com.lqg.domain.Customer;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MyBatisTest &#123; @Test public void test() throws IOException &#123; //1.创建一个SqlSessionFactoryBulider的类 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //2.加载SqlMapConfig.xml的配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); //3.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); //4.创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //5.用sqlSession对象执行查询 Customer customer = sqlSession.selectOne("queryCustomerById",1); System.out.println(customer); &#125;&#125;12345678910111213141516171819202122232425262728293031 8通过用户id查询结果如下： 三. MyBatis的入门程序：4.1、MyBatis的CRUD操作MyBatis查询一个，多个以及增删改 4.4.1通过用户id进行查询对应映射配置 1234&lt;select id="queryCustomerById" parameterType="Int" resultType="com.domain.Customer"&gt; SELECT * FROM `customer` WHERE cust_id = #&#123;cust_id&#125;&lt;/select&gt;123 在测试类里面查询 12Customer c = session.selectOne("queryCustomerById", 1);1 查询所有用户在对应的映射文件里面配置 1234&lt;select id="queryAllCustomer" resultType="com.domain.Customer"&gt; select * from customer &lt;/select&gt;123 模糊查询（同查询所有差不多） 1234&lt;select id="queryAllByName" parameterType="String" resultType="com.lqg.domain.Customer"&gt; select * from customer where cust_name like '%$&#123;value&#125;%'&lt;/select&gt;123 4.4.2、总结 parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中 selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常 selectList可以查询一条或多条记录 #{}表示一个？占位符号，通过#{}可以实现preparedStatement向占位符中设置值自动进行java类型和jdbc类型转换，可以有效防止sql注入#{}可以接收简单类型值或pojo属性值如果parameterType传输单个简单类型值,#{}括号中可以是value或其它名称里面的参数传递过来都是加上’’引号的， 表示拼接sql串，可以接收简单类型值或pojo属性值通过{} 表示拼接sql串，可以接收简单类型值或pojo属性值 通过表示拼接s*ql串，可以接收简单类型值或pojo*属性值通过{}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换如果parameterType传输单个简单类型值，${}括号中只能是value 5、保存更新删除5.1添加用户对应关系映射配置 12345&lt;insert id="insertCustomer" parameterType="com.domain.Customer"&gt; insert into `customer` values(#&#123;cust_id&#125;,#&#123;cust_name&#125;,#&#123;cust_profession&#125;, #&#123;cust_phone&#125;,#&#123;cust_email&#125;)&lt;/insert&gt;1234 注意：如果添加操作后面直接跟的表名，赋值里面的所有字段都要写上包括自动增长的id，如果是跟字段那值就跟上自己写的字段一一对应 5.5.1、添加用户的方法测试代码 12345SqlSession session = MyBatisUtils.openSession(); Customer customer = new Customer("老王","服务员","17364343463","748639224@qq.com"); session.insert("insertCustomer",customer); session.commit();1234 注意：当要修改数据库中的记录的时候，执行sql时候需要自己提交事务 5.5.2、返回添加过后自增的主键两种方式方式一：获取插入最后一个id（写在insert标签里面） 1234&lt;selectKey keyColumn="cust_id" keyProperty="cust_id" resultType="Integer" order="AFTER"&gt; select last_insert_id()&lt;/selectKey&gt;123 方式二：获取插入的最后一个id(这种方式比第一种简单)* 1234567&lt;insert id="insertCustomer" parameterType="Customer" useGeneratedKeys="true" keyProperty="cust_id" keyColumn="cust_id"&gt; //keyColumn可以不写 insert into customer(cust_name,cust_profession,cust_phone) values(#&#123;cust_name&#125;,#&#123;cust_profession&#125;,#&#123;cust_phone&#125;);&lt;/insert&gt; 123456 5.2更新用户对应关系映射配置 1234&lt;update id="updateCustomerById" parameterType="com.lqg.domain.Customer"&gt; update customer set cust_name =#&#123;cust_name&#125; where cust_id = #&#123;cust_id&#125;&lt;/update&gt;123 5.2.1、修改用户的方法测试代码 123456789Customer customer1 = new Customer(); customer1.setCust_id(7); customer1.setCust_name("王麻子"); customer1.setCust_profession("清洁工"); customer1.setCust_email("78754579846"); int row= sqlSession.insert("saveCustomer",customer1); int row2 = sqlSession.update("updateCustomerById",customer1); session.commit();12345678 5.3删除用户对应关系映射配置 1234&lt;delete id="deleteCustomerById" parameterType="com.lqg.domain.Customer"&gt; delete from customer where cust_id=#&#123;cust_id&#125;&lt;/delete&gt;123 5.3.1、修改用户的方法测试代码 12345678910 Customer customer1 = new Customer(); customer1.setCust_id(7); customer1.setCust_name("王麻子"); customer1.setCust_profession("清洁工"); customer1.setCust_email("78754579846"); int row= sqlSession.insert("saveCustomer",customer1); int row2 = sqlSession.update("updateCustomerById",customer1); sqlSession.delete("deleteCustomerById",7) session.commit();123456789 四、MyBatis开发Dao1、原始的Dao开发方法1.1、创建CustomerDao接口类 123456789101112package com.lqg.dao;import com.lqg.domain.Customer;import java.util.List;public interface CustomerDao &#123; public Customer findCustomerById(Long cust_id); public List&lt;Customer&gt; findAllCustomer(); public int saveCustomer(Customer customer);&#125;1234567891011 1.2、创建CustomerDao接口类的实现类CustomerDaoImpl 123456789101112131415161718192021222324252627282930313233343536package com.lqg.daoImpl;import com.lqg.dao.CustomerDao;import com.lqg.domain.Customer;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class CustomerDaoImpl implements CustomerDao &#123; private SqlSessionFactory sqlSessionFactory; public CustomerDaoImpl(SqlSessionFactory sqlSessionFactory)&#123; this.sqlSessionFactory=sqlSessionFactory; &#125; @Override public Customer findCustomerById(Long cust_id) &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); Customer customer = sqlSession.selectOne("queryCustomerById", 2); return customer; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;Customer&gt; allCustomer = sqlSession.selectList("queryAllCustomer"); return allCustomer; &#125; @Override public int saveCustomer(Customer customer) &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); int customer1=sqlSession.insert("saveCustomer",customer); return customer1; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435 1.3、创建CustomerDao的测试类TestCustomerDao的测试类 123456789101112131415161718192021222324252627282930313233343536373839package com.lqg.test;import com.lqg.dao.CustomerDao;import com.lqg.daoImpl.CustomerDaoImpl;import com.lqg.domain.Customer;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestCustomerDao &#123; private SqlSessionFactory sqlSessionFactory; public void init() throws IOException &#123; System.out.println("init"); //1.创建一个SqlSessionFactoryBulider的类 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //2.加载SqlMapConfig.xml的配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); //3.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125;@Testpublic void test()&#123; //创建CustomerDao的接口编程 CustomerDao customerDao = new CustomerDaoImpl(this.sqlSessionFactory); //通过id查询用户，然后保存到customer中 Customer customer = customerDao.findCustomerById(2L); System.out.println(customer); List&lt;Customer&gt; allCustomer = customerDao.findAllCustomer(); System.out.println(allCustomer); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738 2.Mapper动态代理2.1、Mapper动态代理开发的要求 namespace必须和Mapper接口类路径一致 id必须和Mapper接口方法名一致 parameterType必须和接口方法参数类型一致 resultType必须和接口方法返回值类型一致 2.2、先重新创建一张表 1234567CREATE TABLE tbl_employee&#123; id INT PRIMARY KEY auto_increment, last_name VARCHAR(255), gender CHAR(1), email VARCHAR(255)&#125;123456 2.3、这是演示的结构图2.4、创建一个Employee的pojo类 123456789101112131415package com.lqg.mybatis.domain;import lombok.Getter;import lombok.Setter;import lombok.ToString;@Setter@Getter@ToStringpublic class Employee &#123; private Integer id; private String lastName; private String gender; private String email;&#125;1234567891011121314 2.5、创建MyBatis的核心配置文件 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/lqg/mybatis/domain/EmployeeMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;123456789101112131415161718192021222324 2.6、创建pojo的接口类 12345678package com.lqg.mybatis.dao;import com.lqg.mybatis.domain.Employee;public interface EmployeeMapper &#123; public Employee getEmployeeById(Integer id);//方法名称为xml配置文件里面的对应操作语句的id名称&#125;1234567 2.7、创建pojo的映射EmployeeMapper.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql语句，后续有重要内容 --&gt; &lt;!-- 1. namespace必须和Mapper接口类路径一致 2. id必须和Mapper接口方法名一致 3. parameterType必须和接口方法参数类型一致 4. resultType必须和接口方法返回值类型一致--&gt;&lt;!--public Employee getEmployeeById(Integer id);--&gt;&lt;mapper namespace="com.lqg.mybatis.dao.EmployeeMapper"&gt; &lt;select id="getEmployeeById" resultType="com.lqg.mybatis.domain.Employee"&gt; select id,last_name lastName,gender,email from tbl_employee where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;12345678910111213141516 2.8、最后编写MyBatisTest的测试类 12345678910111213141516171819202122232425262728293031323334package com.lqg.mybatis.test;import com.lqg.mybatis.dao.EmployeeMapper;import com.lqg.mybatis.domain.Employee;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;public class MyBatisTest &#123; @Test public void test() throws IOException &#123; //1.创建一个SqlSessionFactoryBulider的类 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //2.加载mybatis-config.xml的配置文件 InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); //3.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); //4.创建SqlSession对象 SqlSession openSession = sqlSessionFactory.openSession(); //获取接口的实现类对象 EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);//接口的字节码 Employee employee=mapper.getEmployeeById(1);//方法为接口当中的方法 System.out.println(employee); openSession.close(); &#125;&#125;123456789101112131415161718192021222324252627282930313233 2.9、查询效果如下 五、MyBatis的参数传递1.单个参数 可以接受基本类型，对象类型，集合类型的值。 MyBatis可直接使用这个参数，不需要经过任何处理。 2.多个参数 任意多个参数，都会被MyBatis重新包装成一个Map传入。 Map的key是param1，param2…，值就是参数的值示例3.@param命名参数 为参数使用@Param起一个名字 MyBatis就会将这些参数封装进map中，key就是我们自己指定的名字示例4.pojo 当这些参数属于我们业务POJO时，我们直接传递POJO示例5.Map我们也可以封装多个参数为map，直接传递示例6.参数传递源码分析 会把参数给放到一个数组当中 如果一个参数, 内部处理时,会自动把该参数范围 如果是多个参数,内部会做判断 判断是否有@param注解 如果没有： 没有注解的话, 就直接使用arg0 arg1…为key 放到map中并且还会以param1和param2…为key放一份到map中 如果有 如果有注解的话, 会使用注解当中的值,替换掉默认的arg0和arg1 使用@param中的值,做为key 放到一个map当中并且还会以param1和param2…为key放一份到map中 六、MyBatis的核心配置文件1、 properties：定义属性及读取属性文件 示例 1234 &lt;properties resource="jdbc.properties"&gt; &lt;property name="jdbc.driver" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;&lt;/properties&gt;123 resource为资源文件，配置文件访问方法”${key名称}”,如访问数据库连接，如果配置了相同的property会先加载，resource里面的会把其覆盖掉 2、settings——这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为示例 123456 &lt;!--全局信息配置，--&gt; &lt;settings&gt; //配置打印sql信息 &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt; &lt;/settings&gt;12345 3、typeAliases——（定义别名，可以在使用时候省略掉前面一串路径） 1234567&lt;typeAliases&gt; &lt;!--单个别名--&gt; &lt;!--&lt;typeAlias type="domain.Customer" alias="Customer"&gt;&lt;/typeAlias&gt;--&gt; &lt;!--批量定义别名，别名为类名--&gt; &lt;package name="domain"&gt;&lt;/package&gt;&lt;/typeAliases&gt;123456 如果当前包类与子包类重名,会有异常，可以在类上使用注解@Alias(“别名”) 4、typeHandlers——（类型处理器）无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。JDK1.8之后实现全部的JSR310规范日期时间处理上，我们可以使用MyBatis基于JSR310（Date and Time API）编写的各种日期时间类型处理器。MyBatis3.4以前的版本需要我们手动注册这些处理器，以后的版本都是自动注册的 5、Plugins ——（插件）插件是MyBatis提供的一个非常强大的机制，MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。通过插件来修改MyBatis的一些核心行为。 6、Environments ——（数据库运行的环境）MyBatis可以配置多种环境，比如开发、测试和生产环境需要有不同的配置。每种环境使用一个environment标签进行配置并指定唯一标识符可以通过environments标签中的default属性指定一个环境的标识符来快速的切换环境Environment子标签transactionManager事务管理Type有以下取值JDBC使用JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务范围MANAGED不提交或回滚一个连接、让容器来管理事务的整个生命周期ManagedTransactionFactory自定义实现TransactionFactory接口type=全类名/别名dataSource数据源type有以下取值UNPOOLED不使用连接池UnpooledDataSourceFactoryPOOLED使用连接池PooledDataSourceFactoryJNDI在EJB 或应用服务器这类容器中查找指定的数据源自定义实现DataSourceFactory接口，定义数据源的获取方式实际开发实际开发中我们使用Spring管理数据源并进行事务控制的配置来覆盖上述配置 7、databaseIDProvider——（定义数据的厂商）MyBatis 可以根据不同的数据库厂商执行不同的语句。可以能过databaseIDProvider标签来进行设置 12345678910111213141516&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MYSQL" value="mysql"/&gt; &lt;property name="DB2" value="db2"/&gt; &lt;property name="Oracle" value="oracle" /&gt; &lt;property name="SQL Server" value="sqlserver"/&gt;&lt;/databaseIdProvider&gt;123456 示例1&lt;mapper namespace="mapper.CustomerDao"&gt; &lt;select id="getCustomerWithID" resultType="Customer" databaseId="mysql"&gt; //只有Mysql的数据库才能执行该语句 select * from customer where cust_id = #&#123;id名称&#125; and cust_name=#&#123;值&#125; &lt;/select&gt;&lt;/mapper&gt; 123456 8、mappers——（加载映射文件）8.1、使用文件路径引入映射器 12 &lt;mapper resource="domain/Customer.xml"&gt;&lt;/mapper&gt; 1 8.2、使用mapper接口类路径，此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中 1234&lt;mapper class=" " /&gt; 如&lt;mapper class="mapper.CustomerDao"&gt;&lt;/mapper&gt;123 8.3、使用包名引入映射器指定包下的所有mapper接口、批量加载、此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中 12&lt;package name=""/1 //加载对应包下面所有的文件 七、MyBatis的输出类型八、MyBatis【关联映射】1、MyBatis的多表连接1.1一对一 1.1.1设计表格：1234567891011121314151617181920--mysqlcreate table cards( cid int(5) primary key, cnum varchar(10));create table students( sid int(5) primary key, sname varchar(10), scid int(5), constraint scid_fk foreign key(scid) references cards(cid));insert into cards(cid,cnum) values(1,&apos;111&apos;);insert into students(sid,sname,scid) values(1,&apos;哈哈&apos;,1);select * from cards;select * from students;12345678910111213141516171819 1.1.2、实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 身份证(单方) * @author AdminTC */public class Card &#123; private Integer id; private String num; public Card()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNum() &#123; return num; &#125; public void setNum(String num) &#123; this.num = num; &#125;&#125;/** * 学生(单方) * @author AdminTC */public class Student &#123; private Integer id; private String name; private Card card;//关联属性 public Student()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Card getCard() &#123; return card; &#125; public void setCard(Card card) &#123; this.card = card; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 1.1.3、映射文件由于我们有两个实体，因此我们会有两个映射文件Student映射文件 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="studentNamespace"&gt; &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt;1234567891011 Card映射文件 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cardNamespace"&gt; &lt;resultMap type="zhongfucheng2.Card" id="cardMap"&gt; &lt;id property="id" column="cid"/&gt; &lt;result property="num" column="cnum"/&gt; &lt;/resultMap&gt; &lt;/mapper&gt;1234567891011select * from zhongfucheng.students s,zhongfucheng.cards c where c.cid = s.scid and sid=1;1 我来看一下查询结果：我们的实体与映射表中，Student实体是没有关联其他的字段的，仅仅是写出了该实体的自带的属性。 12345 &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;/resultMap&gt;1234 明显地，我们Student是不能封装返回的结果，因此我们需要将关联属性进行关联起来！ 1234567891011 &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;!-- property写的是在Student实体中写关联字段的属性变量名称 resultMap写的是映射文件中的命名空间.id --&gt; &lt;association property="card" resultMap="cardNamespace.cardMap"/&gt; &lt;/resultMap&gt;12345678910 我们关联了以后，Student实体就能够封装返回的结果了 12345678910111213141516171819202122232425&lt;!-- 因为使用多表联合查询， 那么查询结果中的列在对象中就没有对应的属性 所以需要我们自己去配置这些列与对象中的属性的映射关系 注意：并且需要给所有属性配置映射关系 --&gt; &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;!-- id子标签：用于配置主键的映射关系 ,这个id是下面的id column:查询结果中的列的列名 property:结果对象中的属性名 把列与属性之间关联起来：会把查询到的该列的值赋值给这个属性 &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;!-- property写的是在Student实体中写关联字段的属性变量名称 resultMap写的是映射文件中的命名空间.id --&gt; &lt;!-- 封装该对象的属性 与 查询语句结果的列的映射 关系 --&gt; &lt;association property="card" resultMap="cardNamespace.cardMap"/&gt; &lt;/resultMap&gt; &lt;select id="findById" parameterType="int" resultMap="studentMap"&gt; select * from zhongfucheng.students s,zhongfucheng.cards c where c.cid = s.scid and sid=#&#123;id&#125;; &lt;/select&gt;123456789101112131415161718192021222324 1.1.4查询编号为1的学生信息【包括身份证编号】12345678910111213141516171819202122232425 public Student findById(int id) throws Exception &#123; //得到连接对象 SqlSession sqlSession = MybatisUtil.getSqlSession(); try&#123; return sqlSession.selectOne("studentNamespace.findById", id); /* sqlSession.commit();*/ &#125;catch(Exception e)&#123; e.printStackTrace(); sqlSession.rollback(); throw e; &#125;finally&#123; MybatisUtil.closeSqlSession(); &#125; &#125; public static void main(String[] args) throws Exception &#123; StudentDao studentDao = new StudentDao(); Student student = studentDao.findById(1); System.out.println(student.getId() + "----" + student.getName() + "----" + student.getCard().getNum()); &#125;12345678910111213141516171819202122232425 这里写图片描述 2.1一对多 2.1.1设计数据库表123456789101112131415161718192021create table grades( gid int(5) primary key, gname varchar(10));create table students( sid int(5) primary key, sname varchar(10), sgid int(5), constraint sgid_fk foreign key(sgid) references grades(gid));insert into grades(gid,gname) values(1,'java');insert into students(sid,sname,sgid) values(1,'哈哈',1);insert into students(sid,sname,sgid) values(2,'呵呵',1);select * from grades;select * from students;1234567891011121314151617181920 2.1.2创建实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package zhongfucheng2;import java.util.ArrayList;import java.util.List;/** * 学科(单方) * @author AdminTC */public class Grade &#123; private Integer id; private String name; private List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();//关联属性 public Grade()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Student&gt; getStudentList() &#123; return studentList; &#125; public void setStudentList(List&lt;Student&gt; studentList) &#123; this.studentList = studentList; &#125;&#125;package zhongfucheng2;/** * 学生(多方) * @author AdminTC */public class Student &#123; private Integer id; private String name; private Grade grade;//关联属性 public Student()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Grade getGrade() &#123; return grade; &#125; public void setGrade(Grade grade) &#123; this.grade = grade; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 2.1.3映射文件SQL语句12345678910111213141516171819202122232425262728293031323334&lt;mapper namespace="studentNamespace"&gt; &lt;resultMap type="zhongfucheng2.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;/resultMap&gt; &lt;!--查询选修的java学科有多少位学生--&gt; &lt;!--由于我们只要查询学生的名字，而我们的实体studentMap可以封装学生的名字，那么我们返回studentMap即可，并不需要再关联到学科表--&gt; &lt;select id="findByGrade" parameterType="string" resultMap="studentMap"&gt; select s.sname,s.sid from zhongfucheng.students s,zhongfucheng.grades g WHERE s.sgid=g.gid and g.gname=#&#123;name&#125;; &lt;/select&gt;&lt;/mapper&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="gradeNamespace"&gt; &lt;resultMap type="zhongfucheng2.Grade" id="gradeMap"&gt; &lt;id property="id" column="gid"/&gt; &lt;result property="name" column="gname"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt;123456789101112131415161718192021222324252627282930313233 2.1.4DAO12345678910111213141516171819202122232425public List&lt;Student&gt; findByGrade(String grade) throws Exception &#123; //得到连接对象 SqlSession sqlSession = MybatisUtil.getSqlSession(); try&#123; return sqlSession.selectList("studentNamespace.findByGrade", grade); /* sqlSession.commit();*/ &#125;catch(Exception e)&#123; e.printStackTrace(); sqlSession.rollback(); throw e; &#125;finally&#123; MybatisUtil.closeSqlSession(); &#125; &#125; public static void main(String[] args) throws Exception &#123; StudentDao studentDao = new StudentDao(); List&lt;Student&gt; student = studentDao.findByGrade("java"); for (Student student1 : student) &#123; System.out.println(student1.getName()); &#125; &#125;123456789101112131415161718192021222324 1.3多对多 1.3.1数据库表12345678910111213141516171819202122232425262728293031create table students( sid int(5) primary key, sname varchar(10));create table courses( cid int(5) primary key, cname varchar(10));create table middles( msid int(5), mcid int(5), primary key(msid,mcid));insert into students(sid,sname) values(1,'哈哈');insert into students(sid,sname) values(2,'呵呵');insert into courses(cid,cname) values(1,'java');insert into courses(cid,cname) values(2,'android');insert into middles(msid,mcid) values(1,1);insert into middles(msid,mcid) values(1,2);insert into middles(msid,mcid) values(2,1);insert into middles(msid,mcid) values(2,2);select * from students;select * from courses;select * from middles;123456789101112131415161718192021222324252627282930 1.3.2 创建实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.itcast.javaee.mybatis.many2many;import java.util.ArrayList;import java.util.List;/** * 课程(多方) * @author AdminTC */public class Course &#123; private Integer id; private String name; private List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();//关联属性 public Course()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Student&gt; getStudentList() &#123; return studentList; &#125; public void setStudentList(List&lt;Student&gt; studentList) &#123; this.studentList = studentList; &#125;&#125;package cn.itcast.javaee.mybatis.many2many;import java.util.ArrayList;import java.util.List;/** * 学生(多方) * @author AdminTC */public class Student &#123; private Integer id; private String name; private List&lt;Course&gt; courseList = new ArrayList&lt;Course&gt;();//关联属性 public Student()&#123;&#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Course&gt; getCourseList() &#123; return courseList; &#125; public void setCourseList(List&lt;Course&gt; courseList) &#123; this.courseList = courseList; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 1.3.3映射文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="courseNamespace"&gt; &lt;resultMap type="cn.itcast.javaee.mybatis.many2many.Course" id="courseMap"&gt; &lt;id property="id" column="cid"/&gt; &lt;result property="name" column="cname"/&gt; &lt;/resultMap&gt; &lt;!-- 查询哈哈选学了哪些课程 --&gt; &lt;select id="findAllByName" parameterType="string" resultMap="courseMap"&gt; select c.cid,c.cname from students s inner join middles m on s.sid = m.msid inner join courses c on m.mcid = c.cid and s.sname = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="studentNamespace"&gt; &lt;resultMap type="cn.itcast.javaee.mybatis.many2many.Student" id="studentMap"&gt; &lt;id property="id" column="sid"/&gt; &lt;result property="name" column="sname"/&gt; &lt;/resultMap&gt; &lt;select id="findAllByCourseName" parameterType="string" resultMap="studentMap"&gt; select s.sname from students s inner join middles m on s.sid = m.msid inner join courses c on m.mcid = c.cid and c.cname = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 1.3.4创建DAO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast.javaee.mybatis.many2many;import java.util.List;import org.apache.ibatis.session.SqlSession;import cn.itcast.javaee.mybatis.util.MybatisUtil;/** * 持久层 * @author AdminTC */public class StudentCourseDao &#123; /** * 查询哈哈选学了哪些课程 * @param name 表示学生的姓名 */ public List&lt;Course&gt; findAllByName(String name) throws Exception&#123; SqlSession sqlSession = null; try&#123; sqlSession = MybatisUtil.getSqlSession(); return sqlSession.selectList("courseNamespace.findAllByName",name); &#125;catch(Exception e)&#123; e.printStackTrace(); throw e; &#125;finally&#123; MybatisUtil.closeSqlSession(); &#125; &#125; /** * 查询java课程有哪些学生选修 * @param name 表示学生的课程 */ public List&lt;Student&gt; findAllByCourseName(String name) throws Exception&#123; SqlSession sqlSession = null; try&#123; sqlSession = MybatisUtil.getSqlSession(); return sqlSession.selectList("studentNamespace.findAllByCourseName",name); &#125;catch(Exception e)&#123; e.printStackTrace(); throw e; &#125;finally&#123; MybatisUtil.closeSqlSession(); &#125; &#125; public static void main(String[] args) throws Exception&#123; StudentCourseDao dao = new StudentCourseDao(); List&lt;Course&gt; courseList = dao.findAllByName("哈哈"); System.out.print("哈哈选学了" + courseList.size()+"个课程,分别是："); for(Course c : courseList)&#123; System.out.print(c.getName()+" "); &#125; System.out.println("\n-----------------------------------------------------"); List&lt;Student&gt; studentList = dao.findAllByCourseName("android"); System.out.println("选修了android课程的学生有"+studentList.size()+"个，分别是："); for(Student s : studentList)&#123; System.out.print(s.getName()+" "); &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 九、MyBatis的动态sql语句1.什么是动态sql：通过mybatis提供的各种标签方法实现动态拼接sql。 1、if标签需求：根据客户名和级别查询客户 12345&lt;!--根据客户名和级别查询客户--&gt;&lt;select id="queryCustomerWhere" parameterType="customer" resultType="customer"&gt; select * from cst_customer where cust_name=#&#123;cust_name&#125; and cust_level=#&#123;cust_level&#125;&lt;/select&gt; 1234 存在问题 有可能传入的名称或级别为空 可以使用if标签来进行判断 注意：test:放的是Boolean表达式 12345678910&lt;select id="queryCustomerWhere" parameterType="customer" resultType="customer"&gt; select * from cst_customer where &lt;if test="cust_name !=null and cust_name=''"&gt; cust_name=#&#123;cust_name&#125; &lt;/if&gt; &lt;if test="cust_level !=null and cust_name=''"&gt; And cust_level=#&#123;cust_name&#125; &lt;/if&gt;&lt;/select&gt; 123456789 如果前一个条件这后,后面就会多一个and执行就会报错 2、Where标签where标签可以自动添加where，同时可以处理sql语句中第一个and关键字 123456789101112&lt;select id="queryCustomerWhere" parameterType="customer" resultType="customer"&gt; select * from cst_custome &lt;where&gt; &lt;if test="cust_name !=null and cust_name=''"&gt; cust_name=#&#123;cust_name&#125; &lt;/if&gt; &lt;if test="cust_level !=null and cust_name=''"&gt; And cust_level=#&#123;cust_name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 1234567891011 去掉第一个前And 3、trim标签 prefix：设置前缀，在第一个条件之前加上一个前缀 prefixOerrides：条件前缀覆盖，把第一个条件之前的and变成空 suffix：设置后缀，在最后一个条件之后加上一个后缀 suffixOverrides：条件后缀覆盖，把最后一个条件之后的and变成空 123456789101112 &lt;select id="getCustomer" resultType="domain.Customer"&gt; select * from `customer` &lt;trim prefix="where" prefixOverrides="and" suffixOverrides="" suffix="and"&gt; &lt;if test="name!=null and name!=''"&gt; and cust_name=#&#123;name&#125; &lt;/if&gt; &lt;if test="profession!=null and profession!=''"&gt; and cust_profession=#&#123;profession&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt;1234567891011 DAO层现在我想根据学生的编号查询学生的信息和身份证信息！ 由于该查询着重是查询学生的信息，于是我们在学生的映射文件中写SQL语句 按照需求，我们写出来的SQL语句是这样子的 4、choose标签choose用法基本和if一致 sqlsqlsql 注意：整个choose最终只会匹配一种情况 whenchoose标签：（只查满足条件的第一个，后面的条件都不执行） select * from customer 123456789101112&lt;where&gt; &lt;choose&gt; &lt;when test="profession!=null and profession!=''"&gt; cust_profession=#&#123;profession&#125; &lt;/when&gt; &lt;when test="name!=null and name!=''"&gt; cust_name=#&#123;name&#125; &lt;/when&gt; &lt;otherwise&gt;1=1&lt;/otherwise&gt; //当都没有满足条件的时候，执行该默认语句 &lt;/choose&gt;&lt;/where&gt;1234567891011 5、set标签6、foreach向sql传递数据或List,mybatis使用foreach解析，如下根据多个id查询用户信息查询sql：select * from user where id in(1,10,24)在pojo中定义list属性ids存储多个用户id，并添加getter/settter方法 123456@Getter@Setter@ToStringpublic class QueryVo&#123;//包含其他的pojoprivate User user;private list&lt;Integer&gt; ids;12345 Mapper.xml文件 123456789101112131415&lt;!--根据ids查询用户--&gt;&lt;select id="queryUserByIds" parameterType="queryVo" resultType="user"&gt; select * from user &lt;where&gt; &lt;!--foreach标签，进行遍历--&gt; &lt;!--collection：遍历的集合，这里是queryVo的ids的属性值-&gt; &lt;!--遍历的项目，可以随便写，但是和后面的#&#123;&#125;里面要保持一致--&gt; &lt;!--open：在前面添加sql片段--&gt; &lt;!--separator：指定遍历元素之间的分隔符--&gt; &lt;foreach collection="ids" item="item" open="id IN("close =")" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;1234567891011121314 7、bind用于绑定一个字符，并且取名 8、Sql片段使用include标签加载sql片段，refid是sql片段的id如果要使用别的Mapper.xml配置的sql片段，可以在refid前面加上对应的Mapper.xml的nameSpace如： 1234567891011121314151617&lt;include refid="com.lqg.mybatis.mapper.OrderMapper.userFirlds"/&gt;1&lt;select id="queryCustomerWhere" parameterType="customer" resultType="customer"&gt; select &lt;include refid="userFirlds"/&gt; from cst_custome &lt;where&gt; &lt;if test="cust_name !=null and cust_name=''"&gt; cust_name=#&#123;cust_name&#125; &lt;/if&gt; &lt;if test="cust_level !=null and cust_name=''"&gt; And cust_level=#&#123;cust_name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &lt;!--声明sql片段--&gt;&lt;sql id="userFieleds"&gt; cust_id,cust_name,cust_level &lt;/sql&gt;]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、MyBatis入门示例]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%BA%8C%E3%80%81MyBatis%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[二、MyBatis入门示例 在本篇博客中，我们来一起完成MyBatis的入门示例 准备数据库和表12345678910111213141516DROP TABLE student;CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100), gender VARCHAR(10), birthday DATE );INSERT INTO student (name,gender,birthday) VALUES ('波多结衣','female','1995-12-11');INSERT INTO student (name,gender,birthday) VALUES ('波少结衣','female','1996-11-12');INSERT INTO student (name,gender,birthday) VALUES ('杉原杏璃','female','1997-10-13');INSERT INTO student (name,gender,birthday) VALUES ('佐佐木希','female','1998-09-14');INSERT INTO student (name,gender,birthday) VALUES ('伊藤梅子','female','1999-08-15');12345678910111213141516 我们建立数据库mb，并创建一张表student并为其插入数据。 创建JavaBean1234567891011121314151617181920212223242526272829303132333435363738394041package cn.com.helloworld;import java.util.Date;public class Student &#123; private int id; private String name; private String gender; private Date birthday; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", gender=" + gender + ", birthday=" + birthday + "]"; &#125;&#125; 请注意：将JavaBean中的字段与数据库中表中的字段保持一致 导入MyBatis相关jar包请下载MyBatis开发所需jar包并存放至工程的lib目录。 SqlMapConfig.xml在有了数据库和JavaBean之后我们来编写MyBatis的全局配置文件SqlMapConfig.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mb?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt;12345678910111213141516 在该配置文件中配置由MyBatis所采用的事务和数据库连接池 StudentMapper.xml刚才我们编写了MyBatis的全局配置文件SqlMapConfig.xml，现在我们来编写与JavaBean相关的配置文件StudentMapper.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;student&quot;&gt;&lt;/mapper&gt;123456 我们在该配置文件中添加标签并设置其namespace为student。 再将StudentMapper.xml配置到SqlMapConfig.xml，代码如下： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mb?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/StudentMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt;123456789101112131415161718 请参见代码第15—17行 CRUD操作在完成了之上的准备工作后，我们来利用MyBatis实现简单的增删改查。 我们先来做一个最简单的例子：依据Stundet的id查询学生信息 首先在映射文件StudentMapper.xml中写sql语句： 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="student"&gt; &lt;select id="findStudentById" parameterType="int" resultType="cn.com.helloworld.Student"&gt; SELECT * FROM student WHERE id=#&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt;12345678910 在该xml文件中为我们的需求写了一个sql语句，请注意 id标识该sql语句的唯一性，因为之后随着功能的扩展在该xml文件中会有许多sql语句。其实，类似于StudentMapper.xml这样的mapper.xml文件中每一个sql语句都对应一个MappedStatement对象，sql语句的id即是MappedStatement的id。 parameterType表示输入参数类型。此处我们要依据id查询学生，那么输入参数就是一个int类型的数字 resultType表示查询结果的返回类型。在此，我们想得到一个Student对象，所以将resultType设置为cn.com.helloworld.Student #{ }表示占位符，用于接收输入参数。输入参数的类型可以是简单类型，pojo、HashMap。如果输入参数是简单类型那么#{}的括号中可以写成value或其它名称。 在完成了映射文件的编码之后，我们再来书写Java代码 1234567891011121314151617181920212223242526/** * 本文作者：谷哥的小弟 * 博客地址：http://blog.csdn.net/lfdfhl */package cn.com.helloworld;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;public class CRUDTest &#123; @Test public void findStudentById() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); Student student = sqlSession.selectOne("student.findStudentById", 1); System.out.println(student); sqlSession.close(); &#125;&#125; 代码详解如下： 获取MyBatis的全局配置文件SqlMapConfig.xml，请参见代码第18—19行 利用全局配置文件创建SqlSessionFactory，请参见代码第20行 利用SqlSessionFactory创建SqlSession，请参见代码第21行 利用SqlSession调用其selectOne()方法查询一条学生信息，请参见代码第22行。请注意该方法参数：第一个参数用于标识一条sql语句，其构成为：映射文件的namespace+”.”+MappedStatement的id(即sql语句的id)；第二参数是需要传递给sql语句的输入参数。 关闭SqlSession，释放资源；请参见代码第24行 输出结果如下： Student [id=1, name=波多结衣, gender=female, birthday=Mon Dec 11 00:00:00 CST 1995] 至此，我们走完了一个利用MyBatis查询数据的完整流程。 刚才这个例子是查询出来了单条记录，如果要查询多条记录又该怎么做呢？比如查询出学生名字中带有”结”这个字的所有学生，请看如下代码： 123&lt;select id="findStudentByName" parameterType="java.lang.String" resultType="cn.com.helloworld.Student"&gt; SELECT * FROM student WHERE name LIKE '%$&#123;value&#125;%'&lt;/select&gt; 在该映射文件中采用${ }表示拼接，它所接收的输入参数类型可以是简单类型，pojo，HashMap。如果接收简单类型，${}中只能写成value。当${}接收pojo对象值时可通过OGNL读取对象中的属性值；即利用属性.属性.属性…的方式获取对象属性值 在完成映射文件的编写之后，我们再来看Java代码： 123456789101112@Test public void findStudentByName() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;Student&gt; list = sqlSession.selectList("student.findStudentByName", "结"); for(Student student:list)&#123; System.out.println(student); &#125; sqlSession.close(); &#125; 在此利用了qlSession.selectList( )方法返回一个查询后的集合。 输出结果如下： Student [id=1, name=波多结衣, gender=female, birthday=Mon Dec 11 00:00:00 CST 1995]Student [id=2, name=波少结衣, gender=female, birthday=Tue Nov 12 00:00:00 CST 1996] 在完成查询操作后，我们向数据库插入一条新数据，并得到新数据被插入到数据库后它的主键值。 123456&lt;insert id="insertStudent" parameterType="cn.com.helloworld.Student"&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO student (name,gender,birthday) value (#&#123;name&#125;,#&#123;gender&#125;,#&#123;birthday&#125;) &lt;/insert&gt;123456 我们在标签中使用了标签获取插入数据的主键并将其设置到Student对象中. SELECT LAST_INSERT_ID()：得到insert记录的主键值，只适用与自增主键 keyProperty：用于指明将查询到的主键值设置到parameterType指定的对象的哪个属性 order：表示SELECT LAST_INSERT_ID()相对于insert语句的执行顺序。在该例子中用AFTER表示执行完该insert语句后再执行SELECT LAST_INSERT_ID() resultType：指定SELECT LAST_INSERT_ID()的结果的类型 123456789101112131415@Test public void insertStudent() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); Student student=new Student(); student.setName("右右木希"); student.setGender("female"); student.setBirthday(new Date()); sqlSession.insert("student.insertStudent",student); sqlSession.commit(); sqlSession.close(); System.out.println(""+student.getId()); &#125; 代码解析如下： 利用sqlSession.insert()将数据插入数据库，请参见代码第11行 利用sqlSession.commit()提交事务，请参见代码第12行 获取到新插入数据的主键值，请参见代码第14行 继续来看删除数据的操作 123&lt;delete id="deleteStudent" parameterType="java.lang.Integer"&gt; DELETE FROM student where id=#&#123;id&#125;&lt;/delete&gt;123 Java代码如下: 12345678910@Test public void deleteStudent() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.delete("student.deleteStudent", 1); sqlSession.commit(); sqlSession.close(); &#125;12345678910 最后来瞅瞅更新操作 123&lt;update id="updateStudent" parameterType="cn.com.helloworld.Student"&gt; UPDATE student set name=#&#123;name&#125;,gender=#&#123;gender&#125;,birthday=#&#123;birthday&#125; where id=#&#123;id&#125; &lt;/update&gt;123 Java代码如下: 123456789101112131415@Test public void updateStudent() throws IOException &#123; String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); Student student=new Student(); student.setId(3); student.setName("中中木希"); student.setGender("female"); student.setBirthday(new Date()); sqlSession.update("student.updateStudent", student); sqlSession.commit(); sqlSession.close(); &#125;123456789101112131415 嗯哼，至此我们关于MyBatis的入门示例就已经全部完成了。 项目结构图如下所示：]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、MyBatis概述]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%B8%80%E3%80%81MyBatis%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[MyBatis简介 MyBatis原本是apache的一个开源项目iBatis, 2010年该项目由apache software foundation 迁移到了google code并改名为MyBatis 。2013年11月MyBatis又迁移到Github。 The MyBatis SQL mapper framework makes it easier to use a relational database with object-oriented applications. MyBatis couples objects with stored procedures or SQL statements using a XML descriptor or annotations. Simplicity is the biggest advantage of the MyBatis data mapper over object relational mapping tools. MyBatis是一个优秀的持久层框架，它对JDBC操作数据库的过程进行了封装，使开发者只需要关注SQL本身，而不需要开发人员花费大量的精力去处理例如注册驱动、创建connection、创建statement、手动设置参数等JDBC操作。 Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由MyBatis框架执行sql并将结果映射成java对象并返回。 更多介绍，敬请参见MyBatis官方网站：http://www.mybatis.org/mybatis-3/ MyBatis框架1、SqlMapConfig.xml是MyBatis的全局配置文件，它配置了MyBatis的运行环境等信息。 2、mapper.xml是sql映射文件，它配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载 3、通过MyBatis配置信息构造SqlSessionFactory(会话工厂) 4、由会话SqlSessionFactory(工厂)创建SqlSession(会话)操作数据库 5、MyBatis底层自定义Executor(执行器)接口用于执行数据库操作，该接口有两个实现：基本执行器和缓存执行器。 6、MappedStatement是MyBatis的底层封装对象，它封装了操作数据库的sql语句，输入参数，输出结果等信息。mapper.xml文件中每一个sql语句对应一个MappedStatement对象，sql语句的id即是MappedStatement的id。 7、MappedStatement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过MappedStatement在执行sql前将输入的java对象映射至sql中 8、MappedStatement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过MappedStatement在执行sql后将输出结果映射至java对象中 MyBatis开发环境在利用MyBatis开发前，请移步MyBatis官网下载开发所有的jar包、开发指南，说明文档等资料。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、Spring Boot多环境配置详解]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%B8%89%E3%80%81Spring-Boot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot多环境配置详解一. 多环境配置的好处： 1.不同环境配置可以配置不同的参数 2.便于部署，提高效率，减少出错 二. Properties多环境配置 配置激活选项 spring.profiles.active=dev 2.添加其他配置文件 三．YAML多环境配置 ​ 1.配置激活选项 ​ spring: profiles:active: dev ​ 2.在配置文件添加三个英文状态下的短横线即可区分 ​ — spring: profiles: dev四．两种配置方式的比较 ​ 1. Properties配置多环境，需要添加多个配置文件，YAML只需要一个配件文件 ​ 2.书写格式的差异，yaml相对比较简洁，优雅 \3. YAML的缺点：不能通过@PropertySource注解加载。如果需要使用@PropertySource注解的方式加载值，那就要使用properties文件。 五．如何使用 ​ java -jar myapp.jar –spring.profiles.active=dev]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《WEB开发-HEXO博客搭建》第一章Hexo的简介与安装]]></title>
    <url>%2F2019%2F08%2F25%2F%E3%80%8AWEB%E5%BC%80%E5%8F%91-HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0Hexo%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[《WEB开发-HEXO博客搭建》第1章 Hexo博客搭建Hexo官方：https://hexo.io/Hexo官方(中文)：https://hexo.io/zh-cn/Node.js官方网站：https://nodejs.org/en/Node.js官方文档：https://nodejs.org/en/docs/Node.js安装文档：https://nodejs.org/en/download/package-manager/ 1.1 Hexo简介Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统。 1.2 node.js安装Hexo是基于node.js的，所以我们在安装它之前需要用到npm安装工具，这个工具是 node.js 安装包的工具，所以，我们先要安装 node.js。笔者是用的Windows 64位的，到node.js下载安装包。 图1 下载后直接安装就可以啦，和普通的软件没有什么大的区别，所有笔者就不赘述了。 1.3 GitHub账户创建及客户端安装关于git账户创建及客户端下载安装等可参看笔者的博客，笔者在这里就不在赘述了。GitHub官网：https://github.com/Git和Github的使用：https://blog.csdn.net/u013162035/article/details/78476880Git下载：https://git-scm.com/downloadsGit安装：https://blog.csdn.net/u013162035/article/details/78464161 在github网页上创建一个以username.github.io命名的repositories,此时username为自己github的账号名称。 1.4安装hexo使用npm安装Hexo，输入以下命令： 1$ npm install hexo-cli -g 1.5创建Blog笔者在D盘下新建一个blog的文件夹，然后进入blog文件夹，单击右键打开git bash。1. 创建一个叫blog网站$ hexo init 如果没有进入blog文件夹， 就会在当前目录进行初始化。这是初始化命令就要加blog。$ hexo init blog 如果后面跟了名子就会创建目录并在目录进行初始化操作, 以这个名子为目录名。2. 我们进入创建的blog目录里. 并运行该服务$ npm install $ hexo server 【注】hexo命令$ hexo install 3. 测试网页打开浏览器, 在地址栏输入http://localhost:4000/可以看到我们刚刚创建的blog首页 4.修改blog目录下的_config.yml配置文件将网站自部署到Github上$ vim _config.yml 添加如下内容 123git repo: git@github.com:用户名/用户名.github.io.gitbranch: master 【注】在type前面需要增加两个空格，在type的冒号后面需要增加一个空格。请保持代码风格一致，否则会出现错误或是不正确的问题。5.安装部署使用到的git插件在这里我们使用的是git源码管理工具，所以，我需要安装git包进行部署，安装这个插件才能使用git进行自动部署。 $ npm install hexo-deployer-git -save 在接下来，我们将要生成网站了，首先清理一下缓存。$hexo clean 6.进行生成网站当我们部署网站前，需要先生成静态网站。它会自动在目录下创建public的目录, 并将新生成的网页存放在这个目录里。 $ hexo g或hexo generate 7.进行自动部署网站注意部署前需要重新生成网站, 每一次修改后都需要重新生成网站并进行部署，生成网站前第6步。 $ hexo d或hexo deploy 如果在部署出现错误信息如果下: 请参考第5步，需要安装git插件ERROR Deployer not found: git以上两步可以使用一步就可以搞定： $hexo g -d 【注】上述的部署指令中hexo deploy可以换成hexo server，两者的区别在于，前者是将博客部署到远程的Github上，而后者是运行在本地，通过http://localhost:4000在浏览器中访问。后者是为了调试配置方便而使用，但是最终本地博客还是需要hexo deploy指令将其部署至Github上。接下来就是查看是否成功啦。打开浏览器输入IP地址。 图2 表明创建成功了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《WEB开发-HEXO博客搭建》第二章Hexo的博客配置]]></title>
    <url>%2F2019%2F08%2F25%2F%E3%80%8AWEB%E5%BC%80%E5%8F%91-HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0Hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[《WEB开发-HEXO博客搭建》第2章 Hexo博客配置Hexo官方Hexo官方(中文)Hexo主题Next 主题 图1 2.1 Hexo页面添加及设置默认有些页面是没有的，需要手动添加，进入博客文件夹，打开Git bash。 123$hexo new page &quot;categories&quot;$hexo new page &quot;tags&quot; $hexo new page &quot;about&quot; 编辑 tags/index.md 和categories/index.md和about/index.md分别添加如下内容： 12type: &quot;categories&quot;layout: &quot;categories&quot; 1234type: &quot;tags&quot;layout: &quot;tags&quot;type: &quot;about&quot;layout: &quot;about&quot; 主题的 _config.yml 文件中的 menu 中进行匹配。 123456menu: Home: / //主页 Archives: /archives //分类 categories: /categories //归档 tags: /tags //标签 about: /about //关于 2.2添加评论功能来必力官网： https://livere.com没有账号的注册账号，打开来必力官网： https://livere.com，点击上方的安装，选择免费的city版本。 图2 图3 点击【申请获得代码】，进入下一步操作。复制其中的uid字段。 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;MTAyMC8zNzMzMC8xMzg2NA==&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt;&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 图4 打开主题目录下的 blog/themes/某个主题/_config.yml 配置文件，定位到 livere_uid 字段，粘贴上刚刚复制的UID。 至此，大功告成。效果展示测试评论如图所示： 图5 2.3统计配置笔者使用的是不蒜子统计注意：此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后。 全局设置 编辑主题配置文件中的busuanzi_count的配置项。当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。  站点UV设置当site_uv: true时，代表在页面底部显示站点的UV值。site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_uv_header]UV值[site_uv_footer]。 //效果：本站访客数12345人次site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次  站点PV设置当site_pv: true时，代表在页面底部显示站点的PV值。site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_pv_header]PV值[site_pv_footer]。 //效果：本站总访问量12345次site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次  单页面PV配置当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。page_pv_header和page_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[page_pv_header]PV值[page_pv_footer]。 //效果：本文总阅读量12345次page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次 2.4搜索配置笔者使用的是Local Search，添加百度/谷歌/本地 自定义站点内容搜索。一、安装 hexo-generator-searchdb在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb —save 二、编辑站点配置文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 三、编辑主题配置文件，启用本地搜索功能 123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客之博客美化]]></title>
    <url>%2F2019%2F08%2F24%2FHexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Hexo 博客优化之博客美化（看板娘/鼠标点击爱心字体烟花爆炸/自定义鼠标指针样式/彩色滚动变换字体/背景音乐/网页标题恶搞/动态线条/人体时钟挂件/雪花飘落/背景动态彩带/背景代码雨……）转载自：链接：https://blog.csdn.net/qq_36759224/article/details/85420403 本文将讲述一些Hexo博客的美化，不同主题可能方法有些不同（本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例）实际效果欢迎访问我的博客：https://www.itrhx.com/ 进行查看，本文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 欢迎关注我的专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 推荐阅读：《Hexo 博客优化之实用功能添加（评论系统/字数统计/阅读时长/网站运行时间/百度统计/RSS订阅/Fork me on GitHub/更改本地预览端口号…）》 文章目录 ● 添加卡通人物（看板娘） ● 添加鼠标点击爱心效果 ● 添加鼠标点击显示字体效果 ● 添加鼠标点击烟花爆炸效果 ● 自定义鼠标指针样式 ● 添加彩色滚动变换字体 ● 添加背景音乐 ● 浏览器网页标题恶搞 ● 背景添加动态线条效果 ● 添加人体时钟等有趣的挂件 ● 添加网站雪花飘落效果 ● 添加背景动态彩带效果 ● 添加背景代码雨特效 未完待续…… ● 添加卡通人物（看板娘）我在逛别人博客的时候偶然发现右下角居然有一个萌萌的卡通人物，还能根据你鼠标位置摇头，瞬间被吸引到了，赶紧也给自己博客添加一个吧！点击此处进入该项目地址 输入如下命令获取 live2d ： 12$ npm install --save hexo-helper-live2d 1 输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请点击此处，各个模型的预览请访问原作者的博客 12$ npm install packagename1 打开站点目录下的 _config.yml 文件，添加如下代码： 123456789101112live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示1234567891011 设置好过后我们就拥有了一个卡通人物 ● 添加鼠标点击爱心效果在 /themes/hexo-theme-spfk/source/js 下新建文件 love.js，在 love.js 文件中添加以下代码： 12!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);1 在 \themes\hexo-theme-spfk\layout\layout.ejs 文件末尾添加以下代码： 123&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/love.js"&gt;&lt;/script&gt;12 完成以上操作后，当我们点击鼠标的时候就可以看见爱心的特效了 ● 添加鼠标点击显示字体效果在 /themes/hexo-theme-spfk/source/js 下新建文件 click_show_text.js，在 click_show_text.js 文件中添加以下代码： 12345678910111213141516171819202122232425262728293031323334var a_idx = 0;jQuery(document).ready(function($) &#123; $("body").click(function(e) &#123; var a = new Array ("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"); var $i = $("&lt;span/&gt;").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; "z-index": 5, "top": y - 20, "left": x, "position": "absolute", "font-weight": "bold", "color": "#FF0000" &#125;); $("body").append($i); $i.animate(&#123; "top": y - 180, "opacity": 0 &#125;, 3000, function() &#123; $i.remove(); &#125;); &#125;); setTimeout('delay()', 2000);&#125;);function delay() &#123; $(".buryit").removeAttr("onclick");&#125;123456789101112131415161718192021222324252627282930313233 其中的社会主义核心价值观可以根据你自己的创意替换为其他文字，然后在 \themes\hexo-theme-spfk\layout\layout.ejs 文件末尾添加以下代码： 123&lt;!--单击显示文字--&gt;&lt;script type="text/javascript" src="/js/click_show_text.js"&gt;&lt;/script&gt;12 最终实现效果如下： ● 添加鼠标点击烟花爆炸效果在 \themes\material-x\source\js 目录下新建一个 fireworks.js 的文件，里面写入以下代码： 12"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;;1 然后在 \themes\material-x\layout\layout.ejs 文件中写入以下代码： 1234&lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/fireworks.js"&gt;&lt;/script&gt;123 最终效果： ● 自定义鼠标指针样式在 \themes\material-x\source\less_base.less 文件 body 样式里写入如下代码： 1234567body &#123; cursor: url(https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur),auto; background-color: @theme_background; ...... ......&#125;123456 鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读参考文档或者参考以下兼容表： 浏览器 最低版本 格式 Internet Explorer 6.0 .cur / .ani Firefox (Gecko), Windows and Linux 1.5 (1.8) .cur / .png / .gif / .jpg Firefox (Gecko) 4.0 (2.0) .cur / .png / .gif / .jpg / .svg Opera — — Safari (Webkit) 3.0 (522-523) .cur / .png / .gif / .jpg 拓展阅读：《CSS 鼠标样式 cursor属性》 （By：歪脖先生的博客） ● 添加彩色滚动变换字体在你想要添加彩色滚动变换字体的地方写入以下代码即可，其中文字可自行更改： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id="binft"&gt;&lt;/div&gt; &lt;script&gt; var binft = function (r) &#123; function t() &#123; return b[Math.floor(Math.random() * b.length)] &#125; function e() &#123; return String.fromCharCode(94 * Math.random() + 33) &#125; function n(r) &#123; for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) &#123; var l = document.createElement("span"); l.textContent = e(), l.style.color = t(), n.appendChild(l) &#125; return n &#125; function i() &#123; var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) &#125; var l = "", o = ["青青陵上柏，磊磊涧中石。", "人生天地间，忽如远行客。","斗酒相娱乐，聊厚不为薄。", "驱车策驽马，游戏宛与洛。","洛中何郁郁，冠带自相索。","长衢罗夹巷，王侯多第宅。","两宫遥相望，双阙百余尺。","极宴娱心意，戚戚何所迫？"].map(function (r) &#123; return r + "" &#125;), a = 2, g = 1, s = 5, d = 75, b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"], c = &#123; text: "", prefixP: -s, skillI: 0, skillP: 0, direction: "forward", delay: a, step: g &#125;; i() &#125;; binft(document.getElementById('binft')); &lt;/script&gt;123456789101112131415161718192021222324252627282930313233343536373839404142 最终效果： ● 添加背景音乐打开网页版网易云音乐，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，复制底下的HTML代码 然后将此代码放到你想要放的地方，比如放在博客的左侧，则打开 \themes\hexo-theme-spfk\layout_partial\left-col.ejs 文件，将复制的HTML代码粘贴进去，再进行适当的位置设置让播放器更美观，其中 auto=1 表示打开网页自动播放音乐，auto=0 表示关闭自动播放音乐 最后效果如下：这种网易云音乐外链的方式有很多局限性，因此推荐使用aplayer，GitHub地址为：https://github.com/MoePlayer/APlayer ，参考教程：《hexo上的aplayer应用》 ● 浏览器网页标题恶搞当用户访问你的博客时点击到了其他网页，我们可以恶搞一下网页标题，呼唤用户回来，首先在目录 \Hexo\themes\hexo-theme-spfk\source\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 123456789101112131415161718&lt;!--浏览器搞笑标题--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/trhx2.png"); document.title = 'ヽ(●-`Д´-)ノ你丑你就走！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/img/trhx2.png"); document.title = 'ヾ(Ő∀Ő3)ノ你帅就回来！' + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;);1234567891011121314151617 然后在 \Hexo\themes\hexo-theme-spfk\layout\layout.ejs 文件中添加如下代码： 123&lt;!--浏览器搞笑标题--&gt;&lt;script type="text/javascript" src="\js\FunnyTitle.js"&gt;&lt;/script&gt;12 再次部署博客后就可以看见标题搞笑的效果了： ● 背景添加动态线条效果在 \Hexo\themes\hexo-theme-spfk\layout\layout.ejs 文件中添加如下代码： 12345&lt;!--动态线条背景--&gt;&lt;script type="text/javascript"color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;1234 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 最终实现效果： ● 添加人体时钟等有趣的挂件无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，点击此处访问作者博客，点击此处在作者原博客上查看动态样式，点击此处查看动态大图，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的 实现代码： 123456&lt;!--人体时钟背景透明--&gt;&lt;script charset="Shift_JIS" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js"&gt;&lt;/script&gt;&lt;!--人体时钟背景白--&gt;&lt;script charset="Shift_JIS" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js"&gt;&lt;/script&gt;12345 其他网页小挂件推荐： http://abowman.com/ 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用 http://www.revolvermaps.com/ 它提供网站访客地理信息，可以以2D、3D等形式显示 http://www.amazingcounters.com/ 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数 https://www.seniverse.com/widget/get 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览 ● 添加网站雪花飘落效果样式一和样式二分别如下： 实现方法：在 \Hexo\themes\hexo-theme-spfk\source\js 目录下新建一个 snow.js 文件，粘贴以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/*样式一*/(function($)&#123; $.fn.snow = function(options)&#123; var $flake = $('&lt;div id="snowbox" /&gt;').css(&#123;'position': 'absolute','z-index':'9999', 'top': '-50px'&#125;).html('&amp;#10052;'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = &#123; minSize : 10, maxSize : 20, newOn : 1000, flakeColor : "#AFDAEF" /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ &#125;, options = $.extend(&#123;&#125;, defaults, options); var interval= setInterval( function()&#123; var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css(&#123; left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor &#125;).animate(&#123; top: endPositionTop, left: endPositionLeft, opacity: 0.2 &#125;,durationFall,'linear',function()&#123; $(this).remove() &#125;); &#125;, options.newOn); &#125;;&#125;)(jQuery);$(function()&#123; $.fn.snow(&#123; minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ &#125;);&#125;);123456789101112131415161718192021222324252627282930313233343536373839404142/*样式二*//* 控制下雪 */function snowFall(snow) &#123; /* 可配置属性 */ snow = snow || &#123;&#125;; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function()&#123; /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123; /* 添加Dom结点 */ var snowcanvas = document.createElement("canvas"); snowcanvas.id = "snowfall"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute("style", "position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;"); document.getElementsByTagName("body")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext("2d"); /* 窗口大小改变的处理 */ window.onresize = function() &#123; snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123; this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function() &#123; var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) &#123; this.velY = this.speed &#125; this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123; this.reset(canvas.width, canvas.height) &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) &#123; this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) &#123; var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, "rgba(255, 255, 255, 0.9)"); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, "rgba(255, 255, 255, 0.5)"); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, "rgba(255, 255, 255, 0)"); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123; var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) &#123; flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) &#125;&#125;/* 画雪 */function drawSnow() &#123; var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) &#123; flakes[e].update(); flakes[e].render(ctx); &#125; /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() &#123; drawSnow.apply(that); &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;maxFlake:60&#125;);snow.start();123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 然后在 \Hexo\themes\hexo-theme-spfk\layout\layout.ejs 文件里引用即可： 123&lt;!-- 雪花特效 --&gt;&lt;script type="text/javascript" src="\js\snow.js"&gt;&lt;/script&gt;12 如果没效果，请确认网页是否已载入JQurey，如果没有请在下雪代码之前引入JQ即可： 123&lt;script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.min.js"&gt;&lt;/script&gt;12 原文链接：《分享两种圣诞节雪花特效JS代码(网站下雪效果)》 ● 添加背景动态彩带效果样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带： 实现方法：在 \themes\material-x\layout\layout.ejs 文件的body前面添加如下代码： 123456&lt;!-- 样式一（鼠标点击更换样式） --&gt;&lt;script src=&quot;https://g.joyinshare.com/hc/ribbon.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;12&lt;!-- 样式二（飘动的彩带） --&gt;&lt;script src=&quot;https://g.joyinshare.com/hc/piao.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;12 ● 添加背景代码雨特效新建 DigitalRain.js，写入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758window.onload = function()&#123; //获取画布对象 var canvas = document.getElementById("canvas"); //获取画布的上下文 var context =canvas.getContext("2d"); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++)&#123; drops.push(0); &#125; //运动的文字 var str ="WELCOME TO WWW.ITRHX.COM"; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw()&#123; context.fillStyle = "rgba(238,238,238,.08)";//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = "600 "+fontSize+"px Georgia"; //给字体添加颜色 context.fillStyle = ["#33B5E5", "#0099CC", "#AA66CC", "#9933CC", "#99CC00", "#669900", "#FFBB33", "#FF8800", "#FF4444", "#CC0000"][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++)&#123; var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99)&#123; drops[i] = 0; &#125; drops[i]++; &#125; &#125;; function randColor()&#123;//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return "rgb("+r+","+g+","+b+")"; &#125; draw(); setInterval(draw,35);&#125;;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\themes\material-x-1.2.1\source\less_main.less 文件末尾）添加以下代码： 1234567891011canvas &#123; position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;&#125;12345678910 然后在主题的 layout.ejs 文件中引入即可： 1234 &lt;!-- 数字雨 --&gt; &lt;canvas id="canvas" width="1440" height="900" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="/js/DigitalRain.js"&gt;&lt;/script&gt;123 最终效果：代码来源：http://www.lxl8800.cn/Main/Resource 未完待续…]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客的背景设置]]></title>
    <url>%2F2019%2F08%2F24%2Fhexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo博客的背景设置主要有以下30种： 在右上角或者左上角实现fork me on github 添加RSS 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改“代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加网易云跟帖(跟帖关闭，已失效，改为来必力) 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 1. 在右上角或者左上角实现fork me on github实现效果图 具体实现方法 点击这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码： 然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 2.添加RSS实现效果图 具体实现方法 切换到你的blog（我是取名blog，具体的看你们的取名是什么）的路径，例如我是在/Users/chenzekun/Code/Hexo/blog这个路径上，也就是在你的根目录下 然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里) 1$ npm install --save hexo-generator-feed 1 1 接下来打开画红线的文件，如下图： 在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) 123456789# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 12345678910111213# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 配置完之后运行： 1$ hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 3. 添加动态背景实现效果图 具体实现方法 这个我之前有一篇文章有讲过了，详情点击我的博客 4. 实现点击出现桃心效果实现效果图 具体实现方法 在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12345&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 5. 修改文章内链接文本样式实现效果图 具体实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011121314151617181920212223242526272829303132333435363738394041// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 6. 修改文章底部的那个带#号的标签实现效果图 具体实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 7. 在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 1234567891011121314151617&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 1234567891011121314151617&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123456789# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 8. 修改作者头像并旋转实现效果图 具体实现方法 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125; img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; /* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 9. 博文压缩在站点的根目录下执行以下命令： 12345$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在如下图所示，新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 10. 修改“代码块自定义样式实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 11. 侧边栏社交小图标设置实现效果图 具体实现方法 打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 12. 主页文章添加阴影效果实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 1234567891011121314151617181920212223242526272829// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 13. 在网站底部加上访问量实现效果图 具体实现方法 打开\themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话： 代码如下： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图： 代码如下： 1234567891011121314151617&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： \1. pv的方式，单个用户连续点击n篇文章，记录n次访问量 123456789&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123456789&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 14. 添加热度实现效果图 具体实现方法 next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了 15. 网站底部字数统计实现效果图 具体方法实现 切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 1 1 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 12345678910111213&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 16. 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为 1skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 17. 设置网站的图标Favicon实现效果图 具体方法实现 在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12345# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 18. 实现统计功能实现效果图 具体实现方法 在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456789101112131415161718192021# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 19. 添加顶部加载条实现效果图 具体实现方法 打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码 代码如下： 12345&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 1 2 1 2 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 目前，博主的增加顶部加载条的pull request 已被Merge��===&gt;详情 现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图： 20. 在文章底部增加版权信息实现效果图 在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); clipboard.on(&apos;success&apos;, $(function()&#123; $(&quot;.fa-clipboard&quot;).click(function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 1234567891011121314151617&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 1234567891011121314151617&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot; 保存重新生成即可。 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： 这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去 (注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 21. 添加网易云跟帖(跟帖关闭，已失效，改为来必力)实现效果图 具体方法实现 有两种实现方法： ①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置: 1gentie_productKey: #your-gentie-product-key ②如果你不想更新的话，那么按下面步骤进行： 首先，还是在主题配置文件_config.yml 文件中添加如下配置: 1gentie_productKey: #your-gentie-product-key 你的productKey就是下面画红线部分 然后在在layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: &quot;&quot;, productKey: &quot;&#123;&#123;gentie_productKey&#125;&#125;&quot;, target: &quot;cloud-tie-wrapper&quot; &#125;; &lt;/script&gt; &lt;script src=&quot;https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include &apos;./comments/gentie.swig&apos; %&#125; 1 1 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 123456789&#123;% elseif theme.gentie_productKey %&#125; &lt;div id=&quot;cloud-tie-wrapper&quot; class=&quot;cloud-tie-wrapper&quot;&gt; &lt;/div&gt; 具体位置如下： 可能你hexo s时可能看不到，直接hexo d就可以看到了 近日，我朋友发来消息，说网易云跟帖要关了，我网上查了一下，果然如此 ��都是泪,上次用了多说，结果多说关了，接着是网易云跟帖��，这次直接用国外的来必力，应该不会这么容易关吧�� 方法其实还是跟上面差不多的 首先在 _config.yml 文件中添加如下配置： 123456789# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid 其中，livere_uid就是画红线的部分 然后在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在 layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include &apos;./comments/livere.swig&apos; %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加 LiveRe 插件是否引用的判断逻辑： 123456789&#123;% elseif theme.livere_uid %&#125; &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&#123;&#123; theme.livere_uid &#125;&#125;&quot;&gt;&lt;/div&gt;&#123;% endif %&#125; 完 22. 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： 23. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 24. 文章加密访问实现效果图 具体实现方法 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 25. 添加jiathis分享在主题配置文件中，jiathis为true，就行了，如下图 默认是这样子的： 如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了 26. 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如 1234567891011121314151617181920212223242526272829---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 27. 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示： 1$font-size-base =16px 28. 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 29. 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接): 1234567891011121314151617181920212223242526272829303132333435363738394041# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 30. 自定义鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码 12345678910111213141516171819202122232425// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 其中 url 里面必须是 ico 图片，ico 图片可以上传到网上（我是使用七牛云图床），然后获取外链，复制到 url 里就行了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo博客的背景设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis入门，读这一篇就够了]]></title>
    <url>%2F2019%2F08%2F23%2FRedis%E5%85%A5%E9%97%A8%EF%BC%8C%E8%AF%BB%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[目录 一. redis 1.1.什么是NOSQL 1.1.1. NOSQL和关系型数据库比较 1.1.2. 非关系型数据库的优势： 1.1.3. 关系型数据库的优势： 1.1.4. 总结 1.2.主流的NOSQL产品 1.3 什么是Redis 1.3.1 redis的应用场景(重要) 二. 下载安装 三. 命令操作 1. redis的数据结构： 2. 字符串类型 string 3. 哈希类型 hash 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 5. 集合类型 set ： 不允许重复元素 6. 有序集合类型 sortedset： 7. 通用命令 四. 持久化 五. Java客户端 Jedis 六. 案例： 一. redis**概念**： redis是一款高性能的NOSQL系列的非关系型数据库1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较**优点：** 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关 系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql 数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 ​ 缺点： 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 1） 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候 使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在 nosql 数据库中备份存储关系型数据库的数据1.2.主流的NOSQL产品• 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset1.3.1 redis的应用场景(重要)• 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离二. 下载安装1. [官网](https://redis.io) 2. [Redis中文网](http://www.redis.net.cn/) 3. 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端三. 命令操作1. redis的数据结构： redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构： 字符串类型 string 哈希类型 hash ： map格式 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 13. 哈希类型 hash**1. 存储**： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 **2. 获取**： hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; **3. 删除**： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 14. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素**1. 存储**：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 **2. 获取**：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; **3. 删除**：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 16. 有序集合类型 sortedset：​ 不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 ​ 1. 存储：zadd key score value​ 127.0.0.1:6379&gt; zadd mysort 60 zhangsan​ (integer) 1​ 127.0.0.1:6379&gt; zadd mysort 50 lisi​ (integer) 1​ 127.0.0.1:6379&gt; zadd mysort 80 wangwu​ (integer) 1​ 2. 获取：zrange key start end [withscores]​ 127.0.0.1:6379&gt; zrange mysort 0 -1​ 1) “lisi”​ 2) “zhangsan”​ 3) “wangwu” ​ 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores​ 1) “zhangsan”​ 2) “60”​ 3) “wangwu”​ 4) “80”​ 5) “lisi”​ 6) “500”​ 3. 删除：zrem key value​ 127.0.0.1:6379&gt; zrem mysort lisi​ (integer) 1 7. 通用命令1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value四. 持久化1. redis是一个内存数据库​ 当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制：1. RDB：默认方式，不需要进行配置，默认就使用这种机制在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 after 900 sec (15 min) if at least 1 key changed save 900 1 after 300 sec (5 min) if at least 10 keys changed save 300 10 after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） \# appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 \# appendfsync no ： 不进行持久化五. Java客户端 Jedis​ Jedis: 一款java操作redis数据库的工具.​ 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(“localhost”,6379); //2. 操作 jedis.set(“username”,”zhangsan”); //3. 关闭连接 jedis.close(); ​ Jedis操作各种redis中的数据结构​ 1) 字符串类型 string​ set​ get​​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ //存储​ jedis.set(“username”,”zhangsan”);​ //获取​ String username = jedis.get(“username”);​ System.out.println(username);​​ //可以使用setex()方法存储可以指定过期时间的 key value​ jedis.setex(“activecode”,20,”hehe”);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对​​ //3. 关闭连接​ jedis.close(); ​ 2) 哈希类型 hash ： map格式​ hset​ hget​ hgetAll​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ // 存储hash​ jedis.hset(“user”,”name”,”lisi”);​ jedis.hset(“user”,”age”,”23”);​ jedis.hset(“user”,”gender”,”female”);​​ // 获取hash​ String name = jedis.hget(“user”, “name”);​ System.out.println(name);​​​ // 获取hash的所有map中的数据​ Map&lt;String, String&gt; user = jedis.hgetAll(“user”);​​ // keyset​ Set keySet = user.keySet();​ for (String key : keySet) {​ //获取value​ String value = user.get(key);​ System.out.println(key + “:” + value);​ }​​ //3. 关闭连接​ jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​​​ // set 存储​ jedis.sadd(“myset”,”java”,”php”,”c++”);​​ // set 获取​ Set myset = jedis.smembers(“myset”);​ System.out.println(myset);​​ //3. 关闭连接​ jedis.close();​ 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序​ zadd​ zrange ​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ // sortedset 存储​ jedis.zadd(“mysortedset”,3,”亚瑟”);​ jedis.zadd(“mysortedset”,30,”后裔”);​ jedis.zadd(“mysortedset”,55,”孙悟空”);​​ // sortedset 获取​ Set mysortedset = jedis.zrange(“mysortedset”, 0, -1);​​ System.out.println(mysortedset);​​​ //3. 关闭连接​ jedis.close(); jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils {​ private static JedisPool jedisPool;​​ static{​ //读取配置文件​ InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(“jedis.properties”);​ //创建Properties对象​ Properties pro = new Properties();​ //关联文件​ try {​ pro.load(is);​ } catch (IOException e) {​ e.printStackTrace();​ }​ //获取数据，设置到JedisPoolConfig中​ JedisPoolConfig config = new JedisPoolConfig();​ config.setMaxTotal(Integer.parseInt(pro.getProperty(“maxTotal”)));​ config.setMaxIdle(Integer.parseInt(pro.getProperty(“maxIdle”)));​​ //初始化JedisPool​ jedisPool = new JedisPool(config,pro.getProperty(“host”),Integer.parseInt(pro.getProperty(“port”)));​​​​ }​​​ /*​ \ 获取连接方法​ */​ public static Jedis getJedis(){​ return jedisPool.getResource();​ }​ } 六. 案例：​ 案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 注意：使用redis缓存一些不经常发生变化的数据。* 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。]]></content>
      <categories>
        <category>非关系型数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、Spring Boot配置文件详解：Properties和YAML]]></title>
    <url>%2F2019%2F08%2F23%2F%E4%BA%8C%E3%80%81Spring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%EF%BC%9AProperties%E5%92%8CYAML%2F</url>
    <content type="text"><![CDATA[Spring Boot配置文件详解：Properties和YAML一.配置文件的生效顺序，会对值进行覆盖： @TestPropertySource 注解 命令行参数 Java系统属性（System.getProperties()） 操作系统环境变量 只有在random.*里包含的属性会产生一个RandomValuePropertySource 在properties文件中设置随机值，随机数等 123456789101112131415161718192021222324252627#这个优先级较低#32位随机字符串roncoo.secret=$&#123;random.value&#125;#int类型的随机数字roncoo.number=$&#123;random.int&#125;roncoo.name=www.roncoo.com#属性占位符属性roncoo.desc=$&#123;roncoo.name&#125; is a domain name#应用端口server.port=8090#时间格式化spring.jackson.date-format=yyyy-MM-dd HH:mm:ss#时区设置spring.jackson.time-zone=Asia/Chongqing 在IndexController层中获取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.roncoo.education.controller;import java.util.Date;import java.util.HashMap;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.roncoo.education.bean.User;/** * spring-boot-demo-3-1 * * @author wujing */@RestController@RequestMapping(value = "/index")public class IndexController &#123; @Value(value = "$&#123;roncoo.secret&#125;") private String secret; @Value(value = "$&#123;roncoo.number&#125;") private int id; @Value(value = "$&#123;roncoo.desc&#125;") private String desc; @RequestMapping public String index() &#123; return "hello world"; &#125; // @RequestParam 简单类型的绑定，可以出来get和post @RequestMapping(value = "/get") public HashMap&lt;String, Object&gt; get(@RequestParam String name) &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("title", "hello world"); map.put("name", name); map.put("secret", secret); map.put("id", id); map.put("desc", desc); return map; &#125; // @PathVariable 获得请求url中的动态参数 @RequestMapping(value = "/get/&#123;id&#125;/&#123;name&#125;") public User getUser(@PathVariable int id, @PathVariable String name) &#123; User user = new User(); user.setId(id); user.setName(name); user.setDate(new Date()); return user; &#125;&#125; 二．配置随机值roncoo.secret=${random.value} roncoo.number=${random.int} roncoo.bignumber=${random.long} roncoo.number.less.than.ten=${random.int(10)} roncoo.number.in.range=${random.int[1024,65536]} 读取使用注解：@Value(value = “${roncoo.secret}”) 注：出现黄点提示，是要提示配置元数据，可以不配置 在打包的jar外的应用程序配置文件（application.properties，包含YAML和profile变量） 在打包的jar内的应用程序配置文件（application.properties，包含YAML和profile变量） 在@Configuration类上的@PropertySource注解 默认属性（使用SpringApplication.setDefaultProperties指定） 三．属性占位符当application.properties里的值被使用时，它们会被存在的Environment过滤，所以你能够引用先前定义的值（比如，系统属性）。 roncoo.name=www.roncoo.com roncoo.desc=${roncoo.name} is a domain name 四．Application属性文件，按优先级排序，位置高的将覆盖位置低的 当前目录下的一个/config子目录 当前目录 一个classpath下的/config包 classpath根路径（root） 这个列表是按优先级排序的（列表中位置高的将覆盖位置低的） 五. 配置应用端口和其他配置的介绍#端口配置： server.port=8090 #时间格式化 spring.jackson.date-format=yyyy-MM-dd HH:mm:ss #时区设置 spring.jackson.time-zone=Asia/Chongqing 六. 使用YAML代替Properties注意写法：冒号后要加个空格]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章，教你学会Git]]></title>
    <url>%2F2019%2F08%2F23%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E6%95%99%E4%BD%A0%E5%AD%A6%E4%BC%9AGit%2F</url>
    <content type="text"><![CDATA[一篇文章，教你学会Git 在日常工作中，经常会用到Git操作。但是对于新人来讲，刚上来对Git很陌生，操作起来也很懵逼。本篇文章主要针对刚开始接触Git的新人，理解Git的基本原理，掌握常用的一些命令。 一、Git工作流程 以上包括一些简单而常用的命令，但是先不关心这些，先来了解下面这4个专有名词。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 工作区 程序员进行开发改动的地方，是你当前看到的，也是最新的。 平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。 暂存区 .git目录下的index文件, 暂存区会记录git add添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用git status查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。 当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过git add先提交到暂存区，被git管理。 本地仓库 保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。 git commit后同步index的目录树到本地仓库，方便从下一步通过git push同步本地仓库与远程仓库的同步。 远程仓库 远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。 小结 任何对象都是在工作区中诞生和被修改； 任何修改都是从进入index区才开始被版本控制； 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹； 与协作者分享本地的修改，可以把它们push到远程仓库来共享。 下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。 二、常用Git命令 网上找了个图，别人整理的一张图，很全很好，借来用下。下面详细解释一些常用命令。 HEAD 在掌握具体命令前，先理解下HEAD。 HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。 add add相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。 git add . 添加当前目录的所有文件到暂存区 git add 添加指定目录到暂存区，包括子目录 git add 添加指定文件到暂存区 commit commit相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。 git commit -m 提交暂存区到本地仓库,message代表说明信息 git commit -m 提交暂存区的指定文件到本地仓库 git commit –amend -m 使用一次新的commit，替代上一次提交 branch 涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 git branch 新建一个分支，但依然停留在当前分支 git checkout -b 新建一个分支，并切换到该分支 git branch –track 新建一个分支，与指定的远程分支建立追踪关系 git checkout 切换到指定分支，并更新工作区 git branch -d 删除分支 git push origin –delete 删除远程分支 关于分支的操作虽然比较多，但都比较简单好记。 merge merge命令把不同的分支合并起来。如上图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。 git fetch merge之前先拉一下远程仓库最新代码 git merge 合并指定分支到当前分支 一般在merge之后，会出现conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。如下图所示，需要手动解除。 rebase rebase又称为衍合，是合并的另外一种选择。 在开始阶段，我们处于new分支上，执行git rebase dev，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。git rebase dev，通俗的解释就是new分支想站在dev的肩膀上继续下去。rebase也需要手动解决冲突。 rebase与merge的区别 现在我们有这样的两个分支,test和master，提交如下： 123456789D---E test /A---B---C---F master 在master执行git merge test,然后会得到如下结果： 123456789D--------E / \A---B---C---F----G test, master 在master执行git rebase test，然后得到如下结果： 1A---B---D---E---C&apos;---F&apos; test, master 可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。 如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge reset reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。 git reset —soft 只改变提交点，暂存区和工作目录的内容都不改变 git reset —mixed 改变提交点，同时改变暂存区的内容 git reset —hard 暂存区、工作区的内容都会被修改到与提交点完全一致的状态 git reset –hard HEAD 让工作区回到上次提交时的状态 revert git revert用一个新提交来消除一个历史提交所做的任何修改。 revert与reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 push上传本地仓库分支到远程仓库分支，实现同步。 git push 上传本地指定分支到远程仓库 git push –force 强行推送当前分支到远程仓库，即使有冲突 git push –all 推送所有分支到远程仓库 其他命令 git status 显示有变更的文件 git log 显示当前分支的版本历史 git diff 显示暂存区和工作区的差异 git diff HEAD 显示工作区与当前分支最新commit之间的差异 git cherry-pick 选择一个commit，合并进当前分支 以上就是关于Git的一些常用命令及详细阐述，相信能对Git有一个初步的认识。]]></content>
      <categories>
        <category>Git管理工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot RESTfull API简单项目的快速搭建]]></title>
    <url>%2F2019%2F08%2F23%2F%E4%B8%80%E3%80%81Spring%20Boot%20RESTfull-API%E7%AE%80%E5%8D%95%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Spring Boot RESTfull API简单项目的快速搭建对spring框架盛行了多年的java方向开发人员来说，每个人java开发已经把spring框架当做开发中不可或缺的一部分。之前传统的模式都是以applicationContext.xml配置文件的形式存在，而对应大多数入门级开发人员来说配置出现一点纰漏就会导致运行失败或者更大的问题，因此会浪费开发人员很多宝贵的时间，对公司来说也是有所损失。那么spring开源组织很早之前就意识到这种问题的存在，于是他们便对spring框架的全系列组件进行了内部封装。对外只是提供maven（jar管理、项目打包工具）或者gradle（新兴jar管理、项目打包工具）的形式来进行引入parent.pom（maven配置文件）或者parent.gradle（gradle配置文件），让每一个spring项目都是以spring的子项目的形式来运行，这样开发人员不用再去注重配置文件的繁琐而是把精力放到业务逻辑以及更深层次的架构方面。自此SpringBoot就诞生了，它有着纯正的开源血统，在此非常感谢spring开源组织给我们java开发人员带来的便利！ SpringBoot主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 提供一系列大型企业级项目的功能性特性（比如：安全、健康检测、外部化配置、数据库访问、restful搭建等很多特性这里就不一一叙说了，后期文章会陆续更新） 本章目的使用springboot完成一个简单的web（springmvc）应用程序，通过@restController输出”HelloWord”到界面，让我们初步体验springboot的快速开发、简单的特性。 系统要求 jdk1.8 springboot 1.5.2.RELEASE 开发工具（IntelliJ IDEA 2017.1.1） 数据库管理工具（Navicat Premium 11.1.7） 文本管理工具（sublime text 3） apache maven（3.3.9，本章采用maven形式管理jar包，具体配置环境变量以及使用请自行查找资料） 开始构建项目目前构建项目有多种方式我这里简单介绍两种。1、使用spring官网 SPRING INITIALIZR 来构建项目结构（地址：http://start.spring.io/）2、使用IntelliJ IDEA开发工具来构建项目结构 使用SPRING INITIALIZR构建访问start.spring.io/网址就会看到如下 “图1” 界面：界面主要部分包括：管理工具，springboot版本，包名（group），工程名（Artifact），已选模块（我已经选择了一个web模块）。点击Generate Project就会下载一个根据你输入的信息创建的项目工程架构源码的压缩包。解压压缩包到指定目录（目录你可以随意定义）我这里为了后续操作先定义到E:/lessions内可以看到如下“图2”所示：解压完成之后我们就可以通过IntelliJ IDEA开发工具导入到工程， 菜单中选择File–&gt;New–&gt;Project from Existing Sources… 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 若你的环境有多个版本的JDK，注意到选择Java SDK的时候请选择系统安装1.8版本 使用IntelliJ IDEA构建打开工具，界面如下 “图3” 所示：我们点击Create New Project来创建一个新的springboot应用程序，点击后如下“图4”所示：我们点击Next继续下一步操作，根据界面输入选项填写对应的内容即可如“图5”所示：点击Next即可完成创建项目，而且创建完成后会自动导入到项目工程内就不需要再次import操作，这种方式会比较简单些，所以我们的文章内都会采用第二种形式来创建新工程。 在下一步我们勾选Web依赖加入到我们的项目中，如下图所示： 项目目录结构我们来看看工具为我们生成新工程的目录结构，如”图6“所示：我们可以看到目录结构有如下几个： 1、/src/main/java/ 存放项目所有源代码目录2、/src//main/resources/ 存放项目所有资源文件以及配置文件目录3、/src/test/ 存放测试代码目录 自动生成的文件解释SpringBoot21Application 该类是程序的入口类内有个main方法，可以直接通过run as运行项目application.properties 该配置文件是项目的核心配置文件，以xx.xx.xx的形式存在pom.xml maven配置文件，因为我们采用的maven管理jar，所以这里会自动生成一个pom文件 @SpringBootApplication注解我们可以看到工具为我们自动生成的入口程序是有@SpringBootApplication的这么一个注解，那它主要是做什么的呢？不难看出，它是声明当前类为sprinboot的入口类。而一个springboot项目内有且只能有一个这个注解存在。 初尝试运行项目我们在入口程序类中右键-&gt;Run LessonOneApplication在控制台的输出如下”图8“所示，证明你已经成功的运行了springboot项目。 可以看到我们的项目是通过内置的tomcat容器启动的，并且端口号默认是8080（至于如何修改端口号后期文章中更新）。我们现在通过浏览器直接访问是得不到任何回应的，只是会有一个错误页面，如下”图9“所示 编写IndexController我们首先在/src/main/java/com/lqg (该目录是你构建项目的目录) 目录下创建一个叫做controller的包，然后在controller包下再创建一个叫做IndexController的类，我们使用@RestController来声明我们新创建的IndexController是一个访问控制器,详细代码如下： 1234567891011121314package com.lqg.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String index()&#123; return "hello spring boot"; &#125;&#125;12345678910111213 可以看到我在IndexController类上配置了一个@RequestMapping注解来声明index()方法可以通过127.0.0.1:8080/index访问到，那么我们接下来重新启动项目（项目中如果重启出错应该是注解配置问题），访问地址如下”图10“所示：在IndexController类里面在写一个方法，返回值是map集合，参数列表是String类型的name，@RequestParam简单类型的绑定的注解，这个注解要放在参数列表的前面 1234567891011121314151617181920212223242526272829303132package com.lqg.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String hello()&#123; return "hello spring boot "; &#125; /** * @RequestParam 简单类型的绑定，可以出来get和post * @param name * @return */ @RequestMapping(value = "/get") public HashMap&lt;String,Object&gt; get(@RequestParam String name)&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("title", "hello world"); map.put("name", name); return map; &#125;&#125;12345678910111213141516171819202122232425262728293031 那么Controller层是如何返回一个Bean对象呢？先在/src/main/java/com/lqg下面创建一个bean包，在bean包里创建一个User类，详细代码如下： 1234567891011121314151617181920package com.lqg.bean;import lombok.Getter;import lombok.Setter;import java.util.Date;/** * @author 凌枫lqg */@Getter@Setterpublic class User &#123; private int id; private String name; private Date date;&#125;12345678910111213141516171819 @Getter@Setter：注解是lombok插件里面的，用这个注解就可以省略getter和setter方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lqg.controller;import com.lqg.bean.User;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.xml.crypto.Data;import java.util.Date;import java.util.HashMap;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String hello()&#123; return "hello spring boot "; &#125; /** * @RequestParam 简单类型的绑定，可以出来get和post * @param name * @return */ @RequestMapping(value = "/get") public HashMap&lt;String,Object&gt; get(@RequestParam String name)&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("title", "hello world"); map.put("name", name); return map; &#125; /** * @PathVariable 获得请求url中的动态参数 * @param id * @param name * @return */ @RequestMapping(value = "/find/&#123;id&#125;/&#123;name&#125;") public User get(@PathVariable int id,@PathVariable String name)&#123; User user = new User(); user.setId(id); user.setName(name); user.setDate(new Date()); return user; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 第二个方法访问的结果如下第三个方法访问的结果如下： SpringBoot的测试SpringBoot测试可以通过Spring提供的测试类MockMvc 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lqg;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import com.lqg.controller.IndexController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import com.lqg.controller.IndexController;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootDemo21ApplicationTests &#123; //SpringBoot测试可以通过Spring提供的测试类MockMvc private MockMvc mvc; @Before public void setup() &#123; //这是通过setup方法引入mvc this.mvc = MockMvcBuilders.standaloneSetup(new IndexController()).build(); &#125; @Test public void contextLoads() throws Exception &#123; //生成request一个请求 RequestBuilder request = get("/index"); //用mvc的请求，期望它的状态码是ok的，期望它返回的内容，返回的是一个字符串hello spring boot mvc.perform(request).andExpect(status().isOk()).andExpect(content().string("hello spring boot")); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940 SpringBoot打包 打包成功后的jar包，打包命令mvn clean install -DskipTests 在命令行运行spring boot]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea中如何导入mysql驱动包]]></title>
    <url>%2F2019%2F08%2F23%2Fidea%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5mysql%E9%A9%B1%E5%8A%A8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[IDEA怎样导入mysql的驱动包注：刚开始用用csdn写博文，写的不好，还请各位博客好友见谅，也可以互相提意见，共同进步！首先需要有mysql的驱动包，没有可以在mysql官网下载 有了驱动包后，就开始进入怎样用IDEA导入mysql驱动包了 1. 打开你的idea工程，点击File2.找到Project Structure并点击3.找到Modules并点击4.找到Dependencies并点击2.找到Project Structure并点击5.找到Scope右边的+号并点击2.选第一个JARs or directories，找到文件mysql-connector-java-版本号-bin.jar，然后点击ok就成功了]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019最新的解决百度网盘下载限速的方法，不限速下载百度云破解版]]></title>
    <url>%2F2019%2F08%2F23%2F2019%E6%9C%80%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%B8%8B%E8%BD%BD%E9%99%90%E9%80%9F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%99%90%E9%80%9F%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E4%BA%91%E7%A0%B4%E8%A7%A3%E7%89%88%2F</url>
    <content type="text"><![CDATA[2019最新的解决百度网盘下载限速的方法，不限速下载百度云破解版下载地址，点击下载，提取码：c25f 永久有效https://pan.baidu.com/s/1G2X8diMTPzTyC_oOvgkyWw 不限速下载以下为软件使用教程，必看 软件使用教程：首先：在打开软件以后先观察是否弹出更新提示，如果有更新提示则必须要更新，一般选择在线自动更新。 第一步，把压缩包下载并解压到你的电脑上，但不要解压到C盘和桌面上。解压完成以后文件夹里的文件如图所示图中用红圈圈出来的文件就是运行的主程序第二步：点击红框中的文件会出现下图中的样子第三步：然后登陆自己的网盘账号以后开始下载情况1、下载自己网盘里的东西 登录之后找到你网盘里的想要下载的文件（不要直接点下载），点击“分享并下载”，然后再确认下载就OK了。 情况2、如果下载在别处获得的链接，请在“下载”栏目下面的“下载分享链接”处下载。如果出现无限验证码或其他错误也可以先保存到自己网盘，然后用1中的方法。软件非常好用，需要的同学可以点击下载了：链接：https://pan.baidu.com/s/1G2X8diMTPzTyC_oOvgkyWw&gt; 提取码：c25f 永久有效]]></content>
      <categories>
        <category>百度云</category>
      </categories>
      <tags>
        <tag>baiduyun</tag>
      </tags>
  </entry>
</search>
