<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F22%2FRESTfull%20API%E7%AE%80%E5%8D%95%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[RESTfull API简单项目的快速搭建对spring框架盛行了多年的java方向开发人员来说，每个人java开发已经把spring框架当做开发中不可或缺的一部分。之前传统的模式都是以applicationContext.xml配置文件的形式存在，而对应大多数入门级开发人员来说配置出现一点纰漏就会导致运行失败或者更大的问题，因此会浪费开发人员很多宝贵的时间，对公司来说也是有所损失。那么spring开源组织很早之前就意识到这种问题的存在，于是他们便对spring框架的全系列组件进行了内部封装。对外只是提供maven（jar管理、项目打包工具）或者gradle（新兴jar管理、项目打包工具）的形式来进行引入parent.pom（maven配置文件）或者parent.gradle（gradle配置文件），让每一个spring项目都是以spring的子项目的形式来运行，这样开发人员不用再去注重配置文件的繁琐而是把精力放到业务逻辑以及更深层次的架构方面。自此SpringBoot就诞生了，它有着纯正的开源血统，在此非常感谢spring开源组织给我们java开发人员带来的便利！ SpringBoot主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 提供一系列大型企业级项目的功能性特性（比如：安全、健康检测、外部化配置、数据库访问、restful搭建等很多特性这里就不一一叙说了，后期文章会陆续更新） 本章目的使用springboot完成一个简单的web（springmvc）应用程序，通过@restController输出”HelloWord”到界面，让我们初步体验springboot的快速开发、简单的特性。 系统要求 jdk1.8 springboot 1.5.2.RELEASE 开发工具（IntelliJ IDEA 2017.1.1） 数据库管理工具（Navicat Premium 11.1.7） 文本管理工具（sublime text 3） apache maven（3.3.9，本章采用maven形式管理jar包，具体配置环境变量以及使用请自行查找资料） 开始构建项目目前构建项目有多种方式我这里简单介绍两种。1、使用spring官网 SPRING INITIALIZR 来构建项目结构（地址：http://start.spring.io/）2、使用IntelliJ IDEA开发工具来构建项目结构 使用SPRING INITIALIZR构建访问start.spring.io/网址就会看到如下 “图1” 界面：界面主要部分包括：管理工具，springboot版本，包名（group），工程名（Artifact），已选模块（我已经选择了一个web模块）。点击Generate Project就会下载一个根据你输入的信息创建的项目工程架构源码的压缩包。解压压缩包到指定目录（目录你可以随意定义）我这里为了后续操作先定义到E:/lessions内可以看到如下“图2”所示：解压完成之后我们就可以通过IntelliJ IDEA开发工具导入到工程， 菜单中选择File–&gt;New–&gt;Project from Existing Sources… 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 若你的环境有多个版本的JDK，注意到选择Java SDK的时候请选择系统安装1.8版本 使用IntelliJ IDEA构建打开工具，界面如下 “图3” 所示：我们点击Create New Project来创建一个新的springboot应用程序，点击后如下“图4”所示：我们点击Next继续下一步操作，根据界面输入选项填写对应的内容即可如“图5”所示：点击Next即可完成创建项目，而且创建完成后会自动导入到项目工程内就不需要再次import操作，这种方式会比较简单些，所以我们的文章内都会采用第二种形式来创建新工程。 在下一步我们勾选Web依赖加入到我们的项目中，如下图所示： 项目目录结构我们来看看工具为我们生成新工程的目录结构，如”图6“所示：我们可以看到目录结构有如下几个： 1、/src/main/java/ 存放项目所有源代码目录2、/src//main/resources/ 存放项目所有资源文件以及配置文件目录3、/src/test/ 存放测试代码目录 自动生成的文件解释SpringBoot21Application 该类是程序的入口类内有个main方法，可以直接通过run as运行项目application.properties 该配置文件是项目的核心配置文件，以xx.xx.xx的形式存在pom.xml maven配置文件，因为我们采用的maven管理jar，所以这里会自动生成一个pom文件 @SpringBootApplication注解我们可以看到工具为我们自动生成的入口程序是有@SpringBootApplication的这么一个注解，那它主要是做什么的呢？不难看出，它是声明当前类为sprinboot的入口类。而一个springboot项目内有且只能有一个这个注解存在。 初尝试运行项目我们在入口程序类中右键-&gt;Run LessonOneApplication在控制台的输出如下”图8“所示，证明你已经成功的运行了springboot项目。 可以看到我们的项目是通过内置的tomcat容器启动的，并且端口号默认是8080（至于如何修改端口号后期文章中更新）。我们现在通过浏览器直接访问是得不到任何回应的，只是会有一个错误页面，如下”图9“所示 编写IndexController我们首先在/src/main/java/com/lqg (该目录是你构建项目的目录) 目录下创建一个叫做controller的包，然后在controller包下再创建一个叫做IndexController的类，我们使用@RestController来声明我们新创建的IndexController是一个访问控制器,详细代码如下： 12345678910111213package com.lqg.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String index()&#123; return "hello spring boot"; &#125;&#125; 可以看到我在IndexController类上配置了一个@RequestMapping注解来声明index()方法可以通过127.0.0.1:8080/index访问到，那么我们接下来重新启动项目（项目中如果重启出错应该是注解配置问题），访问地址如下”图10“所示：在IndexController类里面在写一个方法，返回值是map集合，参数列表是String类型的name，@RequestParam简单类型的绑定的注解，这个注解要放在参数列表的前面 123456789101112131415161718192021222324252627282930package com.lqg.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String hello()&#123; return "hello spring boot "; &#125; /** * @RequestParam 简单类型的绑定，可以出来get和post * @param name * @return */ @RequestMapping(value = "/get") public HashMap&lt;String,Object&gt; get(@RequestParam String name)&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("title", "hello world"); map.put("name", name); return map; &#125;&#125; 那么Controller层是如何返回一个Bean对象呢？先在/src/main/java/com/lqg下面创建一个bean包，在bean包里创建一个User类，详细代码如下： 123456789101112131415161718package com.lqg.bean;import lombok.Getter;import lombok.Setter;import java.util.Date;/** * @author 凌枫lqg */@Getter@Setterpublic class User &#123; private int id; private String name; private Date date;&#125; @Getter@Setter：注解是lombok插件里面的，用这个注解就可以省略getter和setter方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.lqg.controller;import com.lqg.bean.User;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.xml.crypto.Data;import java.util.Date;import java.util.HashMap;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String hello()&#123; return "hello spring boot "; &#125; /** * @RequestParam 简单类型的绑定，可以出来get和post * @param name * @return */ @RequestMapping(value = "/get") public HashMap&lt;String,Object&gt; get(@RequestParam String name)&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("title", "hello world"); map.put("name", name); return map; &#125; /** * @PathVariable 获得请求url中的动态参数 * @param id * @param name * @return */ @RequestMapping(value = "/find/&#123;id&#125;/&#123;name&#125;") public User get(@PathVariable int id,@PathVariable String name)&#123; User user = new User(); user.setId(id); user.setName(name); user.setDate(new Date()); return user; &#125;&#125; 第二个方法访问的结果如下第三个方法访问的结果如下： SpringBoot的测试SpringBoot测试可以通过Spring提供的测试类MockMvc 123456789101112131415161718192021222324252627282930313233343536373839package com.lqg;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import com.lqg.controller.IndexController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import com.lqg.controller.IndexController;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootDemo21ApplicationTests &#123; //SpringBoot测试可以通过Spring提供的测试类MockMvc private MockMvc mvc; @Before public void setup() &#123; //这是通过setup方法引入mvc this.mvc = MockMvcBuilders.standaloneSetup(new IndexController()).build(); &#125; @Test public void contextLoads() throws Exception &#123; //生成request一个请求 RequestBuilder request = get("/index"); //用mvc的请求，期望它的状态码是ok的，期望它返回的内容，返回的是一个字符串hello spring boot mvc.perform(request).andExpect(status().isOk()).andExpect(content().string("hello spring boot")); &#125;&#125; SpringBoot打包 打包成功后的jar包，打包命令mvn clean install -DskipTests 在命令行运行spring boot]]></content>
  </entry>
</search>
