<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F23%2F%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Spring-Boot%E5%9C%A8idea%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Redis入门，读这一篇就够了]]></title>
    <url>%2F2019%2F08%2F23%2FRedis%E5%85%A5%E9%97%A8%EF%BC%8C%E8%AF%BB%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[目录 一. redis 1.1.什么是NOSQL 1.1.1. NOSQL和关系型数据库比较 1.1.2. 非关系型数据库的优势： 1.1.3. 关系型数据库的优势： 1.1.4. 总结 1.2.主流的NOSQL产品 1.3 什么是Redis 1.3.1 redis的应用场景(重要) 二. 下载安装 三. 命令操作 1. redis的数据结构： 2. 字符串类型 string 3. 哈希类型 hash 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 5. 集合类型 set ： 不允许重复元素 6. 有序集合类型 sortedset： 7. 通用命令 四. 持久化 五. Java客户端 Jedis 六. 案例： 一. redis**概念**： redis是一款高性能的NOSQL系列的非关系型数据库1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较**优点：** 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关 系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql 数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 ​ 缺点： 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 1） 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候 使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在 nosql 数据库中备份存储关系型数据库的数据1.2.主流的NOSQL产品• 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset1.3.1 redis的应用场景(重要)• 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离二. 下载安装1. [官网](https://redis.io) 2. [Redis中文网](http://www.redis.net.cn/) 3. 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端三. 命令操作1. redis的数据结构： redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构： 字符串类型 string 哈希类型 hash ： map格式 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 13. 哈希类型 hash**1. 存储**： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 **2. 获取**： hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; **3. 删除**： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 14. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素**1. 存储**：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 **2. 获取**：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; **3. 删除**：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 16. 有序集合类型 sortedset：​ 不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 ​ 1. 存储：zadd key score value​ 127.0.0.1:6379&gt; zadd mysort 60 zhangsan​ (integer) 1​ 127.0.0.1:6379&gt; zadd mysort 50 lisi​ (integer) 1​ 127.0.0.1:6379&gt; zadd mysort 80 wangwu​ (integer) 1​ 2. 获取：zrange key start end [withscores]​ 127.0.0.1:6379&gt; zrange mysort 0 -1​ 1) “lisi”​ 2) “zhangsan”​ 3) “wangwu” ​ 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores​ 1) “zhangsan”​ 2) “60”​ 3) “wangwu”​ 4) “80”​ 5) “lisi”​ 6) “500”​ 3. 删除：zrem key value​ 127.0.0.1:6379&gt; zrem mysort lisi​ (integer) 1 7. 通用命令1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value四. 持久化1. redis是一个内存数据库​ 当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制：1. RDB：默认方式，不需要进行配置，默认就使用这种机制在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 after 900 sec (15 min) if at least 1 key changed save 900 1 after 300 sec (5 min) if at least 10 keys changed save 300 10 after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） \# appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 \# appendfsync no ： 不进行持久化五. Java客户端 Jedis​ Jedis: 一款java操作redis数据库的工具.​ 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(“localhost”,6379); //2. 操作 jedis.set(“username”,”zhangsan”); //3. 关闭连接 jedis.close(); ​ Jedis操作各种redis中的数据结构​ 1) 字符串类型 string​ set​ get​​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ //存储​ jedis.set(“username”,”zhangsan”);​ //获取​ String username = jedis.get(“username”);​ System.out.println(username);​​ //可以使用setex()方法存储可以指定过期时间的 key value​ jedis.setex(“activecode”,20,”hehe”);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对​​ //3. 关闭连接​ jedis.close(); ​ 2) 哈希类型 hash ： map格式​ hset​ hget​ hgetAll​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ // 存储hash​ jedis.hset(“user”,”name”,”lisi”);​ jedis.hset(“user”,”age”,”23”);​ jedis.hset(“user”,”gender”,”female”);​​ // 获取hash​ String name = jedis.hget(“user”, “name”);​ System.out.println(name);​​​ // 获取hash的所有map中的数据​ Map&lt;String, String&gt; user = jedis.hgetAll(“user”);​​ // keyset​ Set keySet = user.keySet();​ for (String key : keySet) {​ //获取value​ String value = user.get(key);​ System.out.println(key + “:” + value);​ }​​ //3. 关闭连接​ jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​​​ // set 存储​ jedis.sadd(“myset”,”java”,”php”,”c++”);​​ // set 获取​ Set myset = jedis.smembers(“myset”);​ System.out.println(myset);​​ //3. 关闭连接​ jedis.close();​ 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序​ zadd​ zrange ​ //1. 获取连接​ Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口​ //2. 操作​ // sortedset 存储​ jedis.zadd(“mysortedset”,3,”亚瑟”);​ jedis.zadd(“mysortedset”,30,”后裔”);​ jedis.zadd(“mysortedset”,55,”孙悟空”);​​ // sortedset 获取​ Set mysortedset = jedis.zrange(“mysortedset”, 0, -1);​​ System.out.println(mysortedset);​​​ //3. 关闭连接​ jedis.close(); jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils {​ private static JedisPool jedisPool;​​ static{​ //读取配置文件​ InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(“jedis.properties”);​ //创建Properties对象​ Properties pro = new Properties();​ //关联文件​ try {​ pro.load(is);​ } catch (IOException e) {​ e.printStackTrace();​ }​ //获取数据，设置到JedisPoolConfig中​ JedisPoolConfig config = new JedisPoolConfig();​ config.setMaxTotal(Integer.parseInt(pro.getProperty(“maxTotal”)));​ config.setMaxIdle(Integer.parseInt(pro.getProperty(“maxIdle”)));​​ //初始化JedisPool​ jedisPool = new JedisPool(config,pro.getProperty(“host”),Integer.parseInt(pro.getProperty(“port”)));​​​​ }​​​ /*​ \ 获取连接方法​ */​ public static Jedis getJedis(){​ return jedisPool.getResource();​ }​ } 六. 案例：​ 案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 注意：使用redis缓存一些不经常发生变化的数据。* 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。]]></content>
      <categories>
        <category>非关系型数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot配置文件详解：Properties和YAML]]></title>
    <url>%2F2019%2F08%2F23%2FSpring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%EF%BC%9AProperties%E5%92%8CYAML%2F</url>
    <content type="text"><![CDATA[配置文件详解：Properties和YAML一.配置文件的生效顺序，会对值进行覆盖： @TestPropertySource 注解 命令行参数 Java系统属性（System.getProperties()） 操作系统环境变量 只有在random.*里包含的属性会产生一个RandomValuePropertySource 在properties文件中设置随机值，随机数等 123456789101112131415161718192021222324252627#这个优先级较低#32位随机字符串roncoo.secret=$&#123;random.value&#125;#int类型的随机数字roncoo.number=$&#123;random.int&#125;roncoo.name=www.roncoo.com#属性占位符属性roncoo.desc=$&#123;roncoo.name&#125; is a domain name#应用端口server.port=8090#时间格式化spring.jackson.date-format=yyyy-MM-dd HH:mm:ss#时区设置spring.jackson.time-zone=Asia/Chongqing 在IndexController层中获取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.roncoo.education.controller;import java.util.Date;import java.util.HashMap;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.roncoo.education.bean.User;/** * spring-boot-demo-3-1 * * @author wujing */@RestController@RequestMapping(value = "/index")public class IndexController &#123; @Value(value = "$&#123;roncoo.secret&#125;") private String secret; @Value(value = "$&#123;roncoo.number&#125;") private int id; @Value(value = "$&#123;roncoo.desc&#125;") private String desc; @RequestMapping public String index() &#123; return "hello world"; &#125; // @RequestParam 简单类型的绑定，可以出来get和post @RequestMapping(value = "/get") public HashMap&lt;String, Object&gt; get(@RequestParam String name) &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("title", "hello world"); map.put("name", name); map.put("secret", secret); map.put("id", id); map.put("desc", desc); return map; &#125; // @PathVariable 获得请求url中的动态参数 @RequestMapping(value = "/get/&#123;id&#125;/&#123;name&#125;") public User getUser(@PathVariable int id, @PathVariable String name) &#123; User user = new User(); user.setId(id); user.setName(name); user.setDate(new Date()); return user; &#125;&#125; 二．配置随机值roncoo.secret=${random.value} roncoo.number=${random.int} roncoo.bignumber=${random.long} roncoo.number.less.than.ten=${random.int(10)} roncoo.number.in.range=${random.int[1024,65536]} 读取使用注解：@Value(value = “${roncoo.secret}”) 注：出现黄点提示，是要提示配置元数据，可以不配置 在打包的jar外的应用程序配置文件（application.properties，包含YAML和profile变量） 在打包的jar内的应用程序配置文件（application.properties，包含YAML和profile变量） 在@Configuration类上的@PropertySource注解 默认属性（使用SpringApplication.setDefaultProperties指定） 三．属性占位符当application.properties里的值被使用时，它们会被存在的Environment过滤，所以你能够引用先前定义的值（比如，系统属性）。 roncoo.name=www.roncoo.com roncoo.desc=${roncoo.name} is a domain name 四．Application属性文件，按优先级排序，位置高的将覆盖位置低的 当前目录下的一个/config子目录 当前目录 一个classpath下的/config包 classpath根路径（root） 这个列表是按优先级排序的（列表中位置高的将覆盖位置低的） 五. 配置应用端口和其他配置的介绍#端口配置： server.port=8090 #时间格式化 spring.jackson.date-format=yyyy-MM-dd HH:mm:ss #时区设置 spring.jackson.time-zone=Asia/Chongqing 六. 使用YAML代替Properties注意写法：冒号后要加个空格]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章，教你学会Git]]></title>
    <url>%2F2019%2F08%2F23%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E6%95%99%E4%BD%A0%E5%AD%A6%E4%BC%9AGit%2F</url>
    <content type="text"><![CDATA[一篇文章，教你学会Git 在日常工作中，经常会用到Git操作。但是对于新人来讲，刚上来对Git很陌生，操作起来也很懵逼。本篇文章主要针对刚开始接触Git的新人，理解Git的基本原理，掌握常用的一些命令。 一、Git工作流程 以上包括一些简单而常用的命令，但是先不关心这些，先来了解下面这4个专有名词。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 工作区 程序员进行开发改动的地方，是你当前看到的，也是最新的。 平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。 暂存区 .git目录下的index文件, 暂存区会记录git add添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用git status查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。 当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过git add先提交到暂存区，被git管理。 本地仓库 保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。 git commit后同步index的目录树到本地仓库，方便从下一步通过git push同步本地仓库与远程仓库的同步。 远程仓库 远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。 小结 任何对象都是在工作区中诞生和被修改； 任何修改都是从进入index区才开始被版本控制； 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹； 与协作者分享本地的修改，可以把它们push到远程仓库来共享。 下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。 二、常用Git命令 网上找了个图，别人整理的一张图，很全很好，借来用下。下面详细解释一些常用命令。 HEAD 在掌握具体命令前，先理解下HEAD。 HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。 add add相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。 git add . 添加当前目录的所有文件到暂存区 git add 添加指定目录到暂存区，包括子目录 git add 添加指定文件到暂存区 commit commit相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。 git commit -m 提交暂存区到本地仓库,message代表说明信息 git commit -m 提交暂存区的指定文件到本地仓库 git commit –amend -m 使用一次新的commit，替代上一次提交 branch 涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 git branch 新建一个分支，但依然停留在当前分支 git checkout -b 新建一个分支，并切换到该分支 git branch –track 新建一个分支，与指定的远程分支建立追踪关系 git checkout 切换到指定分支，并更新工作区 git branch -d 删除分支 git push origin –delete 删除远程分支 关于分支的操作虽然比较多，但都比较简单好记。 merge merge命令把不同的分支合并起来。如上图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。 git fetch merge之前先拉一下远程仓库最新代码 git merge 合并指定分支到当前分支 一般在merge之后，会出现conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。如下图所示，需要手动解除。 rebase rebase又称为衍合，是合并的另外一种选择。 在开始阶段，我们处于new分支上，执行git rebase dev，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。git rebase dev，通俗的解释就是new分支想站在dev的肩膀上继续下去。rebase也需要手动解决冲突。 rebase与merge的区别 现在我们有这样的两个分支,test和master，提交如下： 123456789D---E test /A---B---C---F master 在master执行git merge test,然后会得到如下结果： 123456789D--------E / \A---B---C---F----G test, master 在master执行git rebase test，然后得到如下结果： 1A---B---D---E---C&apos;---F&apos; test, master 可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。 如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge reset reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。 git reset —soft 只改变提交点，暂存区和工作目录的内容都不改变 git reset —mixed 改变提交点，同时改变暂存区的内容 git reset —hard 暂存区、工作区的内容都会被修改到与提交点完全一致的状态 git reset –hard HEAD 让工作区回到上次提交时的状态 revert git revert用一个新提交来消除一个历史提交所做的任何修改。 revert与reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 push上传本地仓库分支到远程仓库分支，实现同步。 git push 上传本地指定分支到远程仓库 git push –force 强行推送当前分支到远程仓库，即使有冲突 git push –all 推送所有分支到远程仓库 其他命令 git status 显示有变更的文件 git log 显示当前分支的版本历史 git diff 显示暂存区和工作区的差异 git diff HEAD 显示工作区与当前分支最新commit之间的差异 git cherry-pick 选择一个commit，合并进当前分支 以上就是关于Git的一些常用命令及详细阐述，相信能对Git有一个初步的认识。]]></content>
      <categories>
        <category>Git管理工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTfull API简单项目的快速搭建]]></title>
    <url>%2F2019%2F08%2F23%2FRESTfull-API%E7%AE%80%E5%8D%95%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[RESTfull API简单项目的快速搭建对spring框架盛行了多年的java方向开发人员来说，每个人java开发已经把spring框架当做开发中不可或缺的一部分。之前传统的模式都是以applicationContext.xml配置文件的形式存在，而对应大多数入门级开发人员来说配置出现一点纰漏就会导致运行失败或者更大的问题，因此会浪费开发人员很多宝贵的时间，对公司来说也是有所损失。那么spring开源组织很早之前就意识到这种问题的存在，于是他们便对spring框架的全系列组件进行了内部封装。对外只是提供maven（jar管理、项目打包工具）或者gradle（新兴jar管理、项目打包工具）的形式来进行引入parent.pom（maven配置文件）或者parent.gradle（gradle配置文件），让每一个spring项目都是以spring的子项目的形式来运行，这样开发人员不用再去注重配置文件的繁琐而是把精力放到业务逻辑以及更深层次的架构方面。自此SpringBoot就诞生了，它有着纯正的开源血统，在此非常感谢spring开源组织给我们java开发人员带来的便利！ SpringBoot主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 提供一系列大型企业级项目的功能性特性（比如：安全、健康检测、外部化配置、数据库访问、restful搭建等很多特性这里就不一一叙说了，后期文章会陆续更新） 本章目的使用springboot完成一个简单的web（springmvc）应用程序，通过@restController输出”HelloWord”到界面，让我们初步体验springboot的快速开发、简单的特性。 系统要求 jdk1.8 springboot 1.5.2.RELEASE 开发工具（IntelliJ IDEA 2017.1.1） 数据库管理工具（Navicat Premium 11.1.7） 文本管理工具（sublime text 3） apache maven（3.3.9，本章采用maven形式管理jar包，具体配置环境变量以及使用请自行查找资料） 开始构建项目目前构建项目有多种方式我这里简单介绍两种。1、使用spring官网 SPRING INITIALIZR 来构建项目结构（地址：http://start.spring.io/）2、使用IntelliJ IDEA开发工具来构建项目结构 使用SPRING INITIALIZR构建访问start.spring.io/网址就会看到如下 “图1” 界面：界面主要部分包括：管理工具，springboot版本，包名（group），工程名（Artifact），已选模块（我已经选择了一个web模块）。点击Generate Project就会下载一个根据你输入的信息创建的项目工程架构源码的压缩包。解压压缩包到指定目录（目录你可以随意定义）我这里为了后续操作先定义到E:/lessions内可以看到如下“图2”所示：解压完成之后我们就可以通过IntelliJ IDEA开发工具导入到工程， 菜单中选择File–&gt;New–&gt;Project from Existing Sources… 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 若你的环境有多个版本的JDK，注意到选择Java SDK的时候请选择系统安装1.8版本 使用IntelliJ IDEA构建打开工具，界面如下 “图3” 所示：我们点击Create New Project来创建一个新的springboot应用程序，点击后如下“图4”所示：我们点击Next继续下一步操作，根据界面输入选项填写对应的内容即可如“图5”所示：点击Next即可完成创建项目，而且创建完成后会自动导入到项目工程内就不需要再次import操作，这种方式会比较简单些，所以我们的文章内都会采用第二种形式来创建新工程。 在下一步我们勾选Web依赖加入到我们的项目中，如下图所示： 项目目录结构我们来看看工具为我们生成新工程的目录结构，如”图6“所示：我们可以看到目录结构有如下几个： 1、/src/main/java/ 存放项目所有源代码目录2、/src//main/resources/ 存放项目所有资源文件以及配置文件目录3、/src/test/ 存放测试代码目录 自动生成的文件解释SpringBoot21Application 该类是程序的入口类内有个main方法，可以直接通过run as运行项目application.properties 该配置文件是项目的核心配置文件，以xx.xx.xx的形式存在pom.xml maven配置文件，因为我们采用的maven管理jar，所以这里会自动生成一个pom文件 @SpringBootApplication注解我们可以看到工具为我们自动生成的入口程序是有@SpringBootApplication的这么一个注解，那它主要是做什么的呢？不难看出，它是声明当前类为sprinboot的入口类。而一个springboot项目内有且只能有一个这个注解存在。 初尝试运行项目我们在入口程序类中右键-&gt;Run LessonOneApplication在控制台的输出如下”图8“所示，证明你已经成功的运行了springboot项目。 可以看到我们的项目是通过内置的tomcat容器启动的，并且端口号默认是8080（至于如何修改端口号后期文章中更新）。我们现在通过浏览器直接访问是得不到任何回应的，只是会有一个错误页面，如下”图9“所示 编写IndexController我们首先在/src/main/java/com/lqg (该目录是你构建项目的目录) 目录下创建一个叫做controller的包，然后在controller包下再创建一个叫做IndexController的类，我们使用@RestController来声明我们新创建的IndexController是一个访问控制器,详细代码如下： 1234567891011121314package com.lqg.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String index()&#123; return "hello spring boot"; &#125;&#125;12345678910111213 可以看到我在IndexController类上配置了一个@RequestMapping注解来声明index()方法可以通过127.0.0.1:8080/index访问到，那么我们接下来重新启动项目（项目中如果重启出错应该是注解配置问题），访问地址如下”图10“所示：在IndexController类里面在写一个方法，返回值是map集合，参数列表是String类型的name，@RequestParam简单类型的绑定的注解，这个注解要放在参数列表的前面 1234567891011121314151617181920212223242526272829303132package com.lqg.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String hello()&#123; return "hello spring boot "; &#125; /** * @RequestParam 简单类型的绑定，可以出来get和post * @param name * @return */ @RequestMapping(value = "/get") public HashMap&lt;String,Object&gt; get(@RequestParam String name)&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("title", "hello world"); map.put("name", name); return map; &#125;&#125;12345678910111213141516171819202122232425262728293031 那么Controller层是如何返回一个Bean对象呢？先在/src/main/java/com/lqg下面创建一个bean包，在bean包里创建一个User类，详细代码如下： 1234567891011121314151617181920package com.lqg.bean;import lombok.Getter;import lombok.Setter;import java.util.Date;/** * @author 凌枫lqg */@Getter@Setterpublic class User &#123; private int id; private String name; private Date date;&#125;12345678910111213141516171819 @Getter@Setter：注解是lombok插件里面的，用这个注解就可以省略getter和setter方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lqg.controller;import com.lqg.bean.User;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.xml.crypto.Data;import java.util.Date;import java.util.HashMap;@RestController@RequestMapping(value = "/index")public class IndexController &#123; @RequestMapping public String hello()&#123; return "hello spring boot "; &#125; /** * @RequestParam 简单类型的绑定，可以出来get和post * @param name * @return */ @RequestMapping(value = "/get") public HashMap&lt;String,Object&gt; get(@RequestParam String name)&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("title", "hello world"); map.put("name", name); return map; &#125; /** * @PathVariable 获得请求url中的动态参数 * @param id * @param name * @return */ @RequestMapping(value = "/find/&#123;id&#125;/&#123;name&#125;") public User get(@PathVariable int id,@PathVariable String name)&#123; User user = new User(); user.setId(id); user.setName(name); user.setDate(new Date()); return user; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 第二个方法访问的结果如下第三个方法访问的结果如下： SpringBoot的测试SpringBoot测试可以通过Spring提供的测试类MockMvc 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lqg;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import com.lqg.controller.IndexController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import com.lqg.controller.IndexController;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootDemo21ApplicationTests &#123; //SpringBoot测试可以通过Spring提供的测试类MockMvc private MockMvc mvc; @Before public void setup() &#123; //这是通过setup方法引入mvc this.mvc = MockMvcBuilders.standaloneSetup(new IndexController()).build(); &#125; @Test public void contextLoads() throws Exception &#123; //生成request一个请求 RequestBuilder request = get("/index"); //用mvc的请求，期望它的状态码是ok的，期望它返回的内容，返回的是一个字符串hello spring boot mvc.perform(request).andExpect(status().isOk()).andExpect(content().string("hello spring boot")); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940 SpringBoot打包 打包成功后的jar包，打包命令mvn clean install -DskipTests 在命令行运行spring boot]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea中如何导入mysql驱动包]]></title>
    <url>%2F2019%2F08%2F23%2Fidea%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5mysql%E9%A9%B1%E5%8A%A8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[IDEA怎样导入mysql的驱动包注：刚开始用用csdn写博文，写的不好，还请各位博客好友见谅，也可以互相提意见，共同进步！首先需要有mysql的驱动包，没有可以在mysql官网下载 有了驱动包后，就开始进入怎样用IDEA导入mysql驱动包了 1. 打开你的idea工程，点击File2.找到Project Structure并点击3.找到Modules并点击4.找到Dependencies并点击2.找到Project Structure并点击5.找到Scope右边的+号并点击2.选第一个JARs or directories，找到文件mysql-connector-java-版本号-bin.jar，然后点击ok就成功了]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019最新的解决百度网盘下载限速的方法，不限速下载百度云破解版]]></title>
    <url>%2F2019%2F08%2F23%2F2019%E6%9C%80%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%B8%8B%E8%BD%BD%E9%99%90%E9%80%9F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%99%90%E9%80%9F%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E4%BA%91%E7%A0%B4%E8%A7%A3%E7%89%88%2F</url>
    <content type="text"><![CDATA[2019最新的解决百度网盘下载限速的方法，不限速下载百度云破解版下载地址，点击下载，提取码：c25f 永久有效https://pan.baidu.com/s/1G2X8diMTPzTyC_oOvgkyWw 不限速下载以下为软件使用教程，必看 软件使用教程：首先：在打开软件以后先观察是否弹出更新提示，如果有更新提示则必须要更新，一般选择在线自动更新。 第一步，把压缩包下载并解压到你的电脑上，但不要解压到C盘和桌面上。解压完成以后文件夹里的文件如图所示图中用红圈圈出来的文件就是运行的主程序第二步：点击红框中的文件会出现下图中的样子第三步：然后登陆自己的网盘账号以后开始下载情况1、下载自己网盘里的东西 登录之后找到你网盘里的想要下载的文件（不要直接点下载），点击“分享并下载”，然后再确认下载就OK了。 情况2、如果下载在别处获得的链接，请在“下载”栏目下面的“下载分享链接”处下载。如果出现无限验证码或其他错误也可以先保存到自己网盘，然后用1中的方法。软件非常好用，需要的同学可以点击下载了：链接：https://pan.baidu.com/s/1G2X8diMTPzTyC_oOvgkyWw&gt; 提取码：c25f 永久有效]]></content>
      <categories>
        <category>百度云</category>
      </categories>
      <tags>
        <tag>baiduyun</tag>
      </tags>
  </entry>
</search>
